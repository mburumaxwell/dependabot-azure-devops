// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../.prisma"
}

datasource db {
  provider = "mongodb"
  url      = env("MONGO_DATABASE_URL")
}

model User {
  id            String       @id @map("_id")
  name          String
  email         String
  emailVerified Boolean      @default(false)
  image         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now()) @updatedAt
  role          String?
  banned        Boolean?     @default(false)
  banReason     String?
  banExpires    DateTime?
  sessions      Session[]
  accounts      Account[]
  members       Member[]
  invitations   Invitation[]
  passkeys      Passkey[]

  @@unique([email])
  @@map("user")
}

model Session {
  id                   String   @id @map("_id")
  expiresAt            DateTime
  token                String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy       String?
  activeOrganizationId String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

enum OrganizationType {
  azure
  gitlab
  bitbucket

  @@map("organization_type")
}

enum SubscriptionStatus {
  active
  inactive
  past_due
  canceled

  @@map("subscription_status")
}

enum OrganizationTier {
  free
  pro
  enterprise

  @@map("organization_tier")
}

enum OrganizationBillingInterval {
  monthly
  yearly

  @@map("organization_billing_interval")
}

model Organization {
  id                  String                      @id @map("_id")
  name                String
  slug                String?
  logo                String?
  createdAt           DateTime
  metadata            String?
  members             Member[]
  invitations         Invitation[]
  type                OrganizationType
  url                 String
  region              String
  providerHostname    String
  providerApiEndpoint String
  tier                OrganizationTier
  billingInterval     OrganizationBillingInterval
  billingEmail        String?
  customerId          String?
  subscriptionId      String?
  subscriptionStatus  SubscriptionStatus?
  maxProjects         Int                         @default(0) // zero until updated after billing setup
  credential          OrganizationCredential?
  secrets             OrganizationSecret[]
  projects            Project[]
  jobs                UpdateJob[]

  @@unique([slug])
  @@unique([url])
  @@index([type])
  @@index([region])
  @@map("organization")
}

model Member {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  createdAt      DateTime

  @@map("member")
}

model Invitation {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@map("invitation")
}

model Passkey {
  id           String    @id @map("_id")
  name         String?
  publicKey    String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?
  aaguid       String?

  @@map("passkey")
}

enum FeedbackAction {
  organization_leave @map("organization.leave")
  user_delete        @map("user.delete")

  @@map("feedback_action")
}

model Feedback {
  id        String         @id @map("_id")
  createdAt DateTime       @default(now())
  action    FeedbackAction
  message   String
  metadata  String?

  @@map("feedback")
}

// Credentials are stored in a separate table/collection for security reasons.
// This way they are only queried when needed and not by accident when pulling
// organization data.

model OrganizationCredential {
  id                   String       @id @map("_id")
  organization         Organization @relation(fields: [id], references: [id], onDelete: Cascade)
  token                String
  tokenSecretUrl       String? // Hopefully won't need secret store with federated identity
  /// Token (password) for Webhooks, ServiceHooks, and Notifications from the provider.
  /// This is generated on creation and may be shown on demand but cannot be edited.
  webhooksToken        String
  githubTokenSecretUrl String?

  @@map("organization_credential")
}

model OrganizationSecret {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  secretUrl      String?

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([name])
  @@map("organization_secret")
}

enum SynchronizationStatus {
  pending
  success
  failed

  @@map("synchronization_status")
}

model Project {
  id                    String                @id @map("_id")
  organizationId        String
  organization          Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  providerId            String
  name                  String
  url                   String
  /// The link that never changes even if the name changes (only for some providers).
  /// This tends to be the API url for the project.
  permalink             String
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  maxRepositories       Int                   @default(0) // zero until updated after billing setup
  synchronizationStatus SynchronizationStatus
  synchronizedAt        DateTime?
  repositories          Repository[]
  jobs                  UpdateJob[]

  @@unique([organizationId, providerId])
  @@index([organizationId])
  @@map("project")
}

model Repository {
  id                    String                @id @map("_id")
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  projectId             String
  project               Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  providerId            String
  name                  String
  url                   String
  /// The link that never changes even if the name changes (only for some providers).
  /// This tends to be the API url for the repository.
  permalink             String
  slug                  String
  /// Latest commit SHA synchronized for the configuration file.
  latestCommit          String?
  /// Contents of the configuration file as of the latest commit.
  configFileContents    String?
  configPath            String?
  /// Error that encountered, if any, when parsing the configuration file.
  synchronizationError  String?
  synchronizationStatus SynchronizationStatus
  synchronizedAt        DateTime?
  updates               RepositoryUpdate[]
  jobs                  UpdateJob[]

  @@unique([projectId, providerId])
  @@unique([url])
  @@index([projectId])
  @@index([providerId])
  @@map("repository")
}

model RepositoryUpdate {
  id                    String           @id @map("_id")
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  repository            Repository       @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  repositoryId          String
  enabled               Boolean
  ecosystem             String
  directory             String?
  directories           String[]
  /// Either the original directory or merger of directories.
  directoryKey          String
  /// Cron schedule for running this update
  cron                  String
  timezone              String
  files                 String[]
  jobs                  UpdateJob[]
  latestUpdateJobId     String?
  latestUpdateJobStatus UpdateJobStatus?
  latestUpdateJobAt     DateTime?
  nextUpdateJobAt       DateTime?

  @@unique([repositoryId, ecosystem, directoryKey])
  @@index([repositoryId])
  @@map("repository_update")
}

enum UpdateJobTrigger {
  scheduled
  synchronization
  manual

  @@map("update_job_trigger")
}

enum UpdateJobStatus {
  scheduled
  running
  succeeded
  failed

  @@map("update_job_status")
}

enum UpdateJobPlatform {
  azure_pipelines @map("azure.pipelines")
  azure_vms       @map("azure.vms")
  azure_aca       @map("azure.aca")
  azure_aci       @map("azure.aci")
}

model UpdateJob {
  id        String            @id @map("_id")
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  status    UpdateJobStatus
  trigger   UpdateJobTrigger
  platform  UpdateJobPlatform

  organizationId     String
  projectId          String
  repositoryId       String
  repositoryUpdateId String
  // no delete cascade, records here retained for billing and analytics
  organization       Organization     @relation(fields: [organizationId], references: [id], onDelete: NoAction)
  project            Project          @relation(fields: [projectId], references: [id], onDelete: NoAction)
  repository         Repository       @relation(fields: [repositoryId], references: [id], onDelete: NoAction)
  repositoryUpdate   RepositoryUpdate @relation(fields: [repositoryUpdateId], references: [id], onDelete: NoAction)

  repositorySlug String

  /// Commit SHA of the configuration file used for the update.
  commit          String
  /// Ecosystem for the update (e.g., npm, pip, etc.)
  ecosystem       String
  directory       String?
  directories     String[]
  /// Either the original directory or merger of directories.
  directoryKey    String
  workflowRunId   String
  config          String // JSON stringified DependabotJobConfig
  credentials     String // JSON stringified DependabotCredential[]
  secret          UpdateJobSecret?
  startedAt       DateTime?
  finishedAt      DateTime?
  /// Duration in milliseconds.
  duration        Int?
  /// URL to view the logs of the job (used when running on customer infra e.g. azure pipelines).
  externalLogsUrl String?
  /// URL to download the logs of the job (used when running on our infra).
  downloadLogsUrl String?
  errorType       String?
  errorDetails    String? // JSON stringified Record<string, any>
  affectedPrIds   Int[]

  @@unique([ecosystem, directoryKey, workflowRunId])
  @@index([organizationId])
  @@index([projectId])
  @@index([repositoryId])
  @@index([repositoryUpdateId])
  @@map("update_job")
}

/// Secret used to authorize update jobs when they make API calls.
/// This is stored separately to avoid accidental exposure.

model UpdateJobSecret {
  id               String    @id @map("_id")
  job              UpdateJob @relation(fields: [id], references: [id], onDelete: Cascade)
  jobToken         String
  credentialsToken String

  @@unique([jobToken])
  @@unique([credentialsToken])
  @@map("update_job_secret")
}
