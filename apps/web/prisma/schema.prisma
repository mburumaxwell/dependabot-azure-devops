// This is your Prisma schema file,
// https://www.prisma.io/docs/orm/prisma-schema/overview

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../.generated/prisma"
}

generator json {
  // an alternative to https://github.com/prisma/prisma/issues/3219

  provider  = "prisma-json-types-generator"
  namespace = "PrismaJson"
  allowAny  = false
}

model User {
  id            String       @id
  name          String
  email         String
  emailVerified Boolean      @default(false)
  image         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  role          String?
  banned        Boolean?     @default(false)
  banReason     String?
  banExpires    DateTime?
  sessions      Session[]
  accounts      Account[]
  members       Member[]
  invitations   Invitation[]
  passkeys      Passkey[]

  @@unique([email])
  @@map("user")
}

model Session {
  id                   String   @id
  expiresAt            DateTime
  token                String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy       String?
  activeOrganizationId String?

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Organization {
  id                  String                  @id
  name                String
  slug                String
  logo                String?
  createdAt           DateTime
  metadata            String?
  /// [OrganizationType]
  type                String
  url                 String
  /// [RegionCode]
  region              String
  providerHostname    String
  providerApiEndpoint String
  customerId          String?
  subscriptionId      String?
  /// [SubscriptionStatus]
  subscriptionStatus  String?
  /// [Period]
  billingPeriod       Json?
  members             Member[]
  invitations         Invitation[]
  credential          OrganizationCredential?
  secrets             OrganizationSecret[]
  projects            Project[]

  @@unique([slug])
  @@unique([url])
  @@index([type])
  @@index([region])
  @@map("organization")
}

model Member {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String       @default("member")
  createdAt      DateTime

  @@index([organizationId])
  @@index([userId])
  @@map("member")
}

model Invitation {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String       @default("pending")
  expiresAt      DateTime
  createdAt      DateTime     @default(now())
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([email])
  @@map("invitation")
}

model Passkey {
  id           String    @id
  name         String?
  publicKey    String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?
  aaguid       String?

  @@index([userId])
  @@index([credentialID])
  @@map("passkey")
}

model Feedback {
  id        String         @id
  createdAt DateTime       @default(now())
  // [FeedbackAction]
  action    String
  message   String
  metadata  String?

  @@map("feedback")
}

// Credentials are stored in a separate table/collection for security reasons.
// This way they are only queried when needed and not by accident when pulling
// organization data.

model OrganizationCredential {
  id                   String       @id
  organization         Organization @relation(fields: [id], references: [id], onDelete: Cascade)
  token                String
  tokenSecretUrl       String? // Hopefully won't need secret store with federated identity
  /// Token (password) for Webhooks, ServiceHooks, and Notifications from the provider.
  /// This is generated on creation and may be shown on demand but cannot be edited.
  webhooksToken        String
  githubTokenSecretUrl String?

  @@map("organization_credential")
}

model OrganizationSecret {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String
  /// [RegionCode]
  region         String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  secretUrl      String?
  description    String?

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([name])
  @@map("organization_secret")
}

model Project {
  id                    String                @id
  organizationId        String
  organization          Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  providerId            String
  name                  String
  url                   String
  /// The link that never changes even if the name changes (only for some providers).
  /// This tends to be the API url for the project.
  permalink             String
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  /// [SynchronizationStatus]
  synchronizationStatus String
  synchronizedAt        DateTime?
  repositories          Repository[]

  @@index([organizationId])
  @@index([providerId])
  @@index([organizationId, providerId])
  @@map("project")
}

model Repository {
  id                    String                  @id
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  projectId             String
  project               Project                 @relation(fields: [projectId], references: [id], onDelete: Cascade)
  providerId            String
  name                  String
  url                   String
  /// The link that never changes even if the name changes (only for some providers).
  /// This tends to be the API url for the repository.
  permalink             String
  slug                  String
  /// Latest commit SHA synchronized for the configuration file.
  latestCommit          String?
  /// Contents of the configuration file as of the latest commit.
  configFileContents    String?
  configPath            String?
  /// Error that encountered, if any, when parsing the configuration file.
  synchronizationError  String?
  /// [SynchronizationStatus]
  synchronizationStatus String
  synchronizedAt        DateTime?
  updates               RepositoryUpdate[]
  pullRequests          RepositoryPullRequest[]

  @@unique([projectId, providerId])
  @@unique([url])
  @@index([projectId])
  @@index([providerId])
  @@map("repository")
}

model RepositoryUpdate {
  id              String     @id
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  repository      Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  repositoryId    String
  enabled         Boolean
  /// [PackageEcosystem]
  ecosystem       String
  directory       String?
  directories     String[]
  /// Either the original directory or merger of directories.
  directoryKey    String
  /// Cron schedule for running this update.
  cron            String
  timezone        String
  nextUpdateJobAt DateTime
  files           String[]

  @@unique([repositoryId, ecosystem, directoryKey])
  @@index([repositoryId])
  @@map("repository_update")
}

model RepositoryPullRequest {
  id             String                      @id
  createdAt      DateTime                    @default(now())
  updatedAt      DateTime                    @updatedAt
  repository     Repository                  @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  repositoryId   String
  providerId     Int
  /// [DependabotPackageManager]
  packageManager String
  /// [RepositoryPullRequestStatus]
  status         String

  /// [DependabotPersistedPr]
  data Json

  @@index([repositoryId])
  @@index([repositoryId, providerId])
  @@index([repositoryId, packageManager, status])
  @@map("repository_pull_request")
}

model UpdateJob {
  id        String           @id
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  /// [UpdateJobStatus]
  status    String
  /// [UpdateJobTrigger]
  trigger   String

  // no related objects to allow delete to not cascade, records retained for billing and analytics
  organizationId     String
  projectId          String
  repositoryId       String
  repositoryUpdateId String

  repositorySlug String

  /// Commit SHA of the configuration file used for the update.
  commit         String
  /// [PackageEcosystem]
  ecosystem      String
  /// [DependabotPackageManager]
  packageManager String
  directory      String?
  directories    String[]
  /// Either the original directory or merger of directories.
  directoryKey   String
  workflowRunId  String
  /// [DependabotConfig]
  config         Json
  /// [DependabotJobConfig]
  jobConfig      Json
  /// [DependabotCredential]
  credentials    Json[]
  secret         UpdateJobSecret?
  /// [RegionCode]
  region         String
  startedAt      DateTime?
  finishedAt     DateTime?
  /// Duration in milliseconds.
  duration       Int?
  /// [DependabotJobError]
  errors         Json[]
  /// [DependabotRecordUpdateJobWarning]
  warnings       Json[]
  affectedPrIds  Int[]

  @@unique([packageManager, directoryKey, workflowRunId])
  @@index([organizationId])
  @@index([projectId])
  @@index([repositoryId])
  @@index([repositoryUpdateId])
  @@index([region])
  @@map("update_job")
}

/// Secret used to authorize update jobs when they make API calls.
/// This is stored separately to avoid accidental exposure.

model UpdateJobSecret {
  id               String    @id
  job              UpdateJob @relation(fields: [id], references: [id], onDelete: Cascade)
  jobToken         String
  credentialsToken String
  hookToken        String

  @@unique([jobToken])
  @@unique([credentialsToken])
  @@unique([hookToken])
  @@map("update_job_secret")
}
