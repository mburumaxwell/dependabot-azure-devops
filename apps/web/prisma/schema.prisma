// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../.prisma"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model UsageTelemetry {
  id              BigInt   @id @map("_id")
  country         String?
  region          String?
  hostPlatform    String
  hostRelease     String
  hostArch        String
  hostMachineHash String
  version         String
  trigger         String
  provider        String
  owner           String
  project         String? // TODO: remove nullable after older records are cleared (90 days after 2025-Oct-21 i.e. 2026-Jan-19)
  packageManager  String
  started         DateTime
  duration        Int
  success         Boolean

  @@index([trigger])
  @@index([owner])
  @@index([packageManager])
  @@index([started(sort: Desc)])
  @@index([duration])
  @@index([success])
  @@index([region])
  @@map("usage_telemetry")
}

model User {
  id               String       @id @map("_id")
  name             String
  email            String
  emailVerified    Boolean      @default(false)
  image            String?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @default(now()) @updatedAt
  role             String?
  banned           Boolean?     @default(false)
  banReason        String?
  banExpires       DateTime?
  sessions         Session[]
  accounts         Account[]
  members          Member[]
  invitations      Invitation[]
  passkeys         Passkey[]
  stripeCustomerId String?

  @@unique([email])
  @@map("user")
}

model Session {
  id                   String   @id @map("_id")
  expiresAt            DateTime
  token                String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy       String?
  activeOrganizationId String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

enum OrganizationType {
  azure
  gitlab
  bitbucket

  @@map("organization_type")
}

model Organization {
  id          String                  @id @map("_id")
  name        String
  slug        String?
  logo        String?
  createdAt   DateTime
  metadata    String?
  members     Member[]
  invitations Invitation[]
  type        OrganizationType
  url         String
  region      String
  maxProjects Int?
  credential  OrganizationCredential?
  secrets     OrganizationSecret[]
  projects    Project[]
  jobs        UpdateJob[]

  @@unique([slug])
  @@unique([url])
  @@index([type])
  @@index([region])
  @@map("organization")
}

model Member {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  createdAt      DateTime

  @@map("member")
}

model Invitation {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@map("invitation")
}

model Passkey {
  id           String    @id @map("_id")
  name         String?
  publicKey    String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?
  aaguid       String?

  @@map("passkey")
}

// Credentials are stored in a separate table/collection for security reasons.
// This way they are only queried when needed and not by accident when pulling
// organization data.
// The better-auth plugin is meant to hide this information but it does not work.
// Even if it did, it is better to keep sensitive information isolated.

model OrganizationCredential {
  id                      String       @id @map("_id")
  organization            Organization @relation(fields: [id], references: [id], onDelete: Cascade)
  token                   String
  tokenEnclaveUrl         String? // Future enclave storage support
  /// Token (password) for Webhooks, ServiceHooks, and Notifications from the provider.
  /// This is generated on creation and may be shown on demand but cannot be edited.
  webhooksToken           String
  webhooksTokenEnclaveUrl String? // Future enclave storage support
  githubToken             String?
  githubTokenEnclaveUrl   String? // Future enclave storage support

  @@map("organization_credential")
}

model OrganizationSecret {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String
  value          String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  enclaveUrl     String? // Future enclave storage support

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([name])
  @@map("organization_secret")
}

enum SynchronizationStatus {
  pending
  success
  failed

  @@map("synchronization_status")
}

model Project {
  id                    String                @id @map("_id")
  organizationId        String
  organization          Organization          @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  providerId            String
  name                  String
  url                   String
  /// The link that never changes even if the name changes (only for some providers).
  /// This tends to be the API url for the project.
  permalink             String
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  synchronizationStatus SynchronizationStatus
  synchronizedAt        DateTime?
  repositories          Repository[]
  jobs                  UpdateJob[]

  @@unique([organizationId, providerId])
  @@index([organizationId])
  @@map("project")
}

model Repository {
  id                    String                @id @map("_id")
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  projectId             String
  project               Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  providerId            String
  name                  String
  url                   String
  /// The link that never changes even if the name changes (only for some providers).
  /// This tends to be the API url for the repository.
  permalink             String
  slug                  String?
  /// Latest commit SHA synchronized for the configuration file.
  latestCommit          String?
  /// Contents of the configuration file as of the latest commit.
  configFileContents    String?
  /// Error that encountered, if any, when parsing the configuration file.
  synchronizationError  String?
  synchronizationStatus SynchronizationStatus
  synchronizedAt        DateTime?
  updates               RepositoryUpdate[]
  /// Parsed JSON of the configuration file.
  configJson            String?
  registriesJson        String?
  jobs                  UpdateJob[]

  @@unique([projectId, providerId])
  @@unique([url])
  @@index([projectId])
  @@index([providerId])
  @@map("repository")
}

model RepositoryUpdate {
  id                    String           @id @map("_id")
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  repository            Repository       @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  repositoryId          String
  ecosystem             String
  directory             String?
  directories           String[]
  /// Either the original directory or merger of directories.
  directoryKey          String
  /// Cron schedule for running this update
  schedule              String
  timezone              String
  files                 String[]
  jobs                  UpdateJob[]
  latestUpdateJobId     String?
  latestUpdateJobStatus UpdateJobStatus?
  latestUpdateJobAt     DateTime?

  @@unique([repositoryId, ecosystem, directoryKey])
  @@index([repositoryId])
  @@map("repository_update")
}

enum UpdateJobTrigger {
  scheduled
  missed_schedule
  synchronization
  manual

  @@map("update_job_trigger")
}

enum UpdateJobStatus {
  scheduled
  running
  succeeded
  failed

  @@map("update_job_status")
}

enum UpdateJobPlatform {
  azure_pipelines
  azure_virtual_machines
  azure_container_apps
  azure_container_instances
}

model UpdateJob {
  id        String            @id @map("_id")
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  status    UpdateJobStatus
  trigger   UpdateJobTrigger
  platform  UpdateJobPlatform

  organizationId     String
  projectId          String
  repositoryId       String
  repositoryUpdateId String
  // no delete cascade, records here retained for billing and analytics
  organization       Organization     @relation(fields: [organizationId], references: [id], onDelete: NoAction)
  project            Project          @relation(fields: [projectId], references: [id], onDelete: NoAction)
  repository         Repository       @relation(fields: [repositoryId], references: [id], onDelete: NoAction)
  repositoryUpdate   RepositoryUpdate @relation(fields: [repositoryUpdateId], references: [id], onDelete: NoAction)

  repositorySlug String

  /// Commit SHA of the configuration file used for the update.
  commit          String
  /// Ecosystem for the update (e.g., npm, pip, etc.)
  ecosystem       String
  directory       String?
  directories     String[]
  /// CPU units provisioned. e.g. 0.25
  resourcesCpu    Float?
  /// Memory provisioned in GB. e.g. 1.2
  resourcesMemory Float?
  secret          UpdateJobSecret?
  startedAt       DateTime?
  finishedAt      DateTime?
  /// Duration in milliseconds.
  duration        Int?
  /// URL to view the logs of the job (used when running on customer infra e.g. azure pipelines).
  externalLogsUrl String?
  /// URL to download the logs of the job (used when running on our infra).
  downloadLogsUrl String?
  errorType       String?
  errorDetailJson String?
}

model UpdateJobSecret {
  id    String    @id @map("_id")
  jobId String
  job   UpdateJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  /// Authorization key for the job, used by the updater to make API calls.
  /// This should never be exposed to the client.
  value String

  @@unique([jobId])
  @@unique([value])
  @@map("update_job_secret")
}
