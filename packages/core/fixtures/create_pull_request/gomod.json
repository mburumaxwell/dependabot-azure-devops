{
  "data": {
    "dependencies": [
      {
        "name": "github.com/aws/aws-sdk-go-v2/service/s3",
        "previous-version": "1.91.1",
        "requirements": [
          {
            "requirement": "1.92.0",
            "file": "go.mod",
            "source": {
              "type": "default",
              "source": "github.com/aws/aws-sdk-go-v2/service/s3"
            },
            "groups": []
          }
        ],
        "previous-requirements": [
          {
            "requirement": "v1.91.1",
            "file": "go.mod",
            "source": {
              "type": "default",
              "source": "github.com/aws/aws-sdk-go-v2/service/s3"
            },
            "groups": []
          }
        ],
        "directory": "/",
        "version": "1.92.0"
      }
    ],
    "updated-dependency-files": [
      {
        "name": "go.mod",
        "content": "module example.com/vendor-test\n\ngo 1.24.0\n\nrequire (\n\tgithub.com/Nerzal/gocloak/v13 v13.9.0\n\tgithub.com/aws/aws-sdk-go-v2 v1.40.0\n\tgithub.com/aws/aws-sdk-go-v2/service/s3 v1.92.0\n\tgithub.com/aws/smithy-go v1.23.2\n\tgithub.com/caarlos0/env/v6 v6.10.1\n\tgithub.com/go-chi/chi/v5 v5.2.3\n\tgithub.com/go-chi/cors v1.2.2\n\tgithub.com/go-chi/telemetry v0.0.0-00010101000000-000000000000\n\tgithub.com/golang-jwt/jwt/v5 v5.2.2\n\tgithub.com/stretchr/testify v1.11.1\n\tgithub.com/swaggo/http-swagger v1.3.4\n\tgithub.com/swaggo/swag v1.16.6\n\tgithub.com/twmb/franz-go v1.20.2\n\tgoogle.golang.org/grpc v1.76.0\n\tgoogle.golang.org/protobuf v1.36.10\n)\n\nrequire (\n\tgithub.com/KyleBanks/depth v1.2.1 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.7.3 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/internal/configsources v1.4.14 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.7.14 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/internal/v4a v1.4.14 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.13.3 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/service/internal/checksum v1.9.5 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.13.14 // indirect\n\tgithub.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.19.14 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/go-openapi/jsonpointer v0.19.5 // indirect\n\tgithub.com/go-openapi/jsonreference v0.20.0 // indirect\n\tgithub.com/go-openapi/spec v0.20.6 // indirect\n\tgithub.com/go-openapi/swag v0.19.15 // indirect\n\tgithub.com/go-resty/resty/v2 v2.7.0 // indirect\n\tgithub.com/golang/mock v1.6.0 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/klauspost/compress v1.18.0 // indirect\n\tgithub.com/mailru/easyjson v0.7.6 // indirect\n\tgithub.com/opentracing/opentracing-go v1.2.0 // indirect\n\tgithub.com/pierrec/lz4/v4 v4.1.22 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_golang v1.19.0 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.52.3 // indirect\n\tgithub.com/prometheus/procfs v0.13.0 // indirect\n\tgithub.com/segmentio/ksuid v1.0.4 // indirect\n\tgithub.com/swaggo/files v0.0.0-20220610200504-28940afbdbfe // indirect\n\tgithub.com/twmb/franz-go/pkg/kmsg v1.12.0 // indirect\n\tgithub.com/twmb/murmur3 v1.1.8 // indirect\n\tgithub.com/uber-go/tally/v4 v4.1.16 // indirect\n\tgo.uber.org/atomic v1.11.0 // indirect\n\tgolang.org/x/mod v0.25.0 // indirect\n\tgolang.org/x/net v0.42.0 // indirect\n\tgolang.org/x/sync v0.16.0 // indirect\n\tgolang.org/x/sys v0.34.0 // indirect\n\tgolang.org/x/text v0.27.0 // indirect\n\tgolang.org/x/tools v0.34.0 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\nreplace github.com/go-chi/telemetry => github.com/Grekkq/telemetry v0.4.2-a\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "utf-8",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "go.sum",
        "content": "cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngithub.com/Grekkq/telemetry v0.4.2-a h1:aRaPJUKk7/i8s5iu+XAiEJASEIL/Cg62/P2i3/tpiwA=\ngithub.com/Grekkq/telemetry v0.4.2-a/go.mod h1:N+qwgqriyLwEPFyXAjj22GMdDlNuCaEourUPJfZBoPw=\ngithub.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=\ngithub.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=\ngithub.com/Nerzal/gocloak/v13 v13.9.0 h1:YWsJsdM5b0yhM2Ba3MLydiOlujkBry4TtdzfIzSVZhw=\ngithub.com/Nerzal/gocloak/v13 v13.9.0/go.mod h1:YYuDcXZ7K2zKECyVP7pPqjKxx2AzYSpKDj8d6GuyM10=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=\ngithub.com/aws/aws-sdk-go-v2 v1.40.0 h1:/WMUA0kjhZExjOQN2z3oLALDREea1A7TobfuiBrKlwc=\ngithub.com/aws/aws-sdk-go-v2 v1.40.0/go.mod h1:c9pm7VwuW0UPxAEYGyTmyurVcNrbF6Rt/wixFqDhcjE=\ngithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.7.3 h1:DHctwEM8P8iTXFxC/QK0MRjwEpWQeM9yzidCRjldUz0=\ngithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.7.3/go.mod h1:xdCzcZEtnSTKVDOmUZs4l/j3pSV6rpo1WXl5ugNsL8Y=\ngithub.com/aws/aws-sdk-go-v2/internal/configsources v1.4.14 h1:PZHqQACxYb8mYgms4RZbhZG0a7dPW06xOjmaH0EJC/I=\ngithub.com/aws/aws-sdk-go-v2/internal/configsources v1.4.14/go.mod h1:VymhrMJUWs69D8u0/lZ7jSB6WgaG/NqHi3gX0aYf6U0=\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.7.14 h1:bOS19y6zlJwagBfHxs0ESzr1XCOU2KXJCWcq3E2vfjY=\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.7.14/go.mod h1:1ipeGBMAxZ0xcTm6y6paC2C/J6f6OO7LBODV9afuAyM=\ngithub.com/aws/aws-sdk-go-v2/internal/v4a v1.4.14 h1:ITi7qiDSv/mSGDSWNpZ4k4Ve0DQR6Ug2SJQ8zEHoDXg=\ngithub.com/aws/aws-sdk-go-v2/internal/v4a v1.4.14/go.mod h1:k1xtME53H1b6YpZt74YmwlONMWf4ecM+lut1WQLAF/U=\ngithub.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.13.3 h1:x2Ibm/Af8Fi+BH+Hsn9TXGdT+hKbDd5XOTZxTMxDk7o=\ngithub.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.13.3/go.mod h1:IW1jwyrQgMdhisceG8fQLmQIydcT/jWY21rFhzgaKwo=\ngithub.com/aws/aws-sdk-go-v2/service/internal/checksum v1.9.5 h1:Hjkh7kE6D81PgrHlE/m9gx+4TyyeLHuY8xJs7yXN5C4=\ngithub.com/aws/aws-sdk-go-v2/service/internal/checksum v1.9.5/go.mod h1:nPRXgyCfAurhyaTMoBMwRBYBhaHI4lNPAnJmjM0Tslc=\ngithub.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.13.14 h1:FIouAnCE46kyYqyhs0XEBDFFSREtdnr8HQuLPQPLCrY=\ngithub.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.13.14/go.mod h1:UTwDc5COa5+guonQU8qBikJo1ZJ4ln2r1MkF7Dqag1E=\ngithub.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.19.14 h1:FzQE21lNtUor0Fb7QNgnEyiRCBlolLTX/Z1j65S7teM=\ngithub.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.19.14/go.mod h1:s1ydyWG9pm3ZwmmYN21HKyG9WzAZhYVW85wMHs5FV6w=\ngithub.com/aws/aws-sdk-go-v2/service/s3 v1.92.0 h1:8FshVvnV2sr9kOSAbOnc/vwVmmAwMjOedKH6JW2ddPM=\ngithub.com/aws/aws-sdk-go-v2/service/s3 v1.92.0/go.mod h1:wYNqY3L02Z3IgRYxOBPH9I1zD9Cjh9hI5QOy/eOjQvw=\ngithub.com/aws/smithy-go v1.23.2 h1:Crv0eatJUQhaManss33hS5r40CG3ZFH+21XSkqMrIUM=\ngithub.com/aws/smithy-go v1.23.2/go.mod h1:LEj2LM3rBRQJxPZTB4KuzZkaZYnZPnvgIhb4pu07mx0=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/caarlos0/env/v6 v6.10.1 h1:t1mPSxNpei6M5yAeu1qtRdPAK29Nbcf/n3G7x+b3/II=\ngithub.com/caarlos0/env/v6 v6.10.1/go.mod h1:hvp/ryKXKipEkcuYjs9mI4bBCg+UI0Yhgm5Zu0ddvwc=\ngithub.com/cactus/go-statsd-client/v5 v5.0.0/go.mod h1:COEvJ1E+/E2L4q6QE5CkjWPi4eeDw9maJBMIuMPBZbY=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-chi/chi/v5 v5.2.3 h1:WQIt9uxdsAbgIYgid+BpYc+liqQZGMHRaUwp0JUcvdE=\ngithub.com/go-chi/chi/v5 v5.2.3/go.mod h1:L2yAIGWB3H+phAw1NxKwWM+7eUH/lU8pOMm5hHcoops=\ngithub.com/go-chi/cors v1.2.2 h1:Jmey33TE+b+rB7fT8MUy1u0I4L+NARQlK6LhzKPSyQE=\ngithub.com/go-chi/cors v1.2.2/go.mod h1:sSbTewc+6wYHBBCW7ytsFSn836hqM7JxpglAy2Vzc58=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=\ngithub.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=\ngithub.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-openapi/jsonpointer v0.19.3/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonpointer v0.19.5 h1:gZr+CIYByUqjcgeLXnQu2gHYQC9o73G2XUeOFYEICuY=\ngithub.com/go-openapi/jsonpointer v0.19.5/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonreference v0.20.0 h1:MYlu0sBgChmCfJxxUKZ8g1cPWFOB37YSZqewK7OKeyA=\ngithub.com/go-openapi/jsonreference v0.20.0/go.mod h1:Ag74Ico3lPc+zR+qjn4XBUmXymS4zJbYVCZmcgkasdo=\ngithub.com/go-openapi/spec v0.20.6 h1:ich1RQ3WDbfoeTqTAb+5EIxNmpKVJZWBNah9RAT0jIQ=\ngithub.com/go-openapi/spec v0.20.6/go.mod h1:2OpW+JddWPrpXSCIX8eOx7lZ5iyuWj3RYR6VaaBKcWA=\ngithub.com/go-openapi/swag v0.19.5/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=\ngithub.com/go-openapi/swag v0.19.15 h1:D2NRCBzS9/pEY3gP9Nl8aDqGUcPFrwG2p+CNFrLyrCM=\ngithub.com/go-openapi/swag v0.19.15/go.mod h1:QYRuS/SOXUCsnplDa677K7+DxSOj6IPNl/eQntq43wQ=\ngithub.com/go-resty/resty/v2 v2.7.0 h1:me+K9p3uhSmXtrBZ4k9jcEAfJmuC8IivWHwaLZwPrFY=\ngithub.com/go-resty/resty/v2 v2.7.0/go.mod h1:9PWDzw47qPphMRFfhsyk0NnSgvluHcljSMVIq3w7q0I=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang-jwt/jwt/v5 v5.2.2 h1:Rl4B7itRWVtYIHFrSNd7vhTiz9UpLdi6gZhZ3wEeDy8=\ngithub.com/golang-jwt/jwt/v5 v5.2.2/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=\ngithub.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=\ngithub.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=\ngithub.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.11/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=\ngithub.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=\ngithub.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.3/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=\ngithub.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/opentracing/opentracing-go v1.2.0 h1:uEJPy/1a5RIPAJ0Ov+OIO8OxWu77jEv+1B0VhjKrZUs=\ngithub.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=\ngithub.com/pierrec/lz4/v4 v4.1.22 h1:cKFw6uJDK+/gfw5BcDL0JL5aBsAFdsIT18eRtLj7VIU=\ngithub.com/pierrec/lz4/v4 v4.1.22/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=\ngithub.com/prometheus/client_golang v1.7.1/go.mod h1:PY5Wy2awLA44sXw4AOSfFBetzPP4j5+D6mVACh+pe2M=\ngithub.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=\ngithub.com/prometheus/client_golang v1.19.0 h1:ygXvpU1AoN1MhdzckN+PyD9QJOSD4x7kmXYlnfbA6JU=\ngithub.com/prometheus/client_golang v1.19.0/go.mod h1:ZRM9uEAypZakd+q/x7+gmsvXdURP+DABIEIjnmDdp+k=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.10.0/go.mod h1:Tlit/dnDKsSWFlCLTWaA1cyBgKHSMdTB80sz/V91rCo=\ngithub.com/prometheus/common v0.26.0/go.mod h1:M7rCNAaPfAosfx8veZJCuw84e35h3Cfd9VFqTh1DIvc=\ngithub.com/prometheus/common v0.52.3 h1:5f8uj6ZwHSscOGNdIQg6OiZv/ybiK2CO2q2drVZAQSA=\ngithub.com/prometheus/common v0.52.3/go.mod h1:BrxBKv3FWBIGXw89Mg1AeBq7FSyRzXWI3l3e7W3RN5U=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=\ngithub.com/prometheus/procfs v0.6.0/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=\ngithub.com/prometheus/procfs v0.13.0 h1:GqzLlQyfsPbaEHaQkO7tbDlriv/4o5Hudv6OXHGKX7o=\ngithub.com/prometheus/procfs v0.13.0/go.mod h1:cd4PFCR54QLnGKPaKGA6l+cfuNXtht43ZKY6tow0Y1g=\ngithub.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\ngithub.com/segmentio/ksuid v1.0.4 h1:sBo2BdShXjmcugAMwjugoGUdUV0pcxY5mW4xKRn3v4c=\ngithub.com/segmentio/ksuid v1.0.4/go.mod h1:/XUiZBD3kVx5SmUOl55voK5yeAbBNNIed+2O73XgrPE=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.6.0/go.mod h1:7uNnSEd1DgxDLC74fIahvMZmmYsHGZGEOFrfsX/uA88=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=\ngithub.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=\ngithub.com/swaggo/files v0.0.0-20220610200504-28940afbdbfe h1:K8pHPVoTgxFJt1lXuIzzOX7zZhZFldJQK/CgKx9BFIc=\ngithub.com/swaggo/files v0.0.0-20220610200504-28940afbdbfe/go.mod h1:lKJPbtWzJ9JhsTN1k1gZgleJWY/cqq0psdoMmaThG3w=\ngithub.com/swaggo/http-swagger v1.3.4 h1:q7t/XLx0n15H1Q9/tk3Y9L4n210XzJF5WtnDX64a5ww=\ngithub.com/swaggo/http-swagger v1.3.4/go.mod h1:9dAh0unqMBAlbp1uE2Uc2mQTxNMU/ha4UbucIg1MFkQ=\ngithub.com/swaggo/swag v1.16.6 h1:qBNcx53ZaX+M5dxVyTrgQ0PJ/ACK+NzhwcbieTt+9yI=\ngithub.com/swaggo/swag v1.16.6/go.mod h1:ngP2etMK5a0P3QBizic5MEwpRmluJZPHjXcMoj4Xesg=\ngithub.com/twmb/franz-go v1.20.2 h1:CiwhyKZHW6vqSHJkh+RTxFAJkio0jBjM/JQhx/HZ72A=\ngithub.com/twmb/franz-go v1.20.2/go.mod h1:YCnepDd4gl6vdzG03I5Wa57RnCTIC6DVEyMpDX/J8UA=\ngithub.com/twmb/franz-go/pkg/kmsg v1.12.0 h1:CbatD7ers1KzDNgJqPbKOq0Bz/WLBdsTH75wgzeVaPc=\ngithub.com/twmb/franz-go/pkg/kmsg v1.12.0/go.mod h1:+DPt4NC8RmI6hqb8G09+3giKObE6uD2Eya6CfqBpeJY=\ngithub.com/twmb/murmur3 v1.1.5/go.mod h1:Qq/R7NUyOfr65zD+6Q5IHKsJLwP7exErjN6lyyq3OSQ=\ngithub.com/twmb/murmur3 v1.1.8 h1:8Yt9taO/WN3l08xErzjeschgZU2QSrwm1kclYq+0aRg=\ngithub.com/twmb/murmur3 v1.1.8/go.mod h1:Qq/R7NUyOfr65zD+6Q5IHKsJLwP7exErjN6lyyq3OSQ=\ngithub.com/uber-go/tally/v4 v4.1.16 h1:by2hveWRh/cUReButk6ns1sHK/hiKry7BuOV6iY16XI=\ngithub.com/uber-go/tally/v4 v4.1.16/go.mod h1:RW5DgqsyEPs0lA4b0YNf4zKj7DveKHd73hnO6zVlyW0=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngo.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=\ngo.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=\ngo.opentelemetry.io/otel v1.37.0 h1:9zhNfelUvx0KBfu/gb+ZgeAfAgtWrfHJZcAqFC228wQ=\ngo.opentelemetry.io/otel v1.37.0/go.mod h1:ehE/umFRLnuLa/vSccNq9oS1ErUlkkK71gMcN34UG8I=\ngo.opentelemetry.io/otel/metric v1.37.0 h1:mvwbQS5m0tbmqML4NqK+e3aDiO02vsf/WgbsdpcPoZE=\ngo.opentelemetry.io/otel/metric v1.37.0/go.mod h1:04wGrZurHYKOc+RKeye86GwKiTb9FKm1WHtO+4EVr2E=\ngo.opentelemetry.io/otel/sdk v1.37.0 h1:ItB0QUqnjesGRvNcmAcU0LyvkVyGJ2xftD29bWdDvKI=\ngo.opentelemetry.io/otel/sdk v1.37.0/go.mod h1:VredYzxUvuo2q3WRcDnKDjbdvmO0sCzOvVAiY+yUkAg=\ngo.opentelemetry.io/otel/sdk/metric v1.37.0 h1:90lI228XrB9jCMuSdA0673aubgRobVZFhbjxHHspCPc=\ngo.opentelemetry.io/otel/sdk/metric v1.37.0/go.mod h1:cNen4ZWfiD37l5NhS+Keb5RXVWZWpRE+9WyVCpbo5ps=\ngo.opentelemetry.io/otel/trace v1.37.0 h1:HLdcFNbRQBE2imdSEgm/kwqmQj1Or1l/7bW6mxVK7z4=\ngo.opentelemetry.io/otel/trace v1.37.0/go.mod h1:TlgrlQ+PtQO5XFerSPUYG0JSgGyryXewPGyayAWSBS0=\ngo.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=\ngo.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=\ngo.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=\ngo.uber.org/goleak v1.2.1 h1:NBol2c7O1ZokfZ0LEU9K6Whx/KnwvepVetCUhtKja4A=\ngo.uber.org/goleak v1.2.1/go.mod h1:qlT2yGI9QafXHhZZLxlSuNsMw3FFLxBr+tBRlmO1xH4=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.43.0 h1:dduJYIi3A3KOfdGOHX8AVZ/jGiyPa3IbBozJ5kNuE04=\ngolang.org/x/crypto v0.43.0/go.mod h1:BFbav4mRNlXJL4wNeejLpWxB7wMbc79PdRGhWKncxR0=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=\ngolang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/net v0.0.0-20210805182204-aaa1db679c0d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211029224645-99673261e6eb/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=\ngolang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.16.0 h1:ycBJEhp9p4vXvUZNszeOq0kGTPghopOL8q0fq3vstxw=\ngolang.org/x/sync v0.16.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200625212154-ddb9806d33ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210603081109-ebe580a85c40/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.34.0 h1:H5Y5sJ2L2JRdyv7ROF1he/lPdvFsd0mJHFw2ThKHxLA=\ngolang.org/x/sys v0.34.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.27.0 h1:4fGWRpyh641NLlecmyl4LOe6yDdfaYNrGb2zdfo4JV4=\ngolang.org/x/text v0.27.0/go.mod h1:1D28KMCvyooCX9hBiosv5Tz/+YLxj0j7XhWjpSUF7CU=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=\ngolang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngonum.org/v1/gonum v0.16.0 h1:5+ul4Swaf3ESvrOnidPp4GZbzf0mxVQpDCYUQE7OJfk=\ngonum.org/v1/gonum v0.16.0/go.mod h1:fef3am4MQ93R2HHpKnLk4/Tbh/s0+wqD5nfa6Pnwy4E=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b h1:zPKJod4w6F1+nRGDI9ubnXYhU9NSWoFAijkHkUXeTK8=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=\ngoogle.golang.org/grpc v1.76.0 h1:UnVkv1+uMLYXoIz6o7chp59WfQUYA2ex/BXQ9rHZu7A=\ngoogle.golang.org/grpc v1.76.0/go.mod h1:Ju12QI8M6iQJtbcsV+awF5a4hfJMLi4X0JLo94ULZ6c=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.36.10 h1:AYd7cD/uASjIL6Q9LiTjz8JLcrh/88q5UObnmY3aOOE=\ngoogle.golang.org/protobuf v1.36.10/go.mod h1:HTf+CrKn2C3g5S8VImy6tdcUvCska2kB7j23XfzDpco=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/validator.v2 v2.0.0-20200605151824-2b28d334fa05/go.mod h1:o4V0GXN9/CAmCsvJ0oXYZvrZOe7syiDZSN1GWGZTGzc=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "utf-8",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/.DS_Store",
        "content": null,
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": true,
        "operation": "delete"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/CHANGELOG.md",
        "content": "# v1.92.0 (2025-11-20)\n\n* **Feature**: Enable / Disable ABAC on a general purpose bucket.\n\n# v1.91.1 (2025-11-19.2)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.91.0 (2025-11-19)\n\n* **Feature**: Adds support for blocking SSE-C writes to general purpose buckets.\n\n# v1.90.2 (2025-11-12)\n\n* **Bug Fix**: Further reduce allocation overhead when the metrics system isn't in-use.\n* **Bug Fix**: Reduce allocation overhead when the client doesn't have any HTTP interceptors configured.\n* **Bug Fix**: Remove blank trace spans towards the beginning of the request that added no additional information. This conveys a slight reduction in overall allocations.\n\n# v1.90.1 (2025-11-11)\n\n* **Bug Fix**: Return validation error if input region is not a valid host label.\n\n# v1.90.0 (2025-11-05)\n\n* **Feature**: Launch IPv6 dual-stack support for S3 Express\n\n# v1.89.2 (2025-11-04)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n* **Dependency Update**: Upgrade to smithy-go v1.23.2 which should convey some passive reduction of overall allocations, especially when not using the metrics system.\n\n# v1.89.1 (2025-10-30)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.89.0 (2025-10-28)\n\n* **Feature**: Amazon Simple Storage Service / Features: Add conditional writes in CopyObject on destination key to prevent unintended object modifications.\n\n# v1.88.7 (2025-10-23)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.88.6 (2025-10-22)\n\n* No change notes available for this release.\n\n# v1.88.5 (2025-10-16)\n\n* **Dependency Update**: Bump minimum Go version to 1.23.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.88.4 (2025-10-07)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.88.3 (2025-09-26)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.88.2 (2025-09-23)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.88.1 (2025-09-10)\n\n* No change notes available for this release.\n\n# v1.88.0 (2025-09-08)\n\n* **Feature**: This release includes backward compatibility work on the \"Expires\" parameter.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.87.3 (2025-08-29)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.87.2 (2025-08-27)\n\n* **Dependency Update**: Update to smithy-go v1.23.0.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.87.1 (2025-08-21)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.87.0 (2025-08-11)\n\n* **Feature**: Add support for configuring per-service Options via callback on global config.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.86.0 (2025-08-04)\n\n* **Feature**: Support configurable auth scheme preferences in service clients via AWS_AUTH_SCHEME_PREFERENCE in the environment, auth_scheme_preference in the config file, and through in-code settings on LoadDefaultConfig and client constructor methods.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.85.1 (2025-07-30)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.85.0 (2025-07-28)\n\n* **Feature**: Add support for HTTP interceptors.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.84.1 (2025-07-19)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.84.0 (2025-07-15)\n\n* **Feature**: Amazon S3 Metadata live inventory tables provide a queryable inventory of all the objects in your general purpose bucket so that you can determine the latest state of your data. To help minimize your storage costs, use journal table record expiration to set a retention period for your records.\n\n# v1.83.0 (2025-07-02)\n\n* **Feature**: Added support for directory bucket creation with tags and bucket ARN retrieval in CreateBucket, ListDirectoryBuckets, and HeadBucket operations\n\n# v1.82.0 (2025-06-25)\n\n* **Feature**: Adds support for additional server-side encryption mode and storage class values for accessing Amazon FSx data from Amazon S3 using S3 Access Points\n\n# v1.81.0 (2025-06-18)\n\n* **Feature**: Added support for renaming objects within the same bucket using the new RenameObject API.\n\n# v1.80.3 (2025-06-17)\n\n* **Dependency Update**: Update to smithy-go v1.22.4.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.80.2 (2025-06-10)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.80.1 (2025-06-06)\n\n* No change notes available for this release.\n\n# v1.80.0 (2025-05-29)\n\n* **Feature**: Adding checksum support for S3 PutBucketOwnershipControls API.\n\n# v1.79.4 (2025-05-22)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.79.3 (2025-04-28)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.79.2 (2025-04-10)\n\n* No change notes available for this release.\n\n# v1.79.1 (2025-04-03)\n\n* No change notes available for this release.\n\n# v1.79.0 (2025-03-31)\n\n* **Feature**: Amazon S3 adds support for S3 Access Points for directory buckets in AWS Dedicated Local Zones\n\n# v1.78.2 (2025-03-11)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.78.1 (2025-03-04.2)\n\n* **Bug Fix**: Add assurance test for operation order.\n\n# v1.78.0 (2025-02-27)\n\n* **Feature**: Track credential providers via User-Agent Feature ids\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.77.1 (2025-02-18)\n\n* **Bug Fix**: Bump go version to 1.22\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.77.0 (2025-02-14)\n\n* **Feature**: Added support for Content-Range header in HeadObject response.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.76.1 (2025-02-10)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.76.0 (2025-02-06)\n\n* **Feature**: Updated list of the valid AWS Region values for the LocationConstraint parameter for general purpose buckets.\n\n# v1.75.4 (2025-02-05)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.75.3 (2025-02-04)\n\n* No change notes available for this release.\n\n# v1.75.2 (2025-01-31)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.75.1 (2025-01-30)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.75.0 (2025-01-29)\n\n* **Feature**: Change the type of MpuObjectSize in CompleteMultipartUploadRequest from int to long.\n\n# v1.74.1 (2025-01-24)\n\n* **Bug Fix**: Enable request checksum validation mode by default\n* **Dependency Update**: Updated to the latest SDK module versions\n* **Dependency Update**: Upgrade to smithy-go v1.22.2.\n\n# v1.74.0 (2025-01-22)\n\n* **Feature**: Add a client config option to disable logging when output checksum validation is skipped due to an unsupported algorithm.\n\n# v1.73.2 (2025-01-17)\n\n* **Bug Fix**: Fix bug where credentials weren't refreshed during retry loop.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.73.1 (2025-01-16)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.73.0 (2025-01-15)\n\n* **Feature**: S3 client behavior is updated to always calculate a checksum by default for operations that support it (such as PutObject or UploadPart), or require it (such as DeleteObjects). The checksum algorithm used by default now becomes CRC32. Checksum behavior can be configured using `when_supported` and `when_required` options - in code using RequestChecksumCalculation, in shared config using request_checksum_calculation, or as env variable using AWS_REQUEST_CHECKSUM_CALCULATION. The S3 client attempts to validate response checksums for all S3 API operations that support checksums. However, if the SDK has not implemented the specified checksum algorithm then this validation is skipped. Checksum validation behavior can be configured using `when_supported` and `when_required` options - in code using ResponseChecksumValidation, in shared config using response_checksum_validation, or as env variable using AWS_RESPONSE_CHECKSUM_VALIDATION.\n* **Feature**: This change enhances integrity protections for new SDK requests to S3. S3 SDKs now support the CRC64NVME checksum algorithm, full object checksums for multipart S3 objects, and new default integrity protections for S3 requests.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.72.3 (2025-01-14)\n\n* **Bug Fix**: Fix issue where waiters were not failing on unmatched errors as they should. This may have breaking behavioral changes for users in fringe cases. See [this announcement](https://github.com/aws/aws-sdk-go-v2/discussions/2954) for more information.\n\n# v1.72.2 (2025-01-09)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.72.1 (2025-01-08)\n\n* No change notes available for this release.\n\n# v1.72.0 (2025-01-03)\n\n* **Feature**: This change is only for updating the model regexp of CopySource which is not for validation but only for documentation and user guide change.\n\n# v1.71.1 (2024-12-19)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.71.0 (2024-12-03.2)\n\n* **Feature**: Amazon S3 Metadata stores object metadata in read-only, fully managed Apache Iceberg metadata tables that you can query. You can create metadata table configurations for S3 general purpose buckets.\n\n# v1.70.0 (2024-12-02)\n\n* **Feature**: Amazon S3 introduces support for AWS Dedicated Local Zones\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.69.0 (2024-11-25)\n\n* **Feature**: Amazon Simple Storage Service / Features: Add support for ETag based conditional writes in PutObject and CompleteMultiPartUpload APIs to prevent unintended object modifications.\n\n# v1.68.0 (2024-11-21)\n\n* **Feature**: Add support for conditional deletes for the S3 DeleteObject and DeleteObjects APIs. Add support for write offset bytes option used to append to objects with the S3 PutObject API.\n\n# v1.67.1 (2024-11-18)\n\n* **Dependency Update**: Update to smithy-go v1.22.1.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.67.0 (2024-11-14)\n\n* **Feature**: This release updates the ListBuckets API Reference documentation in support of the new 10,000 general purpose bucket default quota on all AWS accounts. To increase your bucket quota from 10,000 to up to 1 million buckets, simply request a quota increase via Service Quotas.\n\n# v1.66.3 (2024-11-06)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.66.2 (2024-10-28)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.66.1 (2024-10-25)\n\n* **Bug Fix**: Update presign post URL resolution to use the exact result from EndpointResolverV2\n\n# v1.66.0 (2024-10-16)\n\n* **Feature**: Add support for the new optional bucket-region and prefix query parameters in the ListBuckets API. For ListBuckets requests that express pagination, Amazon S3 will now return both the bucket names and associated AWS regions in the response.\n\n# v1.65.3 (2024-10-11)\n\n* **Bug Fix**: **BREAKING CHANGE**: S3 ReplicationRuleFilter and LifecycleRuleFilter shapes are being changed from union to structure types\n\n# v1.65.2 (2024-10-08)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.65.1 (2024-10-07)\n\n* **Bug Fix**: **CHANGE IN BEHAVIOR**: Allow serialization of headers with empty string for prefix headers. We are deploying this fix because the behavior is actively preventing users from transmitting keys with empty values to the service. If you were setting metadata keys with empty values before this change, they will now actually be sent to the service.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.65.0 (2024-10-04)\n\n* **Feature**: Add support for HTTP client metrics.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.64.1 (2024-10-03)\n\n* No change notes available for this release.\n\n# v1.64.0 (2024-10-02)\n\n* **Feature**: This release introduces a header representing the minimum object size limit for Lifecycle transitions.\n\n# v1.63.3 (2024-09-27)\n\n* No change notes available for this release.\n\n# v1.63.2 (2024-09-25)\n\n* No change notes available for this release.\n\n# v1.63.1 (2024-09-23)\n\n* No change notes available for this release.\n\n# v1.63.0 (2024-09-20)\n\n* **Feature**: Add tracing and metrics support to service clients.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.62.0 (2024-09-18)\n\n* **Feature**: Added SSE-KMS support for directory buckets.\n\n# v1.61.3 (2024-09-17)\n\n* **Bug Fix**: **BREAKFIX**: Only generate AccountIDEndpointMode config for services that use it. This is a compiler break, but removes no actual functionality, as no services currently use the account ID in endpoint resolution.\n\n# v1.61.2 (2024-09-04)\n\n* No change notes available for this release.\n\n# v1.61.1 (2024-09-03)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.61.0 (2024-08-28)\n\n* **Feature**: Add presignPost for s3 PutObject\n\n# v1.60.1 (2024-08-22)\n\n* No change notes available for this release.\n\n# v1.60.0 (2024-08-20)\n\n* **Feature**: Amazon Simple Storage Service / Features : Add support for conditional writes for PutObject and CompleteMultipartUpload APIs.\n\n# v1.59.0 (2024-08-15)\n\n* **Feature**: Amazon Simple Storage Service / Features  : Adds support for pagination in the S3 ListBuckets API.\n* **Dependency Update**: Bump minimum Go version to 1.21.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.58.3 (2024-08-02)\n\n* **Bug Fix**: Add assurance tests for auth scheme selection logic.\n\n# v1.58.2 (2024-07-10.2)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.58.1 (2024-07-10)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.58.0 (2024-07-02)\n\n* **Feature**: Added response overrides to Head Object requests.\n\n# v1.57.1 (2024-06-28)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.57.0 (2024-06-26)\n\n* **Feature**: Support list-of-string endpoint parameter.\n\n# v1.56.1 (2024-06-19)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.56.0 (2024-06-18)\n\n* **Feature**: Track usage of various AWS SDK features in user-agent string.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.55.2 (2024-06-17)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.55.1 (2024-06-07)\n\n* **Bug Fix**: Add clock skew correction on all service clients\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.55.0 (2024-06-05)\n\n* **Feature**: Added new params copySource and key to copyObject API for supporting S3 Access Grants plugin. These changes will not change any of the existing S3 API functionality.\n* **Bug Fix**: Add S3-specific smithy protocol tests.\n\n# v1.54.4 (2024-06-03)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.54.3 (2024-05-23)\n\n* **Bug Fix**: Prevent parsing failures for nonstandard `Expires` values in responses. If the SDK cannot parse the value set in the response header for this field it will now be returned as `nil`. A new field, `ExpiresString`, has been added that will retain the unparsed value from the response (regardless of whether it came back in a format recognized by the SDK).\n\n# v1.54.2 (2024-05-16)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.54.1 (2024-05-15)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.54.0 (2024-05-14)\n\n* **Feature**: Updated a few x-id in the http uri traits\n\n# v1.53.2 (2024-05-08)\n\n* **Bug Fix**: GoDoc improvement\n\n# v1.53.1 (2024-03-29)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.53.0 (2024-03-18)\n\n* **Feature**: Fix two issues with response root node names.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.52.1 (2024-03-15)\n\n* **Documentation**: Documentation updates for Amazon S3.\n\n# v1.52.0 (2024-03-13)\n\n* **Feature**: This release makes the default option for S3 on Outposts request signing to use the SigV4A algorithm when using AWS Common Runtime (CRT).\n\n# v1.51.4 (2024-03-07)\n\n* **Bug Fix**: Remove dependency on go-cmp.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.51.3 (2024-03-05)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.51.2 (2024-03-04)\n\n* **Bug Fix**: Update internal/presigned-url dependency for corrected API name.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.51.1 (2024-02-23)\n\n* **Bug Fix**: Move all common, SDK-side middleware stack ops into the service client module to prevent cross-module compatibility issues in the future.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.51.0 (2024-02-22)\n\n* **Feature**: Add middleware stack snapshot tests.\n\n# v1.50.3 (2024-02-21)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.50.2 (2024-02-20)\n\n* **Bug Fix**: When sourcing values for a service's `EndpointParameters`, the lack of a configured region (i.e. `options.Region == \"\"`) will now translate to a `nil` value for `EndpointParameters.Region` instead of a pointer to the empty string `\"\"`. This will result in a much more explicit error when calling an operation instead of an obscure hostname lookup failure.\n\n# v1.50.1 (2024-02-19)\n\n* **Bug Fix**: Prevent potential panic caused by invalid comparison of credentials.\n\n# v1.50.0 (2024-02-16)\n\n* **Feature**: Add new ClientOptions field to waiter config which allows you to extend the config for operation calls made by waiters.\n\n# v1.49.0 (2024-02-13)\n\n* **Feature**: Bump minimum Go version to 1.20 per our language support policy.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.48.1 (2024-01-24)\n\n* No change notes available for this release.\n\n# v1.48.0 (2024-01-05)\n\n* **Feature**: Support smithy sigv4a trait for codegen.\n\n# v1.47.8 (2024-01-04)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.47.7 (2023-12-20)\n\n* No change notes available for this release.\n\n# v1.47.6 (2023-12-18)\n\n* No change notes available for this release.\n\n# v1.47.5 (2023-12-08)\n\n* **Bug Fix**: Add non-vhostable buckets to request path when using legacy V1 endpoint resolver.\n* **Bug Fix**: Improve uniqueness of default S3Express sesssion credentials cache keying to prevent collision in multi-credential scenarios.\n* **Bug Fix**: Reinstate presence of default Retryer in functional options, but still respect max attempts set therein.\n\n# v1.47.4 (2023-12-07)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.47.3 (2023-12-06)\n\n* **Bug Fix**: Restore pre-refactor auth behavior where all operations could technically be performed anonymously.\n\n# v1.47.2 (2023-12-01)\n\n* **Bug Fix**: Correct wrapping of errors in authentication workflow.\n* **Bug Fix**: Correctly recognize cache-wrapped instances of AnonymousCredentials at client construction.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.47.1 (2023-11-30)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.47.0 (2023-11-29)\n\n* **Feature**: Expose Options() accessor on service clients.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.46.0 (2023-11-28.2)\n\n* **Feature**: Add S3Express support.\n* **Feature**: Adds support for S3 Express One Zone.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.45.1 (2023-11-28)\n\n* **Bug Fix**: Respect setting RetryMaxAttempts in functional options at client construction.\n\n# v1.45.0 (2023-11-27)\n\n* **Feature**: Adding new params - Key and Prefix, to S3 API operations for supporting S3 Access Grants. Note - These updates will not change any of the existing S3 API functionality.\n\n# v1.44.0 (2023-11-21)\n\n* **Feature**: Add support for automatic date based partitioning in S3 Server Access Logs.\n* **Bug Fix**: Don't send MaxKeys/MaxUploads=0 when unspecified in ListObjectVersions and ListMultipartUploads paginators.\n\n# v1.43.1 (2023-11-20)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.43.0 (2023-11-17)\n\n* **Feature**: **BREAKING CHANGE** Correct nullability of a large number of S3 structure fields. See https://github.com/aws/aws-sdk-go-v2/issues/2162.\n* **Feature**: Removes all default 0 values for numbers and false values for booleans\n\n# v1.42.2 (2023-11-15)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.42.1 (2023-11-09)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.42.0 (2023-11-01)\n\n* **Feature**: Adds support for configured endpoints via environment variables and the AWS shared configuration file.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.41.0 (2023-10-31)\n\n* **Feature**: **BREAKING CHANGE**: Bump minimum go version to 1.19 per the revised [go version support policy](https://aws.amazon.com/blogs/developer/aws-sdk-for-go-aligns-with-go-release-policy-on-supported-runtimes/).\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.40.2 (2023-10-12)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.40.1 (2023-10-06)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.40.0 (2023-09-26)\n\n* **Feature**: This release adds a new field COMPLETED to the ReplicationStatus Enum. You can now use this field to validate the replication status of S3 objects using the AWS SDK.\n\n# v1.39.0 (2023-09-20)\n\n* **Feature**: Fix an issue where the SDK can fail to unmarshall response due to NumberFormatException\n\n# v1.38.5 (2023-08-21)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.38.4 (2023-08-18)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.38.3 (2023-08-17)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.38.2 (2023-08-07)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.38.1 (2023-08-01)\n\n* No change notes available for this release.\n\n# v1.38.0 (2023-07-31)\n\n* **Feature**: Adds support for smithy-modeled endpoint resolution. A new rules-based endpoint resolution will be added to the SDK which will supercede and deprecate existing endpoint resolution. Specifically, EndpointResolver will be deprecated while BaseEndpoint and EndpointResolverV2 will take its place. For more information, please see the Endpoints section in our Developer Guide.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.37.1 (2023-07-28)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.37.0 (2023-07-13)\n\n* **Feature**: S3 Inventory now supports Object Access Control List and Object Owner as available object metadata fields in inventory reports.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.36.0 (2023-06-28)\n\n* **Feature**: The S3 LISTObjects, ListObjectsV2 and ListObjectVersions API now supports a new optional header x-amz-optional-object-attributes. If header contains RestoreStatus as the value, then S3 will include Glacier restore status i.e. isRestoreInProgress and RestoreExpiryDate in List response.\n\n# v1.35.0 (2023-06-16)\n\n* **Feature**: This release adds SDK support for request-payer request header and request-charged response header in the \"GetBucketAccelerateConfiguration\", \"ListMultipartUploads\", \"ListObjects\", \"ListObjectsV2\" and \"ListObjectVersions\" S3 APIs.\n\n# v1.34.1 (2023-06-15)\n\n* No change notes available for this release.\n\n# v1.34.0 (2023-06-13)\n\n* **Feature**: Integrate double encryption feature to SDKs.\n* **Bug Fix**: Fix HeadObject to return types.Nound when an object does not exist. Fixes [2084](https://github.com/aws/aws-sdk-go-v2/issues/2084)\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.33.1 (2023-05-04)\n\n* **Documentation**: Documentation updates for Amazon S3\n\n# v1.33.0 (2023-04-24)\n\n* **Feature**: added custom paginators for listMultipartUploads and ListObjectVersions\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.32.0 (2023-04-19)\n\n* **Feature**: Provides support for \"Snow\" Storage class.\n\n# v1.31.3 (2023-04-10)\n\n* No change notes available for this release.\n\n# v1.31.2 (2023-04-07)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.31.1 (2023-03-31)\n\n* **Documentation**: Documentation updates for Amazon S3\n\n# v1.31.0 (2023-03-21)\n\n* **Feature**: port v1 sdk 100-continue http header customization for s3 PutObject/UploadPart request and enable user config\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.30.6 (2023-03-10)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.30.5 (2023-02-22)\n\n* **Bug Fix**: Prevent nil pointer dereference when retrieving error codes.\n\n# v1.30.4 (2023-02-20)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.30.3 (2023-02-14)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.30.2 (2023-02-03)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.30.1 (2023-01-23)\n\n* No change notes available for this release.\n\n# v1.30.0 (2023-01-05)\n\n* **Feature**: Add `ErrorCodeOverride` field to all error structs (aws/smithy-go#401).\n\n# v1.29.6 (2022-12-15)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.29.5 (2022-12-02)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.29.4 (2022-11-22)\n\n* No change notes available for this release.\n\n# v1.29.3 (2022-11-16)\n\n* No change notes available for this release.\n\n# v1.29.2 (2022-11-10)\n\n* No change notes available for this release.\n\n# v1.29.1 (2022-10-24)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.29.0 (2022-10-21)\n\n* **Feature**: S3 on Outposts launches support for automatic bucket-style alias. You can use the automatic access point alias instead of an access point ARN for any object-level operation in an Outposts bucket.\n* **Bug Fix**: The SDK client has been updated to utilize the `aws.IsCredentialsProvider` function for determining if `aws.AnonymousCredentials` has been configured for the `CredentialProvider`.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.28.0 (2022-10-19)\n\n* **Feature**: Updates internal logic for constructing API endpoints. We have added rule-based endpoints and internal model parameters.\n\n# v1.27.11 (2022-09-20)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.10 (2022-09-14)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.9 (2022-09-02)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.8 (2022-08-31)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.7 (2022-08-30)\n\n* No change notes available for this release.\n\n# v1.27.6 (2022-08-29)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.5 (2022-08-11)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.4 (2022-08-09)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.3 (2022-08-08)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.2 (2022-08-01)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.1 (2022-07-05)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.27.0 (2022-07-01)\n\n* **Feature**: Add presign support for HeadBucket, DeleteObject, and DeleteBucket. Fixes [#1076](https://github.com/aws/aws-sdk-go-v2/issues/1076).\n\n# v1.26.12 (2022-06-29)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.11 (2022-06-07)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.10 (2022-05-17)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.9 (2022-05-06)\n\n* No change notes available for this release.\n\n# v1.26.8 (2022-05-03)\n\n* **Documentation**: Documentation only update for doc bug fixes for the S3 API docs.\n\n# v1.26.7 (2022-04-27)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.6 (2022-04-25)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.5 (2022-04-12)\n\n* **Bug Fix**: Fixes an issue that caused the unexported constructor function names for EventStream types to be swapped for the event reader and writer respectivly.\n\n# v1.26.4 (2022-04-07)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.3 (2022-03-30)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.2 (2022-03-24)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.1 (2022-03-23)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.26.0 (2022-03-08)\n\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.25.0 (2022-02-24)\n\n* **Feature**: API client updated\n* **Feature**: Adds RetryMaxAttempts and RetryMod to API client Options. This allows the API clients' default Retryer to be configured from the shared configuration files or environment variables. Adding a new Retry mode of `Adaptive`. `Adaptive` retry mode is an experimental mode, adding client rate limiting when throttles reponses are received from an API. See [retry.AdaptiveMode](https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/aws/retry#AdaptiveMode) for more details, and configuration options.\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Bug Fix**: Fixes the AWS Sigv4 signer to trim header value's whitespace when computing the canonical headers block of the string to sign.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.24.1 (2022-01-28)\n\n* **Bug Fix**: Updates SDK API client deserialization to pre-allocate byte slice and string response payloads, [#1565](https://github.com/aws/aws-sdk-go-v2/pull/1565). Thanks to [Tyson Mote](https://github.com/tysonmote) for submitting this PR.\n\n# v1.24.0 (2022-01-14)\n\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.23.0 (2022-01-07)\n\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Documentation**: API client updated\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.22.0 (2021-12-21)\n\n* **Feature**: API Paginators now support specifying the initial starting token, and support stopping on empty string tokens.\n* **Feature**: Updated to latest service endpoints\n\n# v1.21.0 (2021-12-02)\n\n* **Feature**: API client updated\n* **Bug Fix**: Fixes a bug that prevented aws.EndpointResolverWithOptions from being used by the service client. ([#1514](https://github.com/aws/aws-sdk-go-v2/pull/1514))\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.20.0 (2021-11-30)\n\n* **Feature**: API client updated\n\n# v1.19.1 (2021-11-19)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.19.0 (2021-11-12)\n\n* **Feature**: Waiters now have a `WaitForOutput` method, which can be used to retrieve the output of the successful wait operation. Thank you to [Andrew Haines](https://github.com/haines) for contributing this feature.\n\n# v1.18.0 (2021-11-06)\n\n* **Feature**: Support has been added for the SelectObjectContent API.\n* **Feature**: The SDK now supports configuration of FIPS and DualStack endpoints using environment variables, shared configuration, or programmatically.\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Feature**: Updated service to latest API model.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.17.0 (2021-10-21)\n\n* **Feature**: Updated  to latest version\n* **Feature**: Updates S3 streaming operations - PutObject, UploadPart, WriteGetObjectResponse to use unsigned payload signing auth when TLS is enabled.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.16.1 (2021-10-11)\n\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.16.0 (2021-09-17)\n\n* **Feature**: Updated API client and endpoints to latest revision.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.15.1 (2021-09-10)\n\n* No change notes available for this release.\n\n# v1.15.0 (2021-09-02)\n\n* **Feature**: API client updated\n* **Feature**: Add support for S3 Multi-Region Access Point ARNs.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.14.0 (2021-08-27)\n\n* **Feature**: Updated API model to latest revision.\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.13.0 (2021-08-19)\n\n* **Feature**: API client updated\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.12.0 (2021-08-04)\n\n* **Feature**: Add `HeadObject` presign support. ([#1346](https://github.com/aws/aws-sdk-go-v2/pull/1346))\n* **Dependency Update**: Updated `github.com/aws/smithy-go` to latest version.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.11.1 (2021-07-15)\n\n* **Dependency Update**: Updated `github.com/aws/smithy-go` to latest version\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.11.0 (2021-06-25)\n\n* **Feature**: Updated `github.com/aws/smithy-go` to latest version\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.10.0 (2021-06-04)\n\n* **Feature**: The handling of AccessPoint and Outpost ARNs have been updated.\n* **Feature**: Updated service client to latest API model.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.9.0 (2021-05-25)\n\n* **Feature**: API client updated\n\n# v1.8.0 (2021-05-20)\n\n* **Feature**: API client updated\n* **Dependency Update**: Updated to the latest SDK module versions\n\n# v1.7.0 (2021-05-14)\n\n* **Feature**: Constant has been added to modules to enable runtime version inspection for reporting.\n* **Feature**: Updated to latest service API model.\n* **Dependency Update**: Updated to the latest SDK module versions\n\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_DeleteBucketTagging.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// This operation is not supported for directory buckets.\n//\n// Deletes tags from the general purpose bucket if attribute based access control\n// (ABAC) is not enabled for the bucket. When you [enable ABAC for a general purpose bucket], you can no longer use this\n// operation for that bucket and must use [UntagResource]instead.\n//\n// if ABAC is not enabled for the bucket. When you [enable ABAC for a general purpose bucket], you can no longer use this\n// operation for that bucket and must use [UntagResource]instead.\n//\n// To use this operation, you must have permission to perform the\n// s3:PutBucketTagging action. By default, the bucket owner has this permission and\n// can grant this permission to others.\n//\n// The following operations are related to DeleteBucketTagging :\n//\n// [GetBucketTagging]\n//\n// [PutBucketTagging]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [GetBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketTagging.html\n// [PutBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketTagging.html\n// [enable ABAC for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging-enable-abac.html\n// [UntagResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_UntagResource.html\nfunc (c *Client) DeleteBucketTagging(ctx context.Context, params *DeleteBucketTaggingInput, optFns ...func(*Options)) (*DeleteBucketTaggingOutput, error) {\n\tif params == nil {\n\t\tparams = &DeleteBucketTaggingInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"DeleteBucketTagging\", params, optFns, c.addOperationDeleteBucketTaggingMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*DeleteBucketTaggingOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype DeleteBucketTaggingInput struct {\n\n\t// The bucket that has the tag set to be removed.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// The account ID of the expected bucket owner. If the account ID that you provide\n\t// does not match the actual owner of the bucket, the request fails with the HTTP\n\t// status code 403 Forbidden (access denied).\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *DeleteBucketTaggingInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.UseS3ExpressControlEndpoint = ptr.Bool(true)\n}\n\ntype DeleteBucketTaggingOutput struct {\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationDeleteBucketTaggingMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpDeleteBucketTagging{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpDeleteBucketTagging{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"DeleteBucketTagging\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpDeleteBucketTaggingValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opDeleteBucketTagging(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addDeleteBucketTaggingUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *DeleteBucketTaggingInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opDeleteBucketTagging(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"DeleteBucketTagging\",\n\t}\n}\n\n// getDeleteBucketTaggingBucketMember returns a pointer to string denoting a\n// provided bucket member valueand a boolean indicating if the input has a modeled\n// bucket name,\nfunc getDeleteBucketTaggingBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*DeleteBucketTaggingInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addDeleteBucketTaggingUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getDeleteBucketTaggingBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_GetBucketEncryption.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// Returns the default encryption configuration for an Amazon S3 bucket. By\n// default, all buckets have a default encryption configuration that uses\n// server-side encryption with Amazon S3 managed keys (SSE-S3). This operation also\n// returns the [BucketKeyEnabled]and [BlockedEncryptionTypes] statuses.\n//\n//   - General purpose buckets - For information about the bucket default\n//     encryption feature, see [Amazon S3 Bucket Default Encryption]in the Amazon S3 User Guide.\n//\n//   - Directory buckets - For directory buckets, there are only two supported\n//     options for server-side encryption: SSE-S3 and SSE-KMS. For information about\n//     the default encryption configuration in directory buckets, see [Setting default server-side encryption behavior for directory buckets].\n//\n// Permissions\n//\n//   - General purpose bucket permissions - The s3:GetEncryptionConfiguration\n//     permission is required in a policy. The bucket owner has this permission by\n//     default. The bucket owner can grant this permission to others. For more\n//     information about permissions, see [Permissions Related to Bucket Operations]and [Managing Access Permissions to Your Amazon S3 Resources].\n//\n//   - Directory bucket permissions - To grant access to this API operation, you\n//     must have the s3express:GetEncryptionConfiguration permission in an IAM\n//     identity-based policy instead of a bucket policy. Cross-account access to this\n//     API operation isn't supported. This operation can only be performed by the\n//     Amazon Web Services account that owns the resource. For more information about\n//     directory bucket policies and permissions, see [Amazon Web Services Identity and Access Management (IAM) for S3 Express One Zone]in the Amazon S3 User Guide.\n//\n// HTTP Host header syntax  Directory buckets - The HTTP Host header syntax is\n// s3express-control.region-code.amazonaws.com .\n//\n// The following operations are related to GetBucketEncryption :\n//\n// [PutBucketEncryption]\n//\n// [DeleteBucketEncryption]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [BucketKeyEnabled]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_BucketKeyEnabled.html\n// [BlockedEncryptionTypes]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_BlockedEncryptionTypes.html\n// [DeleteBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketEncryption.html\n// [PutBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketEncryption.html\n// [Setting default server-side encryption behavior for directory buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-bucket-encryption.html\n// [Amazon S3 Bucket Default Encryption]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-encryption.html\n// [Managing Access Permissions to Your Amazon S3 Resources]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.html\n// [Permissions Related to Bucket Operations]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.html#using-with-s3-actions-related-to-bucket-subresources\n// [Amazon Web Services Identity and Access Management (IAM) for S3 Express One Zone]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-security-iam.html\nfunc (c *Client) GetBucketEncryption(ctx context.Context, params *GetBucketEncryptionInput, optFns ...func(*Options)) (*GetBucketEncryptionOutput, error) {\n\tif params == nil {\n\t\tparams = &GetBucketEncryptionInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"GetBucketEncryption\", params, optFns, c.addOperationGetBucketEncryptionMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*GetBucketEncryptionOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype GetBucketEncryptionInput struct {\n\n\t// The name of the bucket from which the server-side encryption configuration is\n\t// retrieved.\n\t//\n\t// Directory buckets - When you use this operation with a directory bucket, you\n\t// must use path-style requests in the format\n\t// https://s3express-control.region-code.amazonaws.com/bucket-name .\n\t// Virtual-hosted-style requests aren't supported. Directory bucket names must be\n\t// unique in the chosen Zone (Availability Zone or Local Zone). Bucket names must\n\t// also follow the format bucket-base-name--zone-id--x-s3 (for example,\n\t// DOC-EXAMPLE-BUCKET--usw2-az1--x-s3 ). For information about bucket naming\n\t// restrictions, see [Directory bucket naming rules]in the Amazon S3 User Guide\n\t//\n\t// [Directory bucket naming rules]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-bucket-naming-rules.html\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// The account ID of the expected bucket owner. If the account ID that you provide\n\t// does not match the actual owner of the bucket, the request fails with the HTTP\n\t// status code 403 Forbidden (access denied).\n\t//\n\t// For directory buckets, this header is not supported in this API operation. If\n\t// you specify this header, the request fails with the HTTP status code 501 Not\n\t// Implemented .\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *GetBucketEncryptionInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.UseS3ExpressControlEndpoint = ptr.Bool(true)\n}\n\ntype GetBucketEncryptionOutput struct {\n\n\t// Specifies the default server-side-encryption configuration.\n\tServerSideEncryptionConfiguration *types.ServerSideEncryptionConfiguration\n\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationGetBucketEncryptionMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpGetBucketEncryption{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpGetBucketEncryption{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"GetBucketEncryption\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpGetBucketEncryptionValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opGetBucketEncryption(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addGetBucketEncryptionUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *GetBucketEncryptionInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opGetBucketEncryption(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"GetBucketEncryption\",\n\t}\n}\n\n// getGetBucketEncryptionBucketMember returns a pointer to string denoting a\n// provided bucket member valueand a boolean indicating if the input has a modeled\n// bucket name,\nfunc getGetBucketEncryptionBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*GetBucketEncryptionInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addGetBucketEncryptionUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getGetBucketEncryptionBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_GetBucketTagging.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// This operation is not supported for directory buckets.\n//\n// Returns the tag set associated with the general purpose bucket.\n//\n// if ABAC is not enabled for the bucket. When you [enable ABAC for a general purpose bucket], you can no longer use this\n// operation for that bucket and must use [ListTagsForResource]instead.\n//\n// To use this operation, you must have permission to perform the\n// s3:GetBucketTagging action. By default, the bucket owner has this permission and\n// can grant this permission to others.\n//\n// GetBucketTagging has the following special error:\n//\n//   - Error code: NoSuchTagSet\n//\n//   - Description: There is no tag set associated with the bucket.\n//\n// The following operations are related to GetBucketTagging :\n//\n// [PutBucketTagging]\n//\n// [DeleteBucketTagging]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [PutBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketTagging.html\n// [enable ABAC for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging-enable-abac.html\n// [DeleteBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketTagging.html\n// [ListTagsForResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_ListTagsForResource.html\nfunc (c *Client) GetBucketTagging(ctx context.Context, params *GetBucketTaggingInput, optFns ...func(*Options)) (*GetBucketTaggingOutput, error) {\n\tif params == nil {\n\t\tparams = &GetBucketTaggingInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"GetBucketTagging\", params, optFns, c.addOperationGetBucketTaggingMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*GetBucketTaggingOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype GetBucketTaggingInput struct {\n\n\t// The name of the bucket for which to get the tagging information.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// The account ID of the expected bucket owner. If the account ID that you provide\n\t// does not match the actual owner of the bucket, the request fails with the HTTP\n\t// status code 403 Forbidden (access denied).\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *GetBucketTaggingInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.UseS3ExpressControlEndpoint = ptr.Bool(true)\n}\n\ntype GetBucketTaggingOutput struct {\n\n\t// Contains the tag set.\n\t//\n\t// This member is required.\n\tTagSet []types.Tag\n\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationGetBucketTaggingMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpGetBucketTagging{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpGetBucketTagging{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"GetBucketTagging\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpGetBucketTaggingValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opGetBucketTagging(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addGetBucketTaggingUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *GetBucketTaggingInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opGetBucketTagging(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"GetBucketTagging\",\n\t}\n}\n\n// getGetBucketTaggingBucketMember returns a pointer to string denoting a provided\n// bucket member valueand a boolean indicating if the input has a modeled bucket\n// name,\nfunc getGetBucketTaggingBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*GetBucketTaggingInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addGetBucketTaggingUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getGetBucketTaggingBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_PutBucketEncryption.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\tinternalChecksum \"github.com/aws/aws-sdk-go-v2/service/internal/checksum\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// This operation configures default encryption and Amazon S3 Bucket Keys for an\n// existing bucket. You can also [block encryption types]using this operation.\n//\n// Directory buckets - For directory buckets, you must make requests for this API\n// operation to the Regional endpoint. These endpoints support path-style requests\n// in the format https://s3express-control.region-code.amazonaws.com/bucket-name .\n// Virtual-hosted-style requests aren't supported. For more information about\n// endpoints in Availability Zones, see [Regional and Zonal endpoints for directory buckets in Availability Zones]in the Amazon S3 User Guide. For more\n// information about endpoints in Local Zones, see [Concepts for directory buckets in Local Zones]in the Amazon S3 User Guide.\n//\n// By default, all buckets have a default encryption configuration that uses\n// server-side encryption with Amazon S3 managed keys (SSE-S3).\n//\n//   - General purpose buckets\n//\n//   - You can optionally configure default encryption for a bucket by using\n//     server-side encryption with Key Management Service (KMS) keys (SSE-KMS) or\n//     dual-layer server-side encryption with Amazon Web Services KMS keys (DSSE-KMS).\n//     If you specify default encryption by using SSE-KMS, you can also configure [Amazon S3 Bucket Keys].\n//     For information about the bucket default encryption feature, see [Amazon S3 Bucket Default Encryption]in the\n//     Amazon S3 User Guide.\n//\n//   - If you use PutBucketEncryption to set your [default bucket encryption]to SSE-KMS, you should verify\n//     that your KMS key ID is correct. Amazon S3 doesn't validate the KMS key ID\n//     provided in PutBucketEncryption requests.\n//\n//   - Directory buckets - You can optionally configure default encryption for a\n//     bucket by using server-side encryption with Key Management Service (KMS) keys\n//     (SSE-KMS).\n//\n//   - We recommend that the bucket's default encryption uses the desired\n//     encryption configuration and you don't override the bucket default encryption in\n//     your CreateSession requests or PUT object requests. Then, new objects are\n//     automatically encrypted with the desired encryption settings. For more\n//     information about the encryption overriding behaviors in directory buckets, see [Specifying server-side encryption with KMS for new object uploads]\n//     .\n//\n//   - Your SSE-KMS configuration can only support 1 [customer managed key]per directory bucket's\n//     lifetime. The [Amazon Web Services managed key]( aws/s3 ) isn't supported.\n//\n//   - S3 Bucket Keys are always enabled for GET and PUT operations in a directory\n//     bucket and cant be disabled. S3 Bucket Keys aren't supported, when you copy\n//     SSE-KMS encrypted objects from general purpose buckets to directory buckets,\n//     from directory buckets to general purpose buckets, or between directory buckets,\n//     through [CopyObject], [UploadPartCopy], [the Copy operation in Batch Operations], or [the import jobs]. In this case, Amazon S3 makes a call to KMS every time a\n//     copy request is made for a KMS-encrypted object.\n//\n//   - When you specify an [KMS customer managed key]for encryption in your directory bucket, only use the\n//     key ID or key ARN. The key alias format of the KMS key isn't supported.\n//\n//   - For directory buckets, if you use PutBucketEncryption to set your [default bucket encryption]to\n//     SSE-KMS, Amazon S3 validates the KMS key ID provided in PutBucketEncryption\n//     requests.\n//\n// If you're specifying a customer managed KMS key, we recommend using a fully\n// qualified KMS key ARN. If you use a KMS key alias instead, then KMS resolves the\n// key within the requesters account. This behavior can result in data that's\n// encrypted with a KMS key that belongs to the requester, and not the bucket\n// owner.\n//\n// Also, this action requires Amazon Web Services Signature Version 4. For more\n// information, see [Authenticating Requests (Amazon Web Services Signature Version 4)].\n//\n// Permissions\n//\n//   - General purpose bucket permissions - The s3:PutEncryptionConfiguration\n//     permission is required in a policy. The bucket owner has this permission by\n//     default. The bucket owner can grant this permission to others. For more\n//     information about permissions, see [Permissions Related to Bucket Operations]and [Managing Access Permissions to Your Amazon S3 Resources]in the Amazon S3 User Guide.\n//\n//   - Directory bucket permissions - To grant access to this API operation, you\n//     must have the s3express:PutEncryptionConfiguration permission in an IAM\n//     identity-based policy instead of a bucket policy. Cross-account access to this\n//     API operation isn't supported. This operation can only be performed by the\n//     Amazon Web Services account that owns the resource. For more information about\n//     directory bucket policies and permissions, see [Amazon Web Services Identity and Access Management (IAM) for S3 Express One Zone]in the Amazon S3 User Guide.\n//\n// To set a directory bucket default encryption with SSE-KMS, you must also have\n//\n//\tthe kms:GenerateDataKey and the kms:Decrypt permissions in IAM identity-based\n//\tpolicies and KMS key policies for the target KMS key.\n//\n// HTTP Host header syntax  Directory buckets - The HTTP Host header syntax is\n// s3express-control.region-code.amazonaws.com .\n//\n// The following operations are related to PutBucketEncryption :\n//\n// [GetBucketEncryption]\n//\n// [DeleteBucketEncryption]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [Specifying server-side encryption with KMS for new object uploads]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-specifying-kms-encryption.html\n// [Concepts for directory buckets in Local Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-lzs-for-directory-buckets.html\n// [KMS customer managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk\n// [Amazon S3 Bucket Default Encryption]: https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html\n// [CopyObject]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CopyObject.html\n// [Managing Access Permissions to Your Amazon S3 Resources]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.html\n// [Permissions Related to Bucket Operations]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.html#using-with-s3-actions-related-to-bucket-subresources\n// [UploadPartCopy]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html\n// [Amazon Web Services managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk\n// [Authenticating Requests (Amazon Web Services Signature Version 4)]: https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html\n// [Amazon Web Services Identity and Access Management (IAM) for S3 Express One Zone]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-security-iam.html\n// [Amazon S3 Bucket Keys]: https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html\n// [GetBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketEncryption.html\n// [DeleteBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketEncryption.html\n// [customer managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk\n// [block encryption types]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_BlockedEncryptionTypes.html\n// [default bucket encryption]: https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html\n// [the import jobs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-import-job\n// [the Copy operation in Batch Operations]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-objects-Batch-Ops\n// [Regional and Zonal endpoints for directory buckets in Availability Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/endpoint-directory-buckets-AZ.html\nfunc (c *Client) PutBucketEncryption(ctx context.Context, params *PutBucketEncryptionInput, optFns ...func(*Options)) (*PutBucketEncryptionOutput, error) {\n\tif params == nil {\n\t\tparams = &PutBucketEncryptionInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"PutBucketEncryption\", params, optFns, c.addOperationPutBucketEncryptionMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*PutBucketEncryptionOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype PutBucketEncryptionInput struct {\n\n\t// Specifies default encryption for a bucket using server-side encryption with\n\t// different key options.\n\t//\n\t// Directory buckets - When you use this operation with a directory bucket, you\n\t// must use path-style requests in the format\n\t// https://s3express-control.region-code.amazonaws.com/bucket-name .\n\t// Virtual-hosted-style requests aren't supported. Directory bucket names must be\n\t// unique in the chosen Zone (Availability Zone or Local Zone). Bucket names must\n\t// also follow the format bucket-base-name--zone-id--x-s3 (for example,\n\t// DOC-EXAMPLE-BUCKET--usw2-az1--x-s3 ). For information about bucket naming\n\t// restrictions, see [Directory bucket naming rules]in the Amazon S3 User Guide\n\t//\n\t// [Directory bucket naming rules]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-bucket-naming-rules.html\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Specifies the default server-side-encryption configuration.\n\t//\n\t// This member is required.\n\tServerSideEncryptionConfiguration *types.ServerSideEncryptionConfiguration\n\n\t// Indicates the algorithm used to create the checksum for the request when you\n\t// use the SDK. This header will not provide any additional functionality if you\n\t// don't use the SDK. When you send this header, there must be a corresponding\n\t// x-amz-checksum or x-amz-trailer header sent. Otherwise, Amazon S3 fails the\n\t// request with the HTTP status code 400 Bad Request . For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// If you provide an individual checksum, Amazon S3 ignores any provided\n\t// ChecksumAlgorithm parameter.\n\t//\n\t// For directory buckets, when you use Amazon Web Services SDKs, CRC32 is the\n\t// default checksum algorithm that's used for performance.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumAlgorithm types.ChecksumAlgorithm\n\n\t// The Base64 encoded 128-bit MD5 digest of the server-side encryption\n\t// configuration.\n\t//\n\t// For requests made using the Amazon Web Services Command Line Interface (CLI) or\n\t// Amazon Web Services SDKs, this field is calculated automatically.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tContentMD5 *string\n\n\t// The account ID of the expected bucket owner. If the account ID that you provide\n\t// does not match the actual owner of the bucket, the request fails with the HTTP\n\t// status code 403 Forbidden (access denied).\n\t//\n\t// For directory buckets, this header is not supported in this API operation. If\n\t// you specify this header, the request fails with the HTTP status code 501 Not\n\t// Implemented .\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *PutBucketEncryptionInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.UseS3ExpressControlEndpoint = ptr.Bool(true)\n}\n\ntype PutBucketEncryptionOutput struct {\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationPutBucketEncryptionMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpPutBucketEncryption{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpPutBucketEncryption{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"PutBucketEncryption\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestChecksumMetricsTracking(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpPutBucketEncryptionValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opPutBucketEncryption(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketEncryptionInputChecksumMiddlewares(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketEncryptionUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = s3cust.AddExpressDefaultChecksumMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *PutBucketEncryptionInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opPutBucketEncryption(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"PutBucketEncryption\",\n\t}\n}\n\n// getPutBucketEncryptionRequestAlgorithmMember gets the request checksum\n// algorithm value provided as input.\nfunc getPutBucketEncryptionRequestAlgorithmMember(input interface{}) (string, bool) {\n\tin := input.(*PutBucketEncryptionInput)\n\tif len(in.ChecksumAlgorithm) == 0 {\n\t\treturn \"\", false\n\t}\n\treturn string(in.ChecksumAlgorithm), true\n}\n\nfunc addPutBucketEncryptionInputChecksumMiddlewares(stack *middleware.Stack, options Options) error {\n\treturn addInputChecksumMiddleware(stack, internalChecksum.InputMiddlewareOptions{\n\t\tGetAlgorithm:                     getPutBucketEncryptionRequestAlgorithmMember,\n\t\tRequireChecksum:                  true,\n\t\tRequestChecksumCalculation:       options.RequestChecksumCalculation,\n\t\tEnableTrailingChecksum:           false,\n\t\tEnableComputeSHA256PayloadHash:   true,\n\t\tEnableDecodedContentLengthHeader: true,\n\t})\n}\n\n// getPutBucketEncryptionBucketMember returns a pointer to string denoting a\n// provided bucket member valueand a boolean indicating if the input has a modeled\n// bucket name,\nfunc getPutBucketEncryptionBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*PutBucketEncryptionInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addPutBucketEncryptionUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getPutBucketEncryptionBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_PutBucketTagging.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\tinternalChecksum \"github.com/aws/aws-sdk-go-v2/service/internal/checksum\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// This operation is not supported for directory buckets.\n//\n// Sets the tags for a general purpose bucket if attribute based access control\n// (ABAC) is not enabled for the bucket. When you [enable ABAC for a general purpose bucket], you can no longer use this\n// operation for that bucket and must use the [TagResource]or [UntagResource] operations instead.\n//\n// if ABAC is not enabled for the bucket. When you [enable ABAC for a general purpose bucket], you can no longer use this\n// operation for that bucket and must use [TagResource]instead.\n//\n// Use tags to organize your Amazon Web Services bill to reflect your own cost\n// structure. To do this, sign up to get your Amazon Web Services account bill with\n// tag key values included. Then, to see the cost of combined resources, organize\n// your billing information according to resources with the same tag key values.\n// For example, you can tag several resources with a specific application name, and\n// then organize your billing information to see the total cost of that application\n// across several services. For more information, see [Cost Allocation and Tagging]and [Using Cost Allocation in Amazon S3 Bucket Tags].\n//\n// When this operation sets the tags for a bucket, it will overwrite any current\n// tags the bucket already has. You cannot use this operation to add tags to an\n// existing list of tags.\n//\n// To use this operation, you must have permissions to perform the\n// s3:PutBucketTagging action. The bucket owner has this permission by default and\n// can grant this permission to others. For more information about permissions, see\n// [Permissions Related to Bucket Subresource Operations]and [Managing Access Permissions to Your Amazon S3 Resources].\n//\n// PutBucketTagging has the following special errors. For more Amazon S3 errors\n// see, [Error Responses].\n//\n//   - InvalidTag - The tag provided was not a valid tag. This error can occur if\n//     the tag did not pass input validation. For more information, see [Using Cost Allocation in Amazon S3 Bucket Tags].\n//\n//   - MalformedXML - The XML provided does not match the schema.\n//\n//   - OperationAborted - A conflicting conditional action is currently in progress\n//     against this resource. Please try again.\n//\n//   - InternalError - The service was unable to apply the provided tag to the\n//     bucket.\n//\n// The following operations are related to PutBucketTagging :\n//\n// [GetBucketTagging]\n//\n// [DeleteBucketTagging]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [Error Responses]: https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n// [GetBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketTagging.html\n// [Cost Allocation and Tagging]: https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html\n// [enable ABAC for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging-enable-abac.html\n// [Permissions Related to Bucket Subresource Operations]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.html#using-with-s3-actions-related-to-bucket-subresources\n// [DeleteBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketTagging.html\n// [TagResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_TagResource.html\n// [UntagResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_UntagResource.html\n// [Using Cost Allocation in Amazon S3 Bucket Tags]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/CostAllocTagging.html\n// [Managing Access Permissions to Your Amazon S3 Resources]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.html\nfunc (c *Client) PutBucketTagging(ctx context.Context, params *PutBucketTaggingInput, optFns ...func(*Options)) (*PutBucketTaggingOutput, error) {\n\tif params == nil {\n\t\tparams = &PutBucketTaggingInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"PutBucketTagging\", params, optFns, c.addOperationPutBucketTaggingMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*PutBucketTaggingOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype PutBucketTaggingInput struct {\n\n\t// The bucket name.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Container for the TagSet and Tag elements.\n\t//\n\t// This member is required.\n\tTagging *types.Tagging\n\n\t// Indicates the algorithm used to create the checksum for the request when you\n\t// use the SDK. This header will not provide any additional functionality if you\n\t// don't use the SDK. When you send this header, there must be a corresponding\n\t// x-amz-checksum or x-amz-trailer header sent. Otherwise, Amazon S3 fails the\n\t// request with the HTTP status code 400 Bad Request . For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// If you provide an individual checksum, Amazon S3 ignores any provided\n\t// ChecksumAlgorithm parameter.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumAlgorithm types.ChecksumAlgorithm\n\n\t// The Base64 encoded 128-bit MD5 digest of the data. You must use this header as\n\t// a message integrity check to verify that the request body was not corrupted in\n\t// transit. For more information, see [RFC 1864].\n\t//\n\t// For requests made using the Amazon Web Services Command Line Interface (CLI) or\n\t// Amazon Web Services SDKs, this field is calculated automatically.\n\t//\n\t// [RFC 1864]: http://www.ietf.org/rfc/rfc1864.txt\n\tContentMD5 *string\n\n\t// The account ID of the expected bucket owner. If the account ID that you provide\n\t// does not match the actual owner of the bucket, the request fails with the HTTP\n\t// status code 403 Forbidden (access denied).\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *PutBucketTaggingInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.UseS3ExpressControlEndpoint = ptr.Bool(true)\n}\n\ntype PutBucketTaggingOutput struct {\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationPutBucketTaggingMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpPutBucketTagging{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpPutBucketTagging{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"PutBucketTagging\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestChecksumMetricsTracking(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpPutBucketTaggingValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opPutBucketTagging(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketTaggingInputChecksumMiddlewares(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketTaggingUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = s3cust.AddExpressDefaultChecksumMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *PutBucketTaggingInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opPutBucketTagging(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"PutBucketTagging\",\n\t}\n}\n\n// getPutBucketTaggingRequestAlgorithmMember gets the request checksum algorithm\n// value provided as input.\nfunc getPutBucketTaggingRequestAlgorithmMember(input interface{}) (string, bool) {\n\tin := input.(*PutBucketTaggingInput)\n\tif len(in.ChecksumAlgorithm) == 0 {\n\t\treturn \"\", false\n\t}\n\treturn string(in.ChecksumAlgorithm), true\n}\n\nfunc addPutBucketTaggingInputChecksumMiddlewares(stack *middleware.Stack, options Options) error {\n\treturn addInputChecksumMiddleware(stack, internalChecksum.InputMiddlewareOptions{\n\t\tGetAlgorithm:                     getPutBucketTaggingRequestAlgorithmMember,\n\t\tRequireChecksum:                  true,\n\t\tRequestChecksumCalculation:       options.RequestChecksumCalculation,\n\t\tEnableTrailingChecksum:           false,\n\t\tEnableComputeSHA256PayloadHash:   true,\n\t\tEnableDecodedContentLengthHeader: true,\n\t})\n}\n\n// getPutBucketTaggingBucketMember returns a pointer to string denoting a provided\n// bucket member valueand a boolean indicating if the input has a modeled bucket\n// name,\nfunc getPutBucketTaggingBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*PutBucketTaggingInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addPutBucketTaggingUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getPutBucketTaggingBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_UploadPart.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\tawshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\"\n\tinternalChecksum \"github.com/aws/aws-sdk-go-v2/service/internal/checksum\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n\t\"io\"\n)\n\n// Uploads a part in a multipart upload.\n//\n// In this operation, you provide new data as a part of an object in your request.\n// However, you have an option to specify your existing Amazon S3 object as a data\n// source for the part you are uploading. To upload a part from an existing object,\n// you use the [UploadPartCopy]operation.\n//\n// You must initiate a multipart upload (see [CreateMultipartUpload]) before you can upload any part. In\n// response to your initiate request, Amazon S3 returns an upload ID, a unique\n// identifier that you must include in your upload part request.\n//\n// Part numbers can be any number from 1 to 10,000, inclusive. A part number\n// uniquely identifies a part and also defines its position within the object being\n// created. If you upload a new part using the same part number that was used with\n// a previous part, the previously uploaded part is overwritten.\n//\n// For information about maximum and minimum part sizes and other multipart upload\n// specifications, see [Multipart upload limits]in the Amazon S3 User Guide.\n//\n// After you initiate multipart upload and upload one or more parts, you must\n// either complete or abort multipart upload in order to stop getting charged for\n// storage of the uploaded parts. Only after you either complete or abort multipart\n// upload, Amazon S3 frees up the parts storage and stops charging you for the\n// parts storage.\n//\n// For more information on multipart uploads, go to [Multipart Upload Overview] in the Amazon S3 User Guide .\n//\n// Directory buckets - For directory buckets, you must make requests for this API\n// operation to the Zonal endpoint. These endpoints support virtual-hosted-style\n// requests in the format\n// https://amzn-s3-demo-bucket.s3express-zone-id.region-code.amazonaws.com/key-name\n// . Path-style requests are not supported. For more information about endpoints\n// in Availability Zones, see [Regional and Zonal endpoints for directory buckets in Availability Zones]in the Amazon S3 User Guide. For more information\n// about endpoints in Local Zones, see [Concepts for directory buckets in Local Zones]in the Amazon S3 User Guide.\n//\n// Permissions\n//   - General purpose bucket permissions - To perform a multipart upload with\n//     encryption using an Key Management Service key, the requester must have\n//     permission to the kms:Decrypt and kms:GenerateDataKey actions on the key. The\n//     requester must also have permissions for the kms:GenerateDataKey action for\n//     the CreateMultipartUpload API. Then, the requester needs permissions for the\n//     kms:Decrypt action on the UploadPart and UploadPartCopy APIs.\n//\n// These permissions are required because Amazon S3 must decrypt and read data\n//\n//\tfrom the encrypted file parts before it completes the multipart upload. For more\n//\tinformation about KMS permissions, see [Protecting data using server-side encryption with KMS]in the Amazon S3 User Guide. For\n//\tinformation about the permissions required to use the multipart upload API, see [Multipart upload and permissions]\n//\tand [Multipart upload API and permissions]in the Amazon S3 User Guide.\n//\n//\t- Directory bucket permissions - To grant access to this API operation on a\n//\tdirectory bucket, we recommend that you use the [CreateSession]CreateSession API operation\n//\tfor session-based authorization. Specifically, you grant the\n//\ts3express:CreateSession permission to the directory bucket in a bucket policy\n//\tor an IAM identity-based policy. Then, you make the CreateSession API call on\n//\tthe bucket to obtain a session token. With the session token in your request\n//\theader, you can make API requests to this operation. After the session token\n//\texpires, you make another CreateSession API call to generate a new session\n//\ttoken for use. Amazon Web Services CLI or SDKs create session and refresh the\n//\tsession token automatically to avoid service interruptions when a session\n//\texpires. For more information about authorization, see [CreateSession]CreateSession .\n//\n// If the object is encrypted with SSE-KMS, you must also have the\n//\n//\tkms:GenerateDataKey and kms:Decrypt permissions in IAM identity-based policies\n//\tand KMS key policies for the KMS key.\n//\n// Data integrity  General purpose bucket - To ensure that data is not corrupted\n// traversing the network, specify the Content-MD5 header in the upload part\n// request. Amazon S3 checks the part data against the provided MD5 value. If they\n// do not match, Amazon S3 returns an error. If the upload request is signed with\n// Signature Version 4, then Amazon Web Services S3 uses the x-amz-content-sha256\n// header as a checksum instead of Content-MD5 . For more information see [Authenticating Requests: Using the Authorization Header (Amazon Web Services Signature Version 4)].\n//\n// Directory buckets - MD5 is not supported by directory buckets. You can use\n// checksum algorithms to check object integrity.\n//\n// Encryption\n//   - General purpose bucket - Server-side encryption is for data encryption at\n//     rest. Amazon S3 encrypts your data as it writes it to disks in its data centers\n//     and decrypts it when you access it. You have mutually exclusive options to\n//     protect data using server-side encryption in Amazon S3, depending on how you\n//     choose to manage the encryption keys. Specifically, the encryption key options\n//     are Amazon S3 managed keys (SSE-S3), Amazon Web Services KMS keys (SSE-KMS), and\n//     Customer-Provided Keys (SSE-C). Amazon S3 encrypts data with server-side\n//     encryption using Amazon S3 managed keys (SSE-S3) by default. You can optionally\n//     tell Amazon S3 to encrypt data at rest using server-side encryption with other\n//     key options. The option you use depends on whether you want to use KMS keys\n//     (SSE-KMS) or provide your own encryption key (SSE-C).\n//\n// Server-side encryption is supported by the S3 Multipart Upload operations.\n//\n//\tUnless you are using a customer-provided encryption key (SSE-C), you don't need\n//\tto specify the encryption parameters in each UploadPart request. Instead, you\n//\tonly need to specify the server-side encryption parameters in the initial\n//\tInitiate Multipart request. For more information, see [CreateMultipartUpload].\n//\n// If you have server-side encryption with customer-provided keys (SSE-C) blocked\n//\n//\tfor your general purpose bucket, you will get an HTTP 403 Access Denied error\n//\twhen you specify the SSE-C request headers while writing new data to your\n//\tbucket. For more information, see [Blocking or unblocking SSE-C for a general purpose bucket].\n//\n// If you request server-side encryption using a customer-provided encryption key\n//\n//\t(SSE-C) in your initiate multipart upload request, you must provide identical\n//\tencryption information in each part upload using the following request headers.\n//\n//\t- x-amz-server-side-encryption-customer-algorithm\n//\n//\t- x-amz-server-side-encryption-customer-key\n//\n//\t- x-amz-server-side-encryption-customer-key-MD5\n//\n// For more information, see [Using Server-Side Encryption]in the Amazon S3 User Guide.\n//\n//   - Directory buckets - For directory buckets, there are only two supported\n//     options for server-side encryption: server-side encryption with Amazon S3\n//     managed keys (SSE-S3) ( AES256 ) and server-side encryption with KMS keys\n//     (SSE-KMS) ( aws:kms ).\n//\n// Special errors\n//\n//   - Error Code: NoSuchUpload\n//\n//   - Description: The specified multipart upload does not exist. The upload ID\n//     might be invalid, or the multipart upload might have been aborted or completed.\n//\n//   - HTTP Status Code: 404 Not Found\n//\n//   - SOAP Fault Code Prefix: Client\n//\n// HTTP Host header syntax  Directory buckets - The HTTP Host header syntax is\n// Bucket-name.s3express-zone-id.region-code.amazonaws.com .\n//\n// The following operations are related to UploadPart :\n//\n// [CreateMultipartUpload]\n//\n// [CompleteMultipartUpload]\n//\n// [AbortMultipartUpload]\n//\n// [ListParts]\n//\n// [ListMultipartUploads]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [Concepts for directory buckets in Local Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-lzs-for-directory-buckets.html\n// [ListParts]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html\n// [Authenticating Requests: Using the Authorization Header (Amazon Web Services Signature Version 4)]: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html\n// [UploadPartCopy]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html\n// [CompleteMultipartUpload]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html\n// [CreateMultipartUpload]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html\n// [Using Server-Side Encryption]: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html\n// [Multipart upload limits]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\n// [AbortMultipartUpload]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html\n// [Multipart Upload Overview]: https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html\n// [ListMultipartUploads]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html\n// [Regional and Zonal endpoints for directory buckets in Availability Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/endpoint-directory-buckets-AZ.html\n//\n// [Protecting data using server-side encryption with KMS]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html\n// [Multipart upload and permissions]: https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html\n// [CreateSession]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateSession.html\n// [Multipart upload API and permissions]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html#mpuAndPermissions\n// [Blocking or unblocking SSE-C for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/blocking-unblocking-s3-c-encryption-gpb.html\nfunc (c *Client) UploadPart(ctx context.Context, params *UploadPartInput, optFns ...func(*Options)) (*UploadPartOutput, error) {\n\tif params == nil {\n\t\tparams = &UploadPartInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"UploadPart\", params, optFns, c.addOperationUploadPartMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*UploadPartOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype UploadPartInput struct {\n\n\t// The name of the bucket to which the multipart upload was initiated.\n\t//\n\t// Directory buckets - When you use this operation with a directory bucket, you\n\t// must use virtual-hosted-style requests in the format\n\t// Bucket-name.s3express-zone-id.region-code.amazonaws.com . Path-style requests\n\t// are not supported. Directory bucket names must be unique in the chosen Zone\n\t// (Availability Zone or Local Zone). Bucket names must follow the format\n\t// bucket-base-name--zone-id--x-s3 (for example,\n\t// amzn-s3-demo-bucket--usw2-az1--x-s3 ). For information about bucket naming\n\t// restrictions, see [Directory bucket naming rules]in the Amazon S3 User Guide.\n\t//\n\t// Access points - When you use this action with an access point for general\n\t// purpose buckets, you must provide the alias of the access point in place of the\n\t// bucket name or specify the access point ARN. When you use this action with an\n\t// access point for directory buckets, you must provide the access point name in\n\t// place of the bucket name. When using the access point ARN, you must direct\n\t// requests to the access point hostname. The access point hostname takes the form\n\t// AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this\n\t// action with an access point through the Amazon Web Services SDKs, you provide\n\t// the access point ARN in place of the bucket name. For more information about\n\t// access point ARNs, see [Using access points]in the Amazon S3 User Guide.\n\t//\n\t// Object Lambda access points are not supported by directory buckets.\n\t//\n\t// S3 on Outposts - When you use this action with S3 on Outposts, you must direct\n\t// requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the\n\t// form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com . When\n\t// you use this action with S3 on Outposts, the destination bucket must be the\n\t// Outposts access point ARN or the access point alias. For more information about\n\t// S3 on Outposts, see [What is S3 on Outposts?]in the Amazon S3 User Guide.\n\t//\n\t// [Directory bucket naming rules]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-bucket-naming-rules.html\n\t// [What is S3 on Outposts?]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html\n\t// [Using access points]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Object key for which the multipart upload was initiated.\n\t//\n\t// This member is required.\n\tKey *string\n\n\t// Part number of part being uploaded. This is a positive integer between 1 and\n\t// 10,000.\n\t//\n\t// This member is required.\n\tPartNumber *int32\n\n\t// Upload ID identifying the multipart upload whose part is being uploaded.\n\t//\n\t// This member is required.\n\tUploadId *string\n\n\t// Object data.\n\tBody io.Reader\n\n\t// Indicates the algorithm used to create the checksum for the object when you use\n\t// the SDK. This header will not provide any additional functionality if you don't\n\t// use the SDK. When you send this header, there must be a corresponding\n\t// x-amz-checksum or x-amz-trailer header sent. Otherwise, Amazon S3 fails the\n\t// request with the HTTP status code 400 Bad Request . For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// If you provide an individual checksum, Amazon S3 ignores any provided\n\t// ChecksumAlgorithm parameter.\n\t//\n\t// This checksum algorithm must be the same for all parts and it match the\n\t// checksum value supplied in the CreateMultipartUpload request.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumAlgorithm types.ChecksumAlgorithm\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 32-bit CRC32 checksum of the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32 *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 32-bit CRC32C checksum of the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32C *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 64-bit CRC64NVME checksum of the part. For more information,\n\t// see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 160-bit SHA1 digest of the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA1 *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 256-bit SHA256 digest of the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA256 *string\n\n\t// Size of the body in bytes. This parameter is useful when the size of the body\n\t// cannot be determined automatically.\n\tContentLength *int64\n\n\t// The Base64 encoded 128-bit MD5 digest of the part data. This parameter is\n\t// auto-populated when using the command from the CLI. This parameter is required\n\t// if object lock parameters are specified.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tContentMD5 *string\n\n\t// The account ID of the expected bucket owner. If the account ID that you provide\n\t// does not match the actual owner of the bucket, the request fails with the HTTP\n\t// status code 403 Forbidden (access denied).\n\tExpectedBucketOwner *string\n\n\t// Confirms that the requester knows that they will be charged for the request.\n\t// Bucket owners need not specify this parameter in their requests. If either the\n\t// source or destination S3 bucket has Requester Pays enabled, the requester will\n\t// pay for corresponding charges to copy the object. For information about\n\t// downloading objects from Requester Pays buckets, see [Downloading Objects in Requester Pays Buckets]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// This functionality is not supported for directory buckets.\n\t//\n\t// [Downloading Objects in Requester Pays Buckets]: https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html\n\tRequestPayer types.RequestPayer\n\n\t// Specifies the algorithm to use when encrypting the object (for example, AES256).\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerAlgorithm *string\n\n\t// Specifies the customer-provided encryption key for Amazon S3 to use in\n\t// encrypting data. This value is used to store the object and then it is\n\t// discarded; Amazon S3 does not store the encryption key. The key must be\n\t// appropriate for use with the algorithm specified in the\n\t// x-amz-server-side-encryption-customer-algorithm header . This must be the same\n\t// encryption key specified in the initiate multipart upload request.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerKey *string\n\n\t// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.\n\t// Amazon S3 uses this header for a message integrity check to ensure that the\n\t// encryption key was transmitted without error.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerKeyMD5 *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *UploadPartInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.Key = in.Key\n\n}\n\ntype UploadPartOutput struct {\n\n\t// Indicates whether the multipart upload uses an S3 Bucket Key for server-side\n\t// encryption with Key Management Service (KMS) keys (SSE-KMS).\n\tBucketKeyEnabled *bool\n\n\t// The Base64 encoded, 32-bit CRC32 checksum of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use an API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumCRC32 *string\n\n\t// The Base64 encoded, 32-bit CRC32C checksum of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use an API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumCRC32C *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 64-bit CRC64NVME checksum of the part. For more information,\n\t// see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// The Base64 encoded, 160-bit SHA1 digest of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use the API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumSHA1 *string\n\n\t// The Base64 encoded, 256-bit SHA256 digest of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use an API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumSHA256 *string\n\n\t// Entity tag for the uploaded object.\n\tETag *string\n\n\t// If present, indicates that the requester was successfully charged for the\n\t// request. For more information, see [Using Requester Pays buckets for storage transfers and usage]in the Amazon Simple Storage Service user\n\t// guide.\n\t//\n\t// This functionality is not supported for directory buckets.\n\t//\n\t// [Using Requester Pays buckets for storage transfers and usage]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html\n\tRequestCharged types.RequestCharged\n\n\t// If server-side encryption with a customer-provided encryption key was\n\t// requested, the response will include this header to confirm the encryption\n\t// algorithm that's used.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerAlgorithm *string\n\n\t// If server-side encryption with a customer-provided encryption key was\n\t// requested, the response will include this header to provide the round-trip\n\t// message integrity verification of the customer-provided encryption key.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerKeyMD5 *string\n\n\t// If present, indicates the ID of the KMS key that was used for object encryption.\n\tSSEKMSKeyId *string\n\n\t// The server-side encryption algorithm used when you store this object in Amazon\n\t// S3 or Amazon FSx.\n\t//\n\t// When accessing data stored in Amazon FSx file systems using S3 access points,\n\t// the only valid server side encryption option is aws:fsx .\n\tServerSideEncryption types.ServerSideEncryption\n\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationUploadPartMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpUploadPart{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpUploadPart{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"UploadPart\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestChecksumMetricsTracking(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpUploadPartValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opUploadPart(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = add100Continue(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addUploadPartInputChecksumMiddlewares(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addUploadPartUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.UseDynamicPayloadSigningMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *UploadPartInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opUploadPart(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"UploadPart\",\n\t}\n}\n\n// getUploadPartRequestAlgorithmMember gets the request checksum algorithm value\n// provided as input.\nfunc getUploadPartRequestAlgorithmMember(input interface{}) (string, bool) {\n\tin := input.(*UploadPartInput)\n\tif len(in.ChecksumAlgorithm) == 0 {\n\t\treturn \"\", false\n\t}\n\treturn string(in.ChecksumAlgorithm), true\n}\n\nfunc addUploadPartInputChecksumMiddlewares(stack *middleware.Stack, options Options) error {\n\treturn addInputChecksumMiddleware(stack, internalChecksum.InputMiddlewareOptions{\n\t\tGetAlgorithm:                     getUploadPartRequestAlgorithmMember,\n\t\tRequireChecksum:                  false,\n\t\tRequestChecksumCalculation:       options.RequestChecksumCalculation,\n\t\tEnableTrailingChecksum:           true,\n\t\tEnableComputeSHA256PayloadHash:   true,\n\t\tEnableDecodedContentLengthHeader: true,\n\t})\n}\n\n// getUploadPartBucketMember returns a pointer to string denoting a provided\n// bucket member valueand a boolean indicating if the input has a modeled bucket\n// name,\nfunc getUploadPartBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*UploadPartInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addUploadPartUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getUploadPartBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n\n// PresignUploadPart is used to generate a presigned HTTP Request which contains\n// presigned URL, signed headers and HTTP method used.\nfunc (c *PresignClient) PresignUploadPart(ctx context.Context, params *UploadPartInput, optFns ...func(*PresignOptions)) (*v4.PresignedHTTPRequest, error) {\n\tif params == nil {\n\t\tparams = &UploadPartInput{}\n\t}\n\toptions := c.options.copy()\n\tfor _, fn := range optFns {\n\t\tfn(&options)\n\t}\n\tclientOptFns := append(options.ClientOptions, withNopHTTPClientAPIOption)\n\n\tclientOptFns = append(options.ClientOptions, withNoDefaultChecksumAPIOption)\n\n\tresult, _, err := c.client.invokeOperation(ctx, \"UploadPart\", params, clientOptFns,\n\t\tc.client.addOperationUploadPartMiddlewares,\n\t\tpresignConverter(options).convertToPresignMiddleware,\n\t\tfunc(stack *middleware.Stack, options Options) error {\n\t\t\treturn awshttp.RemoveContentTypeHeader(stack)\n\t\t},\n\t\taddUploadPartPayloadAsUnsigned,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*v4.PresignedHTTPRequest)\n\treturn out, nil\n}\n\nfunc addUploadPartPayloadAsUnsigned(stack *middleware.Stack, options Options) error {\n\tv4.RemoveContentSHA256HeaderMiddleware(stack)\n\tv4.RemoveComputePayloadSHA256Middleware(stack)\n\treturn v4.AddUnsignedPayloadMiddleware(stack)\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_UploadPartCopy.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n\t\"time\"\n)\n\n// Uploads a part by copying data from an existing object as data source. To\n// specify the data source, you add the request header x-amz-copy-source in your\n// request. To specify a byte range, you add the request header\n// x-amz-copy-source-range in your request.\n//\n// For information about maximum and minimum part sizes and other multipart upload\n// specifications, see [Multipart upload limits]in the Amazon S3 User Guide.\n//\n// Instead of copying data from an existing object as part data, you might use the [UploadPart]\n// action to upload new data as a part of an object in your request.\n//\n// You must initiate a multipart upload before you can upload any part. In\n// response to your initiate request, Amazon S3 returns the upload ID, a unique\n// identifier that you must include in your upload part request.\n//\n// For conceptual information about multipart uploads, see [Uploading Objects Using Multipart Upload] in the Amazon S3 User\n// Guide. For information about copying objects using a single atomic action vs. a\n// multipart upload, see [Operations on Objects]in the Amazon S3 User Guide.\n//\n// Directory buckets - For directory buckets, you must make requests for this API\n// operation to the Zonal endpoint. These endpoints support virtual-hosted-style\n// requests in the format\n// https://amzn-s3-demo-bucket.s3express-zone-id.region-code.amazonaws.com/key-name\n// . Path-style requests are not supported. For more information about endpoints\n// in Availability Zones, see [Regional and Zonal endpoints for directory buckets in Availability Zones]in the Amazon S3 User Guide. For more information\n// about endpoints in Local Zones, see [Concepts for directory buckets in Local Zones]in the Amazon S3 User Guide.\n//\n// Authentication and authorization All UploadPartCopy requests must be\n// authenticated and signed by using IAM credentials (access key ID and secret\n// access key for the IAM identities). All headers with the x-amz- prefix,\n// including x-amz-copy-source , must be signed. For more information, see [REST Authentication].\n//\n// Directory buckets - You must use IAM credentials to authenticate and authorize\n// your access to the UploadPartCopy API operation, instead of using the temporary\n// security credentials through the CreateSession API operation.\n//\n// Amazon Web Services CLI or SDKs handles authentication and authorization on\n// your behalf.\n//\n// Permissions You must have READ access to the source object and WRITE access to\n// the destination bucket.\n//\n//   - General purpose bucket permissions - You must have the permissions in a\n//     policy based on the bucket types of your source bucket and destination bucket in\n//     an UploadPartCopy operation.\n//\n//   - If the source object is in a general purpose bucket, you must have the\n//     s3:GetObject permission to read the source object that is being copied.\n//\n//   - If the destination bucket is a general purpose bucket, you must have the\n//     s3:PutObject permission to write the object copy to the destination bucket.\n//\n//   - To perform a multipart upload with encryption using an Key Management\n//     Service key, the requester must have permission to the kms:Decrypt and\n//     kms:GenerateDataKey actions on the key. The requester must also have\n//     permissions for the kms:GenerateDataKey action for the CreateMultipartUpload\n//     API. Then, the requester needs permissions for the kms:Decrypt action on the\n//     UploadPart and UploadPartCopy APIs. These permissions are required because\n//     Amazon S3 must decrypt and read data from the encrypted file parts before it\n//     completes the multipart upload. For more information about KMS permissions, see [Protecting data using server-side encryption with KMS]\n//     in the Amazon S3 User Guide. For information about the permissions required to\n//     use the multipart upload API, see [Multipart upload and permissions]and [Multipart upload API and permissions]in the Amazon S3 User Guide.\n//\n//   - Directory bucket permissions - You must have permissions in a bucket policy\n//     or an IAM identity-based policy based on the source and destination bucket types\n//     in an UploadPartCopy operation.\n//\n//   - If the source object that you want to copy is in a directory bucket, you\n//     must have the s3express:CreateSession permission in the Action element of a\n//     policy to read the object. By default, the session is in the ReadWrite mode.\n//     If you want to restrict the access, you can explicitly set the\n//     s3express:SessionMode condition key to ReadOnly on the copy source bucket.\n//\n//   - If the copy destination is a directory bucket, you must have the\n//     s3express:CreateSession permission in the Action element of a policy to write\n//     the object to the destination. The s3express:SessionMode condition key cannot\n//     be set to ReadOnly on the copy destination.\n//\n// If the object is encrypted with SSE-KMS, you must also have the\n//\n//\tkms:GenerateDataKey and kms:Decrypt permissions in IAM identity-based policies\n//\tand KMS key policies for the KMS key.\n//\n// For example policies, see [Example bucket policies for S3 Express One Zone]and [Amazon Web Services Identity and Access Management (IAM) identity-based policies for S3 Express One Zone]in the Amazon S3 User Guide.\n//\n// Encryption\n//   - General purpose buckets - For information about using server-side\n//     encryption with customer-provided encryption keys with the UploadPartCopy\n//     operation, see [CopyObject]and [UploadPart].\n//\n// If you have server-side encryption with customer-provided keys (SSE-C) blocked\n//\n//\tfor your general purpose bucket, you will get an HTTP 403 Access Denied error\n//\twhen you specify the SSE-C request headers while writing new data to your\n//\tbucket. For more information, see [Blocking or unblocking SSE-C for a general purpose bucket].\n//\n//\t- Directory buckets - For directory buckets, there are only two supported\n//\toptions for server-side encryption: server-side encryption with Amazon S3\n//\tmanaged keys (SSE-S3) ( AES256 ) and server-side encryption with KMS keys\n//\t(SSE-KMS) ( aws:kms ). For more information, see [Protecting data with server-side encryption]in the Amazon S3 User Guide.\n//\n// For directory buckets, when you perform a CreateMultipartUpload operation and an\n//\n//\tUploadPartCopy operation, the request headers you provide in the\n//\tCreateMultipartUpload request must match the default encryption configuration\n//\tof the destination bucket.\n//\n// S3 Bucket Keys aren't supported, when you copy SSE-KMS encrypted objects from\n//\n//\tgeneral purpose buckets to directory buckets, from directory buckets to general\n//\tpurpose buckets, or between directory buckets, through [UploadPartCopy]. In this case, Amazon\n//\tS3 makes a call to KMS every time a copy request is made for a KMS-encrypted\n//\tobject.\n//\n// Special errors\n//\n//   - Error Code: NoSuchUpload\n//\n//   - Description: The specified multipart upload does not exist. The upload ID\n//     might be invalid, or the multipart upload might have been aborted or completed.\n//\n//   - HTTP Status Code: 404 Not Found\n//\n//   - Error Code: InvalidRequest\n//\n//   - Description: The specified copy source is not supported as a byte-range\n//     copy source.\n//\n//   - HTTP Status Code: 400 Bad Request\n//\n// HTTP Host header syntax  Directory buckets - The HTTP Host header syntax is\n// Bucket-name.s3express-zone-id.region-code.amazonaws.com .\n//\n// The following operations are related to UploadPartCopy :\n//\n// [CreateMultipartUpload]\n//\n// [UploadPart]\n//\n// [CompleteMultipartUpload]\n//\n// [AbortMultipartUpload]\n//\n// [ListParts]\n//\n// [ListMultipartUploads]\n//\n// You must URL encode any signed header values that contain spaces. For example,\n// if your header value is my file.txt , containing two spaces after my , you must\n// URL encode this value to my%20%20file.txt .\n//\n// [Uploading Objects Using Multipart Upload]: https://docs.aws.amazon.com/AmazonS3/latest/dev/uploadobjusingmpu.html\n// [Concepts for directory buckets in Local Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-lzs-for-directory-buckets.html\n// [ListParts]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html\n// [UploadPart]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html\n// [Protecting data using server-side encryption with KMS]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html\n// [CopyObject]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CopyObject.html\n// [Multipart upload and permissions]: https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuAndPermissions.html\n// [Multipart upload API and permissions]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html#mpuAndPermissions\n// [CompleteMultipartUpload]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html\n// [CreateMultipartUpload]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html\n// [Multipart upload limits]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\n// [Amazon Web Services Identity and Access Management (IAM) identity-based policies for S3 Express One Zone]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-security-iam-identity-policies.html\n// [AbortMultipartUpload]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html\n// [REST Authentication]: https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html\n// [Example bucket policies for S3 Express One Zone]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-security-iam-example-bucket-policies.html\n// [Operations on Objects]: https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectOperations.html\n// [ListMultipartUploads]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html\n// [Regional and Zonal endpoints for directory buckets in Availability Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/endpoint-directory-buckets-AZ.html\n//\n// [Blocking or unblocking SSE-C for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/blocking-unblocking-s3-c-encryption-gpb.html\n// [UploadPartCopy]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html\n// [Protecting data with server-side encryption]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-serv-side-encryption.html\nfunc (c *Client) UploadPartCopy(ctx context.Context, params *UploadPartCopyInput, optFns ...func(*Options)) (*UploadPartCopyOutput, error) {\n\tif params == nil {\n\t\tparams = &UploadPartCopyInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"UploadPartCopy\", params, optFns, c.addOperationUploadPartCopyMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*UploadPartCopyOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype UploadPartCopyInput struct {\n\n\t// The bucket name.\n\t//\n\t// Directory buckets - When you use this operation with a directory bucket, you\n\t// must use virtual-hosted-style requests in the format\n\t// Bucket-name.s3express-zone-id.region-code.amazonaws.com . Path-style requests\n\t// are not supported. Directory bucket names must be unique in the chosen Zone\n\t// (Availability Zone or Local Zone). Bucket names must follow the format\n\t// bucket-base-name--zone-id--x-s3 (for example,\n\t// amzn-s3-demo-bucket--usw2-az1--x-s3 ). For information about bucket naming\n\t// restrictions, see [Directory bucket naming rules]in the Amazon S3 User Guide.\n\t//\n\t// Copying objects across different Amazon Web Services Regions isn't supported\n\t// when the source or destination bucket is in Amazon Web Services Local Zones. The\n\t// source and destination buckets must have the same parent Amazon Web Services\n\t// Region. Otherwise, you get an HTTP 400 Bad Request error with the error code\n\t// InvalidRequest .\n\t//\n\t// Access points - When you use this action with an access point for general\n\t// purpose buckets, you must provide the alias of the access point in place of the\n\t// bucket name or specify the access point ARN. When you use this action with an\n\t// access point for directory buckets, you must provide the access point name in\n\t// place of the bucket name. When using the access point ARN, you must direct\n\t// requests to the access point hostname. The access point hostname takes the form\n\t// AccessPointName-AccountId.s3-accesspoint.Region.amazonaws.com. When using this\n\t// action with an access point through the Amazon Web Services SDKs, you provide\n\t// the access point ARN in place of the bucket name. For more information about\n\t// access point ARNs, see [Using access points]in the Amazon S3 User Guide.\n\t//\n\t// Object Lambda access points are not supported by directory buckets.\n\t//\n\t// S3 on Outposts - When you use this action with S3 on Outposts, you must direct\n\t// requests to the S3 on Outposts hostname. The S3 on Outposts hostname takes the\n\t// form AccessPointName-AccountId.outpostID.s3-outposts.Region.amazonaws.com . When\n\t// you use this action with S3 on Outposts, the destination bucket must be the\n\t// Outposts access point ARN or the access point alias. For more information about\n\t// S3 on Outposts, see [What is S3 on Outposts?]in the Amazon S3 User Guide.\n\t//\n\t// [Directory bucket naming rules]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-bucket-naming-rules.html\n\t// [What is S3 on Outposts?]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/S3onOutposts.html\n\t// [Using access points]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-access-points.html\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Specifies the source object for the copy operation. You specify the value in\n\t// one of two formats, depending on whether you want to access the source object\n\t// through an [access point]:\n\t//\n\t//   - For objects not accessed through an access point, specify the name of the\n\t//   source bucket and key of the source object, separated by a slash (/). For\n\t//   example, to copy the object reports/january.pdf from the bucket\n\t//   awsexamplebucket , use awsexamplebucket/reports/january.pdf . The value must\n\t//   be URL-encoded.\n\t//\n\t//   - For objects accessed through access points, specify the Amazon Resource\n\t//   Name (ARN) of the object as accessed through the access point, in the format\n\t//   arn:aws:s3:::accesspoint//object/ . For example, to copy the object\n\t//   reports/january.pdf through access point my-access-point owned by account\n\t//   123456789012 in Region us-west-2 , use the URL encoding of\n\t//   arn:aws:s3:us-west-2:123456789012:accesspoint/my-access-point/object/reports/january.pdf\n\t//   . The value must be URL encoded.\n\t//\n\t//   - Amazon S3 supports copy operations using Access points only when the source\n\t//   and destination buckets are in the same Amazon Web Services Region.\n\t//\n\t//   - Access points are not supported by directory buckets.\n\t//\n\t// Alternatively, for objects accessed through Amazon S3 on Outposts, specify the\n\t//   ARN of the object as accessed in the format\n\t//   arn:aws:s3-outposts:::outpost//object/ . For example, to copy the object\n\t//   reports/january.pdf through outpost my-outpost owned by account 123456789012\n\t//   in Region us-west-2 , use the URL encoding of\n\t//   arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/object/reports/january.pdf\n\t//   . The value must be URL-encoded.\n\t//\n\t// If your bucket has versioning enabled, you could have multiple versions of the\n\t// same object. By default, x-amz-copy-source identifies the current version of\n\t// the source object to copy. To copy a specific version of the source object to\n\t// copy, append ?versionId= to the x-amz-copy-source request header (for example,\n\t// x-amz-copy-source:\n\t// /awsexamplebucket/reports/january.pdf?versionId=QUpfdndhfd8438MNFDN93jdnJFkdmqnh893\n\t// ).\n\t//\n\t// If the current version is a delete marker and you don't specify a versionId in\n\t// the x-amz-copy-source request header, Amazon S3 returns a 404 Not Found error,\n\t// because the object does not exist. If you specify versionId in the\n\t// x-amz-copy-source and the versionId is a delete marker, Amazon S3 returns an\n\t// HTTP 400 Bad Request error, because you are not allowed to specify a delete\n\t// marker as a version for the x-amz-copy-source .\n\t//\n\t// Directory buckets - S3 Versioning isn't enabled and supported for directory\n\t// buckets.\n\t//\n\t// [access point]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html\n\t//\n\t// This member is required.\n\tCopySource *string\n\n\t// Object key for which the multipart upload was initiated.\n\t//\n\t// This member is required.\n\tKey *string\n\n\t// Part number of part being copied. This is a positive integer between 1 and\n\t// 10,000.\n\t//\n\t// This member is required.\n\tPartNumber *int32\n\n\t// Upload ID identifying the multipart upload whose part is being copied.\n\t//\n\t// This member is required.\n\tUploadId *string\n\n\t// Copies the object if its entity tag (ETag) matches the specified tag.\n\t//\n\t// If both of the x-amz-copy-source-if-match and\n\t// x-amz-copy-source-if-unmodified-since headers are present in the request as\n\t// follows:\n\t//\n\t// x-amz-copy-source-if-match condition evaluates to true , and;\n\t//\n\t// x-amz-copy-source-if-unmodified-since condition evaluates to false ;\n\t//\n\t// Amazon S3 returns 200 OK and copies the data.\n\tCopySourceIfMatch *string\n\n\t// Copies the object if it has been modified since the specified time.\n\t//\n\t// If both of the x-amz-copy-source-if-none-match and\n\t// x-amz-copy-source-if-modified-since headers are present in the request as\n\t// follows:\n\t//\n\t// x-amz-copy-source-if-none-match condition evaluates to false , and;\n\t//\n\t// x-amz-copy-source-if-modified-since condition evaluates to true ;\n\t//\n\t// Amazon S3 returns 412 Precondition Failed response code.\n\tCopySourceIfModifiedSince *time.Time\n\n\t// Copies the object if its entity tag (ETag) is different than the specified ETag.\n\t//\n\t// If both of the x-amz-copy-source-if-none-match and\n\t// x-amz-copy-source-if-modified-since headers are present in the request as\n\t// follows:\n\t//\n\t// x-amz-copy-source-if-none-match condition evaluates to false , and;\n\t//\n\t// x-amz-copy-source-if-modified-since condition evaluates to true ;\n\t//\n\t// Amazon S3 returns 412 Precondition Failed response code.\n\tCopySourceIfNoneMatch *string\n\n\t// Copies the object if it hasn't been modified since the specified time.\n\t//\n\t// If both of the x-amz-copy-source-if-match and\n\t// x-amz-copy-source-if-unmodified-since headers are present in the request as\n\t// follows:\n\t//\n\t// x-amz-copy-source-if-match condition evaluates to true , and;\n\t//\n\t// x-amz-copy-source-if-unmodified-since condition evaluates to false ;\n\t//\n\t// Amazon S3 returns 200 OK and copies the data.\n\tCopySourceIfUnmodifiedSince *time.Time\n\n\t// The range of bytes to copy from the source object. The range value must use the\n\t// form bytes=first-last, where the first and last are the zero-based byte offsets\n\t// to copy. For example, bytes=0-9 indicates that you want to copy the first 10\n\t// bytes of the source. You can copy a range only if the source object is greater\n\t// than 5 MB.\n\tCopySourceRange *string\n\n\t// Specifies the algorithm to use when decrypting the source object (for example,\n\t// AES256 ).\n\t//\n\t// This functionality is not supported when the source object is in a directory\n\t// bucket.\n\tCopySourceSSECustomerAlgorithm *string\n\n\t// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt\n\t// the source object. The encryption key provided in this header must be one that\n\t// was used when the source object was created.\n\t//\n\t// This functionality is not supported when the source object is in a directory\n\t// bucket.\n\tCopySourceSSECustomerKey *string\n\n\t// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.\n\t// Amazon S3 uses this header for a message integrity check to ensure that the\n\t// encryption key was transmitted without error.\n\t//\n\t// This functionality is not supported when the source object is in a directory\n\t// bucket.\n\tCopySourceSSECustomerKeyMD5 *string\n\n\t// The account ID of the expected destination bucket owner. If the account ID that\n\t// you provide does not match the actual owner of the destination bucket, the\n\t// request fails with the HTTP status code 403 Forbidden (access denied).\n\tExpectedBucketOwner *string\n\n\t// The account ID of the expected source bucket owner. If the account ID that you\n\t// provide does not match the actual owner of the source bucket, the request fails\n\t// with the HTTP status code 403 Forbidden (access denied).\n\tExpectedSourceBucketOwner *string\n\n\t// Confirms that the requester knows that they will be charged for the request.\n\t// Bucket owners need not specify this parameter in their requests. If either the\n\t// source or destination S3 bucket has Requester Pays enabled, the requester will\n\t// pay for corresponding charges to copy the object. For information about\n\t// downloading objects from Requester Pays buckets, see [Downloading Objects in Requester Pays Buckets]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// This functionality is not supported for directory buckets.\n\t//\n\t// [Downloading Objects in Requester Pays Buckets]: https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html\n\tRequestPayer types.RequestPayer\n\n\t// Specifies the algorithm to use when encrypting the object (for example, AES256).\n\t//\n\t// This functionality is not supported when the destination bucket is a directory\n\t// bucket.\n\tSSECustomerAlgorithm *string\n\n\t// Specifies the customer-provided encryption key for Amazon S3 to use in\n\t// encrypting data. This value is used to store the object and then it is\n\t// discarded; Amazon S3 does not store the encryption key. The key must be\n\t// appropriate for use with the algorithm specified in the\n\t// x-amz-server-side-encryption-customer-algorithm header. This must be the same\n\t// encryption key specified in the initiate multipart upload request.\n\t//\n\t// This functionality is not supported when the destination bucket is a directory\n\t// bucket.\n\tSSECustomerKey *string\n\n\t// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.\n\t// Amazon S3 uses this header for a message integrity check to ensure that the\n\t// encryption key was transmitted without error.\n\t//\n\t// This functionality is not supported when the destination bucket is a directory\n\t// bucket.\n\tSSECustomerKeyMD5 *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *UploadPartCopyInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\tp.DisableS3ExpressSessionAuth = ptr.Bool(true)\n}\n\ntype UploadPartCopyOutput struct {\n\n\t// Indicates whether the multipart upload uses an S3 Bucket Key for server-side\n\t// encryption with Key Management Service (KMS) keys (SSE-KMS).\n\tBucketKeyEnabled *bool\n\n\t// Container for all response elements.\n\tCopyPartResult *types.CopyPartResult\n\n\t// The version of the source object that was copied, if you have enabled\n\t// versioning on the source bucket.\n\t//\n\t// This functionality is not supported when the source object is in a directory\n\t// bucket.\n\tCopySourceVersionId *string\n\n\t// If present, indicates that the requester was successfully charged for the\n\t// request. For more information, see [Using Requester Pays buckets for storage transfers and usage]in the Amazon Simple Storage Service user\n\t// guide.\n\t//\n\t// This functionality is not supported for directory buckets.\n\t//\n\t// [Using Requester Pays buckets for storage transfers and usage]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html\n\tRequestCharged types.RequestCharged\n\n\t// If server-side encryption with a customer-provided encryption key was\n\t// requested, the response will include this header to confirm the encryption\n\t// algorithm that's used.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerAlgorithm *string\n\n\t// If server-side encryption with a customer-provided encryption key was\n\t// requested, the response will include this header to provide the round-trip\n\t// message integrity verification of the customer-provided encryption key.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tSSECustomerKeyMD5 *string\n\n\t// If present, indicates the ID of the KMS key that was used for object encryption.\n\tSSEKMSKeyId *string\n\n\t// The server-side encryption algorithm used when you store this object in Amazon\n\t// S3 or Amazon FSx.\n\t//\n\t// When accessing data stored in Amazon FSx file systems using S3 access points,\n\t// the only valid server side encryption option is aws:fsx .\n\tServerSideEncryption types.ServerSideEncryption\n\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationUploadPartCopyMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpUploadPartCopy{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpUploadPartCopy{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"UploadPartCopy\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpUploadPartCopyValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opUploadPartCopy(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addUploadPartCopyUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = s3cust.HandleResponseErrorWith200Status(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *UploadPartCopyInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opUploadPartCopy(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"UploadPartCopy\",\n\t}\n}\n\n// getUploadPartCopyBucketMember returns a pointer to string denoting a provided\n// bucket member valueand a boolean indicating if the input has a modeled bucket\n// name,\nfunc getUploadPartCopyBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*UploadPartCopyInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addUploadPartCopyUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getUploadPartCopyBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/deserializers.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream/eventstreamapi\"\n\tawsxml \"github.com/aws/aws-sdk-go-v2/aws/protocol/xml\"\n\t\"github.com/aws/aws-sdk-go-v2/service/internal/s3shared\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\tsmithy \"github.com/aws/smithy-go\"\n\tsmithyxml \"github.com/aws/smithy-go/encoding/xml\"\n\tsmithyio \"github.com/aws/smithy-go/io\"\n\t\"github.com/aws/smithy-go/middleware\"\n\t\"github.com/aws/smithy-go/ptr\"\n\tsmithytime \"github.com/aws/smithy-go/time\"\n\t\"github.com/aws/smithy-go/tracing\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc deserializeS3Expires(v string) (*time.Time, error) {\n\tt, err := smithytime.ParseHTTPDate(v)\n\tif err != nil {\n\t\treturn nil, nil\n\t}\n\treturn &t, nil\n}\n\ntype awsRestxml_deserializeOpAbortMultipartUpload struct {\n}\n\nfunc (*awsRestxml_deserializeOpAbortMultipartUpload) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpAbortMultipartUpload) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorAbortMultipartUpload(response, &metadata)\n\t}\n\toutput := &AbortMultipartUploadOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsAbortMultipartUploadOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorAbortMultipartUpload(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchUpload\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchUpload(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsAbortMultipartUploadOutput(v *AbortMultipartUploadOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpCompleteMultipartUpload struct {\n}\n\nfunc (*awsRestxml_deserializeOpCompleteMultipartUpload) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCompleteMultipartUpload) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCompleteMultipartUpload(response, &metadata)\n\t}\n\toutput := &CompleteMultipartUploadOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsCompleteMultipartUploadOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentCompleteMultipartUploadOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCompleteMultipartUpload(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsCompleteMultipartUploadOutput(v *CompleteMultipartUploadOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-expiration\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Expiration = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentCompleteMultipartUploadOutput(v **CompleteMultipartUploadOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *CompleteMultipartUploadOutput\n\tif *v == nil {\n\t\tsv = &CompleteMultipartUploadOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32C\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32C = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC64NVME\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC64NVME = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA1\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA1 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA256\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA256 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Location\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Location = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpCopyObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpCopyObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCopyObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCopyObject(response, &metadata)\n\t}\n\toutput := &CopyObjectOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsCopyObjectOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentCopyObjectResult(&output.CopyObjectResult, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCopyObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"ObjectNotInActiveTierError\", errorCode):\n\t\treturn awsRestxml_deserializeErrorObjectNotInActiveTierError(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsCopyObjectOutput(v *CopyObjectOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-copy-source-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.CopySourceVersionId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-expiration\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Expiration = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-context\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSEncryptionContext = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentCopyObjectOutput(v **CopyObjectOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *CopyObjectOutput\n\tif *v == nil {\n\t\tsv = &CopyObjectOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"CopyObjectResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCopyObjectResult(&sv.CopyObjectResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpCreateBucket struct {\n}\n\nfunc (*awsRestxml_deserializeOpCreateBucket) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCreateBucket) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCreateBucket(response, &metadata)\n\t}\n\toutput := &CreateBucketOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsCreateBucketOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCreateBucket(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"BucketAlreadyExists\", errorCode):\n\t\treturn awsRestxml_deserializeErrorBucketAlreadyExists(response, errorBody)\n\n\tcase strings.EqualFold(\"BucketAlreadyOwnedByYou\", errorCode):\n\t\treturn awsRestxml_deserializeErrorBucketAlreadyOwnedByYou(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsCreateBucketOutput(v *CreateBucketOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-bucket-arn\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.BucketArn = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Location\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Location = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpCreateBucketMetadataConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpCreateBucketMetadataConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCreateBucketMetadataConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCreateBucketMetadataConfiguration(response, &metadata)\n\t}\n\toutput := &CreateBucketMetadataConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCreateBucketMetadataConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpCreateBucketMetadataTableConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpCreateBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCreateBucketMetadataTableConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCreateBucketMetadataTableConfiguration(response, &metadata)\n\t}\n\toutput := &CreateBucketMetadataTableConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCreateBucketMetadataTableConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpCreateMultipartUpload struct {\n}\n\nfunc (*awsRestxml_deserializeOpCreateMultipartUpload) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCreateMultipartUpload) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCreateMultipartUpload(response, &metadata)\n\t}\n\toutput := &CreateMultipartUploadOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsCreateMultipartUploadOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentCreateMultipartUploadOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCreateMultipartUpload(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsCreateMultipartUploadOutput(v *CreateMultipartUploadOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-abort-date\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseHTTPDate(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.AbortDate = ptr.Time(t)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-abort-rule-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.AbortRuleId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumAlgorithm = types.ChecksumAlgorithm(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumType = types.ChecksumType(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-context\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSEncryptionContext = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentCreateMultipartUploadOutput(v **CreateMultipartUploadOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *CreateMultipartUploadOutput\n\tif *v == nil {\n\t\tsv = &CreateMultipartUploadOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"UploadId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.UploadId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpCreateSession struct {\n}\n\nfunc (*awsRestxml_deserializeOpCreateSession) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpCreateSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorCreateSession(response, &metadata)\n\t}\n\toutput := &CreateSessionOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsCreateSessionOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentCreateSessionOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorCreateSession(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchBucket\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchBucket(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsCreateSessionOutput(v *CreateSessionOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-context\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSEncryptionContext = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentCreateSessionOutput(v **CreateSessionOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *CreateSessionOutput\n\tif *v == nil {\n\t\tsv = &CreateSessionOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Credentials\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentSessionCredentials(&sv.Credentials, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpDeleteBucket struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucket) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucket) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucket(response, &metadata)\n\t}\n\toutput := &DeleteBucketOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucket(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketAnalyticsConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketAnalyticsConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketAnalyticsConfiguration(response, &metadata)\n\t}\n\toutput := &DeleteBucketAnalyticsConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketAnalyticsConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketCors struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketCors) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketCors) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketCors(response, &metadata)\n\t}\n\toutput := &DeleteBucketCorsOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketCors(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketEncryption struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketEncryption) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketEncryption) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketEncryption(response, &metadata)\n\t}\n\toutput := &DeleteBucketEncryptionOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketEncryption(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketIntelligentTieringConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketIntelligentTieringConfiguration(response, &metadata)\n\t}\n\toutput := &DeleteBucketIntelligentTieringConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketIntelligentTieringConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketInventoryConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketInventoryConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketInventoryConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketInventoryConfiguration(response, &metadata)\n\t}\n\toutput := &DeleteBucketInventoryConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketInventoryConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketLifecycle struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketLifecycle) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketLifecycle) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketLifecycle(response, &metadata)\n\t}\n\toutput := &DeleteBucketLifecycleOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketLifecycle(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketMetadataConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketMetadataConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketMetadataConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketMetadataConfiguration(response, &metadata)\n\t}\n\toutput := &DeleteBucketMetadataConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketMetadataConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketMetadataTableConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketMetadataTableConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketMetadataTableConfiguration(response, &metadata)\n\t}\n\toutput := &DeleteBucketMetadataTableConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketMetadataTableConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketMetricsConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketMetricsConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketMetricsConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketMetricsConfiguration(response, &metadata)\n\t}\n\toutput := &DeleteBucketMetricsConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketMetricsConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketOwnershipControls struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketOwnershipControls) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketOwnershipControls) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketOwnershipControls(response, &metadata)\n\t}\n\toutput := &DeleteBucketOwnershipControlsOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketOwnershipControls(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketPolicy struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketPolicy) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketPolicy(response, &metadata)\n\t}\n\toutput := &DeleteBucketPolicyOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketPolicy(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketReplication struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketReplication) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketReplication) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketReplication(response, &metadata)\n\t}\n\toutput := &DeleteBucketReplicationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketReplication(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketTagging struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketTagging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketTagging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketTagging(response, &metadata)\n\t}\n\toutput := &DeleteBucketTaggingOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketTagging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteBucketWebsite struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteBucketWebsite) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteBucketWebsite) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteBucketWebsite(response, &metadata)\n\t}\n\toutput := &DeleteBucketWebsiteOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteBucketWebsite(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpDeleteObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteObject(response, &metadata)\n\t}\n\toutput := &DeleteObjectOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsDeleteObjectOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsDeleteObjectOutput(v *DeleteObjectOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-delete-marker\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.DeleteMarker = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpDeleteObjects struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteObjects) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteObjects) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteObjects(response, &metadata)\n\t}\n\toutput := &DeleteObjectsOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsDeleteObjectsOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentDeleteObjectsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteObjects(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsDeleteObjectsOutput(v *DeleteObjectsOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentDeleteObjectsOutput(v **DeleteObjectsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *DeleteObjectsOutput\n\tif *v == nil {\n\t\tsv = &DeleteObjectsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Deleted\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentDeletedObjectsUnwrapped(&sv.Deleted, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Error\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentErrorsUnwrapped(&sv.Errors, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpDeleteObjectTagging struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeleteObjectTagging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeleteObjectTagging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeleteObjectTagging(response, &metadata)\n\t}\n\toutput := &DeleteObjectTaggingOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsDeleteObjectTaggingOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeleteObjectTagging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsDeleteObjectTaggingOutput(v *DeleteObjectTaggingOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpDeletePublicAccessBlock struct {\n}\n\nfunc (*awsRestxml_deserializeOpDeletePublicAccessBlock) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpDeletePublicAccessBlock) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorDeletePublicAccessBlock(response, &metadata)\n\t}\n\toutput := &DeletePublicAccessBlockOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorDeletePublicAccessBlock(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpGetBucketAbac struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketAbac) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketAbac) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketAbac(response, &metadata)\n\t}\n\toutput := &GetBucketAbacOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentAbacStatus(&output.AbacStatus, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketAbac(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketAbacOutput(v **GetBucketAbacOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketAbacOutput\n\tif *v == nil {\n\t\tsv = &GetBucketAbacOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AbacStatus\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAbacStatus(&sv.AbacStatus, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketAccelerateConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketAccelerateConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketAccelerateConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketAccelerateConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketAccelerateConfigurationOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetBucketAccelerateConfigurationOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketAccelerateConfigurationOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketAccelerateConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetBucketAccelerateConfigurationOutput(v *GetBucketAccelerateConfigurationOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetBucketAccelerateConfigurationOutput(v **GetBucketAccelerateConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketAccelerateConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketAccelerateConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.BucketAccelerateStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketAcl struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketAcl) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketAcl) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketAcl(response, &metadata)\n\t}\n\toutput := &GetBucketAclOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketAclOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketAcl(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketAclOutput(v **GetBucketAclOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketAclOutput\n\tif *v == nil {\n\t\tsv = &GetBucketAclOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessControlList\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGrants(&sv.Grants, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketAnalyticsConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketAnalyticsConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketAnalyticsConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketAnalyticsConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentAnalyticsConfiguration(&output.AnalyticsConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketAnalyticsConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketAnalyticsConfigurationOutput(v **GetBucketAnalyticsConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketAnalyticsConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketAnalyticsConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AnalyticsConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsConfiguration(&sv.AnalyticsConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketCors struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketCors) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketCors) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketCors(response, &metadata)\n\t}\n\toutput := &GetBucketCorsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketCorsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketCors(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketCorsOutput(v **GetBucketCorsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketCorsOutput\n\tif *v == nil {\n\t\tsv = &GetBucketCorsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"CORSRule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCORSRulesUnwrapped(&sv.CORSRules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketEncryption struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketEncryption) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketEncryption) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketEncryption(response, &metadata)\n\t}\n\toutput := &GetBucketEncryptionOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentServerSideEncryptionConfiguration(&output.ServerSideEncryptionConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketEncryption(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketEncryptionOutput(v **GetBucketEncryptionOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketEncryptionOutput\n\tif *v == nil {\n\t\tsv = &GetBucketEncryptionOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ServerSideEncryptionConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentServerSideEncryptionConfiguration(&sv.ServerSideEncryptionConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketIntelligentTieringConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketIntelligentTieringConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketIntelligentTieringConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentIntelligentTieringConfiguration(&output.IntelligentTieringConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketIntelligentTieringConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketIntelligentTieringConfigurationOutput(v **GetBucketIntelligentTieringConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketIntelligentTieringConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketIntelligentTieringConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"IntelligentTieringConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentIntelligentTieringConfiguration(&sv.IntelligentTieringConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketInventoryConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketInventoryConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketInventoryConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketInventoryConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketInventoryConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentInventoryConfiguration(&output.InventoryConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketInventoryConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketInventoryConfigurationOutput(v **GetBucketInventoryConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketInventoryConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketInventoryConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"InventoryConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryConfiguration(&sv.InventoryConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketLifecycleConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketLifecycleConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketLifecycleConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketLifecycleConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketLifecycleConfigurationOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetBucketLifecycleConfigurationOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketLifecycleConfigurationOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketLifecycleConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetBucketLifecycleConfigurationOutput(v *GetBucketLifecycleConfigurationOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-transition-default-minimum-object-size\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.TransitionDefaultMinimumObjectSize = types.TransitionDefaultMinimumObjectSize(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetBucketLifecycleConfigurationOutput(v **GetBucketLifecycleConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketLifecycleConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketLifecycleConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Rule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentLifecycleRulesUnwrapped(&sv.Rules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketLocation struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketLocation) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketLocation) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketLocation(response, &metadata)\n\t}\n\toutput := &GetBucketLocationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketLocationOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketLocation(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketLocationOutput(v **GetBucketLocationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketLocationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketLocationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"LocationConstraint\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.LocationConstraint = types.BucketLocationConstraint(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketLogging struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketLogging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketLogging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketLogging(response, &metadata)\n\t}\n\toutput := &GetBucketLoggingOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketLoggingOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketLogging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketLoggingOutput(v **GetBucketLoggingOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketLoggingOutput\n\tif *v == nil {\n\t\tsv = &GetBucketLoggingOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"LoggingEnabled\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentLoggingEnabled(&sv.LoggingEnabled, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketMetadataConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketMetadataConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketMetadataConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketMetadataConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketMetadataConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentGetBucketMetadataConfigurationResult(&output.GetBucketMetadataConfigurationResult, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketMetadataConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketMetadataConfigurationOutput(v **GetBucketMetadataConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketMetadataConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketMetadataConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"GetBucketMetadataConfigurationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGetBucketMetadataConfigurationResult(&sv.GetBucketMetadataConfigurationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketMetadataTableConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketMetadataTableConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketMetadataTableConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketMetadataTableConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentGetBucketMetadataTableConfigurationResult(&output.GetBucketMetadataTableConfigurationResult, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketMetadataTableConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketMetadataTableConfigurationOutput(v **GetBucketMetadataTableConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketMetadataTableConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketMetadataTableConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"GetBucketMetadataTableConfigurationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGetBucketMetadataTableConfigurationResult(&sv.GetBucketMetadataTableConfigurationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketMetricsConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketMetricsConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketMetricsConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketMetricsConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketMetricsConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentMetricsConfiguration(&output.MetricsConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketMetricsConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketMetricsConfigurationOutput(v **GetBucketMetricsConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketMetricsConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketMetricsConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"MetricsConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMetricsConfiguration(&sv.MetricsConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketNotificationConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketNotificationConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketNotificationConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketNotificationConfiguration(response, &metadata)\n\t}\n\toutput := &GetBucketNotificationConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketNotificationConfigurationOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketNotificationConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketNotificationConfigurationOutput(v **GetBucketNotificationConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketNotificationConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketNotificationConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"EventBridgeConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentEventBridgeConfiguration(&sv.EventBridgeConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"CloudFunctionConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentLambdaFunctionConfigurationListUnwrapped(&sv.LambdaFunctionConfigurations, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"QueueConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentQueueConfigurationListUnwrapped(&sv.QueueConfigurations, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TopicConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTopicConfigurationListUnwrapped(&sv.TopicConfigurations, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketOwnershipControls struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketOwnershipControls) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketOwnershipControls) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketOwnershipControls(response, &metadata)\n\t}\n\toutput := &GetBucketOwnershipControlsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentOwnershipControls(&output.OwnershipControls, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketOwnershipControls(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketOwnershipControlsOutput(v **GetBucketOwnershipControlsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketOwnershipControlsOutput\n\tif *v == nil {\n\t\tsv = &GetBucketOwnershipControlsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"OwnershipControls\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwnershipControls(&sv.OwnershipControls, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketPolicy struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketPolicy) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketPolicy(response, &metadata)\n\t}\n\toutput := &GetBucketPolicyOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpDocumentGetBucketPolicyOutput(output, response.Body, response.ContentLength)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to deserialize response payload, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketPolicy(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketPolicyOutput(v *GetBucketPolicyOutput, body io.ReadCloser, contentLength int64) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization of nil %T\", v)\n\t}\n\tvar buf bytes.Buffer\n\tif contentLength > 0 {\n\t\tbuf.Grow(int(contentLength))\n\t} else {\n\t\tbuf.Grow(512)\n\t}\n\n\t_, err := buf.ReadFrom(body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif buf.Len() > 0 {\n\t\tv.Policy = ptr.String(buf.String())\n\t}\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketPolicyStatus struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketPolicyStatus) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketPolicyStatus) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketPolicyStatus(response, &metadata)\n\t}\n\toutput := &GetBucketPolicyStatusOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentPolicyStatus(&output.PolicyStatus, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketPolicyStatus(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketPolicyStatusOutput(v **GetBucketPolicyStatusOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketPolicyStatusOutput\n\tif *v == nil {\n\t\tsv = &GetBucketPolicyStatusOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"PolicyStatus\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentPolicyStatus(&sv.PolicyStatus, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketReplication struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketReplication) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketReplication) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketReplication(response, &metadata)\n\t}\n\toutput := &GetBucketReplicationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentReplicationConfiguration(&output.ReplicationConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketReplication(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketReplicationOutput(v **GetBucketReplicationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketReplicationOutput\n\tif *v == nil {\n\t\tsv = &GetBucketReplicationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ReplicationConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationConfiguration(&sv.ReplicationConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketRequestPayment struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketRequestPayment) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketRequestPayment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketRequestPayment(response, &metadata)\n\t}\n\toutput := &GetBucketRequestPaymentOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketRequestPaymentOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketRequestPayment(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketRequestPaymentOutput(v **GetBucketRequestPaymentOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketRequestPaymentOutput\n\tif *v == nil {\n\t\tsv = &GetBucketRequestPaymentOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Payer\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Payer = types.Payer(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketTagging struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketTagging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketTagging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketTagging(response, &metadata)\n\t}\n\toutput := &GetBucketTaggingOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketTaggingOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketTagging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketTaggingOutput(v **GetBucketTaggingOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketTaggingOutput\n\tif *v == nil {\n\t\tsv = &GetBucketTaggingOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"TagSet\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSet(&sv.TagSet, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketVersioning struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketVersioning) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketVersioning) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketVersioning(response, &metadata)\n\t}\n\toutput := &GetBucketVersioningOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketVersioningOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketVersioning(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketVersioningOutput(v **GetBucketVersioningOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketVersioningOutput\n\tif *v == nil {\n\t\tsv = &GetBucketVersioningOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"MfaDelete\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.MFADelete = types.MFADeleteStatus(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.BucketVersioningStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetBucketWebsite struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetBucketWebsite) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetBucketWebsite) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetBucketWebsite(response, &metadata)\n\t}\n\toutput := &GetBucketWebsiteOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetBucketWebsiteOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetBucketWebsite(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetBucketWebsiteOutput(v **GetBucketWebsiteOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetBucketWebsiteOutput\n\tif *v == nil {\n\t\tsv = &GetBucketWebsiteOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ErrorDocument\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentErrorDocument(&sv.ErrorDocument, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IndexDocument\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentIndexDocument(&sv.IndexDocument, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RedirectAllRequestsTo\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentRedirectAllRequestsTo(&sv.RedirectAllRequestsTo, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RoutingRules\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentRoutingRules(&sv.RoutingRules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObject(response, &metadata)\n\t}\n\toutput := &GetObjectOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetObjectOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\terr = awsRestxml_deserializeOpDocumentGetObjectOutput(output, response.Body)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to deserialize response payload, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"InvalidObjectState\", errorCode):\n\t\treturn awsRestxml_deserializeErrorInvalidObjectState(response, errorBody)\n\n\tcase strings.EqualFold(\"NoSuchKey\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchKey(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetObjectOutput(v *GetObjectOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"accept-ranges\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.AcceptRanges = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"Cache-Control\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.CacheControl = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32c\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32C = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc64nvme\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC64NVME = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha1\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA1 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha256\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA256 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumType = types.ChecksumType(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Disposition\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentDisposition = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Encoding\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentEncoding = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Language\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentLanguage = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Length\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.ContentLength = ptr.Int64(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Range\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentRange = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentType = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-delete-marker\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.DeleteMarker = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"ETag\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ETag = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-expiration\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Expiration = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Expires\"); len(headerValues) != 0 {\n\t\tdeserOverride, err := deserializeS3Expires(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.Expires = deserOverride\n\n\t}\n\n\tif headerValues := response.Header.Values(\"Expires\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ExpiresString = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Last-Modified\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseHTTPDate(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.LastModified = ptr.Time(t)\n\t}\n\n\tfor headerKey, headerValues := range response.Header {\n\t\tif lenPrefix := len(\"x-amz-meta-\"); len(headerKey) >= lenPrefix && strings.EqualFold(headerKey[:lenPrefix], \"x-amz-meta-\") {\n\t\t\tif v.Metadata == nil {\n\t\t\t\tv.Metadata = map[string]string{}\n\t\t\t}\n\t\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\t\tv.Metadata[strings.ToLower(headerKey[lenPrefix:])] = headerValues[0]\n\t\t}\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-missing-meta\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.MissingMeta = ptr.Int32(int32(vv))\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-lock-legal-hold\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ObjectLockLegalHoldStatus = types.ObjectLockLegalHoldStatus(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-lock-mode\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ObjectLockMode = types.ObjectLockMode(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-lock-retain-until-date\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseDateTime(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.ObjectLockRetainUntilDate = ptr.Time(t)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-mp-parts-count\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.PartsCount = ptr.Int32(int32(vv))\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-replication-status\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ReplicationStatus = types.ReplicationStatus(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-restore\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Restore = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-storage-class\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.StorageClass = types.StorageClass(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-tagging-count\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.TagCount = ptr.Int32(int32(vv))\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-website-redirect-location\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.WebsiteRedirectLocation = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetObjectOutput(v *GetObjectOutput, body io.ReadCloser) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization of nil %T\", v)\n\t}\n\tv.Body = body\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectAcl struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectAcl) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectAcl) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectAcl(response, &metadata)\n\t}\n\toutput := &GetObjectAclOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetObjectAclOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetObjectAclOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectAcl(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchKey\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchKey(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetObjectAclOutput(v *GetObjectAclOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetObjectAclOutput(v **GetObjectAclOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetObjectAclOutput\n\tif *v == nil {\n\t\tsv = &GetObjectAclOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessControlList\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGrants(&sv.Grants, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectAttributes struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectAttributes) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectAttributes(response, &metadata)\n\t}\n\toutput := &GetObjectAttributesOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetObjectAttributesOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetObjectAttributesOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectAttributes(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchKey\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchKey(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetObjectAttributesOutput(v *GetObjectAttributesOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-delete-marker\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.DeleteMarker = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"Last-Modified\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseHTTPDate(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.LastModified = ptr.Time(t)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetObjectAttributesOutput(v **GetObjectAttributesOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetObjectAttributesOutput\n\tif *v == nil {\n\t\tsv = &GetObjectAttributesOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Checksum\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentChecksum(&sv.Checksum, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ObjectParts\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGetObjectAttributesParts(&sv.ObjectParts, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ObjectSize\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.ObjectSize = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.StorageClass(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectLegalHold struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectLegalHold) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectLegalHold) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectLegalHold(response, &metadata)\n\t}\n\toutput := &GetObjectLegalHoldOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentObjectLockLegalHold(&output.LegalHold, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectLegalHold(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetObjectLegalHoldOutput(v **GetObjectLegalHoldOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetObjectLegalHoldOutput\n\tif *v == nil {\n\t\tsv = &GetObjectLegalHoldOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"LegalHold\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectLockLegalHold(&sv.LegalHold, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectLockConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectLockConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectLockConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectLockConfiguration(response, &metadata)\n\t}\n\toutput := &GetObjectLockConfigurationOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentObjectLockConfiguration(&output.ObjectLockConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectLockConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetObjectLockConfigurationOutput(v **GetObjectLockConfigurationOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetObjectLockConfigurationOutput\n\tif *v == nil {\n\t\tsv = &GetObjectLockConfigurationOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ObjectLockConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectLockConfiguration(&sv.ObjectLockConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectRetention struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectRetention) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectRetention) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectRetention(response, &metadata)\n\t}\n\toutput := &GetObjectRetentionOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentObjectLockRetention(&output.Retention, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectRetention(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetObjectRetentionOutput(v **GetObjectRetentionOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetObjectRetentionOutput\n\tif *v == nil {\n\t\tsv = &GetObjectRetentionOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Retention\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectLockRetention(&sv.Retention, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectTagging struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectTagging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectTagging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectTagging(response, &metadata)\n\t}\n\toutput := &GetObjectTaggingOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetObjectTaggingOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentGetObjectTaggingOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectTagging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetObjectTaggingOutput(v *GetObjectTaggingOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetObjectTaggingOutput(v **GetObjectTaggingOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetObjectTaggingOutput\n\tif *v == nil {\n\t\tsv = &GetObjectTaggingOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"TagSet\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSet(&sv.TagSet, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetObjectTorrent struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetObjectTorrent) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetObjectTorrent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetObjectTorrent(response, &metadata)\n\t}\n\toutput := &GetObjectTorrentOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsGetObjectTorrentOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\terr = awsRestxml_deserializeOpDocumentGetObjectTorrentOutput(output, response.Body)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to deserialize response payload, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetObjectTorrent(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsGetObjectTorrentOutput(v *GetObjectTorrentOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentGetObjectTorrentOutput(v *GetObjectTorrentOutput, body io.ReadCloser) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization of nil %T\", v)\n\t}\n\tv.Body = body\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpGetPublicAccessBlock struct {\n}\n\nfunc (*awsRestxml_deserializeOpGetPublicAccessBlock) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpGetPublicAccessBlock) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorGetPublicAccessBlock(response, &metadata)\n\t}\n\toutput := &GetPublicAccessBlockOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentPublicAccessBlockConfiguration(&output.PublicAccessBlockConfiguration, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorGetPublicAccessBlock(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentGetPublicAccessBlockOutput(v **GetPublicAccessBlockOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *GetPublicAccessBlockOutput\n\tif *v == nil {\n\t\tsv = &GetPublicAccessBlockOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"PublicAccessBlockConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentPublicAccessBlockConfiguration(&sv.PublicAccessBlockConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpHeadBucket struct {\n}\n\nfunc (*awsRestxml_deserializeOpHeadBucket) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpHeadBucket) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorHeadBucket(response, &metadata)\n\t}\n\toutput := &HeadBucketOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsHeadBucketOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorHeadBucket(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NotFound\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNotFound(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsHeadBucketOutput(v *HeadBucketOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-access-point-alias\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.AccessPointAlias = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-bucket-arn\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.BucketArn = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-bucket-location-name\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.BucketLocationName = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-bucket-location-type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.BucketLocationType = types.LocationType(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-bucket-region\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.BucketRegion = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpHeadObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpHeadObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpHeadObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorHeadObject(response, &metadata)\n\t}\n\toutput := &HeadObjectOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsHeadObjectOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorHeadObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NotFound\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNotFound(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsHeadObjectOutput(v *HeadObjectOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"accept-ranges\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.AcceptRanges = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-archive-status\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ArchiveStatus = types.ArchiveStatus(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"Cache-Control\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.CacheControl = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32c\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32C = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc64nvme\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC64NVME = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha1\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA1 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha256\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA256 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumType = types.ChecksumType(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Disposition\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentDisposition = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Encoding\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentEncoding = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Language\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentLanguage = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Length\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.ContentLength = ptr.Int64(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Range\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentRange = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Content-Type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ContentType = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-delete-marker\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.DeleteMarker = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"ETag\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ETag = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-expiration\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Expiration = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Expires\"); len(headerValues) != 0 {\n\t\tdeserOverride, err := deserializeS3Expires(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.Expires = deserOverride\n\n\t}\n\n\tif headerValues := response.Header.Values(\"Expires\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ExpiresString = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"Last-Modified\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseHTTPDate(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.LastModified = ptr.Time(t)\n\t}\n\n\tfor headerKey, headerValues := range response.Header {\n\t\tif lenPrefix := len(\"x-amz-meta-\"); len(headerKey) >= lenPrefix && strings.EqualFold(headerKey[:lenPrefix], \"x-amz-meta-\") {\n\t\t\tif v.Metadata == nil {\n\t\t\t\tv.Metadata = map[string]string{}\n\t\t\t}\n\t\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\t\tv.Metadata[strings.ToLower(headerKey[lenPrefix:])] = headerValues[0]\n\t\t}\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-missing-meta\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.MissingMeta = ptr.Int32(int32(vv))\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-lock-legal-hold\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ObjectLockLegalHoldStatus = types.ObjectLockLegalHoldStatus(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-lock-mode\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ObjectLockMode = types.ObjectLockMode(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-lock-retain-until-date\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseDateTime(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.ObjectLockRetainUntilDate = ptr.Time(t)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-mp-parts-count\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.PartsCount = ptr.Int32(int32(vv))\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-replication-status\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ReplicationStatus = types.ReplicationStatus(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-restore\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Restore = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-storage-class\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.StorageClass = types.StorageClass(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-tagging-count\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 32)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.TagCount = ptr.Int32(int32(vv))\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-website-redirect-location\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.WebsiteRedirectLocation = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListBucketAnalyticsConfigurations struct {\n}\n\nfunc (*awsRestxml_deserializeOpListBucketAnalyticsConfigurations) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListBucketAnalyticsConfigurations) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListBucketAnalyticsConfigurations(response, &metadata)\n\t}\n\toutput := &ListBucketAnalyticsConfigurationsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListBucketAnalyticsConfigurationsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListBucketAnalyticsConfigurations(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentListBucketAnalyticsConfigurationsOutput(v **ListBucketAnalyticsConfigurationsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListBucketAnalyticsConfigurationsOutput\n\tif *v == nil {\n\t\tsv = &ListBucketAnalyticsConfigurationsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AnalyticsConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsConfigurationListUnwrapped(&sv.AnalyticsConfigurationList, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListBucketIntelligentTieringConfigurations struct {\n}\n\nfunc (*awsRestxml_deserializeOpListBucketIntelligentTieringConfigurations) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListBucketIntelligentTieringConfigurations) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListBucketIntelligentTieringConfigurations(response, &metadata)\n\t}\n\toutput := &ListBucketIntelligentTieringConfigurationsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListBucketIntelligentTieringConfigurationsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListBucketIntelligentTieringConfigurations(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentListBucketIntelligentTieringConfigurationsOutput(v **ListBucketIntelligentTieringConfigurationsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListBucketIntelligentTieringConfigurationsOutput\n\tif *v == nil {\n\t\tsv = &ListBucketIntelligentTieringConfigurationsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IntelligentTieringConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentIntelligentTieringConfigurationListUnwrapped(&sv.IntelligentTieringConfigurationList, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListBucketInventoryConfigurations struct {\n}\n\nfunc (*awsRestxml_deserializeOpListBucketInventoryConfigurations) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListBucketInventoryConfigurations) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListBucketInventoryConfigurations(response, &metadata)\n\t}\n\toutput := &ListBucketInventoryConfigurationsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListBucketInventoryConfigurationsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListBucketInventoryConfigurations(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentListBucketInventoryConfigurationsOutput(v **ListBucketInventoryConfigurationsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListBucketInventoryConfigurationsOutput\n\tif *v == nil {\n\t\tsv = &ListBucketInventoryConfigurationsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"InventoryConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryConfigurationListUnwrapped(&sv.InventoryConfigurationList, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListBucketMetricsConfigurations struct {\n}\n\nfunc (*awsRestxml_deserializeOpListBucketMetricsConfigurations) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListBucketMetricsConfigurations) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListBucketMetricsConfigurations(response, &metadata)\n\t}\n\toutput := &ListBucketMetricsConfigurationsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListBucketMetricsConfigurationsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListBucketMetricsConfigurations(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentListBucketMetricsConfigurationsOutput(v **ListBucketMetricsConfigurationsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListBucketMetricsConfigurationsOutput\n\tif *v == nil {\n\t\tsv = &ListBucketMetricsConfigurationsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MetricsConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMetricsConfigurationListUnwrapped(&sv.MetricsConfigurationList, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListBuckets struct {\n}\n\nfunc (*awsRestxml_deserializeOpListBuckets) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListBuckets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListBuckets(response, &metadata)\n\t}\n\toutput := &ListBucketsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListBucketsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListBuckets(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentListBucketsOutput(v **ListBucketsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListBucketsOutput\n\tif *v == nil {\n\t\tsv = &ListBucketsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Buckets\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentBuckets(&sv.Buckets, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListDirectoryBuckets struct {\n}\n\nfunc (*awsRestxml_deserializeOpListDirectoryBuckets) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListDirectoryBuckets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListDirectoryBuckets(response, &metadata)\n\t}\n\toutput := &ListDirectoryBucketsOutput{}\n\tout.Result = output\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListDirectoryBucketsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListDirectoryBuckets(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpDocumentListDirectoryBucketsOutput(v **ListDirectoryBucketsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListDirectoryBucketsOutput\n\tif *v == nil {\n\t\tsv = &ListDirectoryBucketsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Buckets\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentBuckets(&sv.Buckets, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListMultipartUploads struct {\n}\n\nfunc (*awsRestxml_deserializeOpListMultipartUploads) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListMultipartUploads) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListMultipartUploads(response, &metadata)\n\t}\n\toutput := &ListMultipartUploadsOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsListMultipartUploadsOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListMultipartUploadsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListMultipartUploads(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsListMultipartUploadsOutput(v *ListMultipartUploadsOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentListMultipartUploadsOutput(v **ListMultipartUploadsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListMultipartUploadsOutput\n\tif *v == nil {\n\t\tsv = &ListMultipartUploadsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"CommonPrefixes\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCommonPrefixListUnwrapped(&sv.CommonPrefixes, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Delimiter\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Delimiter = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"EncodingType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.EncodingType = types.EncodingType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"KeyMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.KeyMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxUploads\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxUploads = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextKeyMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextKeyMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextUploadIdMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextUploadIdMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"UploadIdMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.UploadIdMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Upload\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMultipartUploadListUnwrapped(&sv.Uploads, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListObjects struct {\n}\n\nfunc (*awsRestxml_deserializeOpListObjects) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListObjects) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListObjects(response, &metadata)\n\t}\n\toutput := &ListObjectsOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsListObjectsOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListObjectsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListObjects(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchBucket\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchBucket(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsListObjectsOutput(v *ListObjectsOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentListObjectsOutput(v **ListObjectsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListObjectsOutput\n\tif *v == nil {\n\t\tsv = &ListObjectsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"CommonPrefixes\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCommonPrefixListUnwrapped(&sv.CommonPrefixes, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Contents\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectListUnwrapped(&sv.Contents, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Delimiter\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Delimiter = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"EncodingType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.EncodingType = types.EncodingType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Marker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Marker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxKeys\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxKeys = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Name\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Name = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListObjectsV2 struct {\n}\n\nfunc (*awsRestxml_deserializeOpListObjectsV2) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListObjectsV2) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListObjectsV2(response, &metadata)\n\t}\n\toutput := &ListObjectsV2Output{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsListObjectsV2Output(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListObjectsV2Output(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListObjectsV2(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchBucket\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchBucket(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsListObjectsV2Output(v *ListObjectsV2Output, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentListObjectsV2Output(v **ListObjectsV2Output, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListObjectsV2Output\n\tif *v == nil {\n\t\tsv = &ListObjectsV2Output{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"CommonPrefixes\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCommonPrefixListUnwrapped(&sv.CommonPrefixes, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Contents\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectListUnwrapped(&sv.Contents, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Delimiter\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Delimiter = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"EncodingType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.EncodingType = types.EncodingType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"KeyCount\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.KeyCount = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxKeys\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxKeys = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Name\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Name = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextContinuationToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextContinuationToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StartAfter\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StartAfter = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListObjectVersions struct {\n}\n\nfunc (*awsRestxml_deserializeOpListObjectVersions) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListObjectVersions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListObjectVersions(response, &metadata)\n\t}\n\toutput := &ListObjectVersionsOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsListObjectVersionsOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListObjectVersionsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListObjectVersions(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsListObjectVersionsOutput(v *ListObjectVersionsOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentListObjectVersionsOutput(v **ListObjectVersionsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListObjectVersionsOutput\n\tif *v == nil {\n\t\tsv = &ListObjectVersionsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"CommonPrefixes\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCommonPrefixListUnwrapped(&sv.CommonPrefixes, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"DeleteMarker\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentDeleteMarkersUnwrapped(&sv.DeleteMarkers, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Delimiter\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Delimiter = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"EncodingType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.EncodingType = types.EncodingType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"KeyMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.KeyMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxKeys\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxKeys = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Name\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Name = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextKeyMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextKeyMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextVersionIdMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextVersionIdMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"VersionIdMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.VersionIdMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Version\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectVersionListUnwrapped(&sv.Versions, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpListParts struct {\n}\n\nfunc (*awsRestxml_deserializeOpListParts) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpListParts) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorListParts(response, &metadata)\n\t}\n\toutput := &ListPartsOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsListPartsOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeOpDocumentListPartsOutput(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorListParts(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsListPartsOutput(v *ListPartsOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-abort-date\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tt, err := smithytime.ParseHTTPDate(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.AbortDate = ptr.Time(t)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-abort-rule-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.AbortRuleId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentListPartsOutput(v **ListPartsOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *ListPartsOutput\n\tif *v == nil {\n\t\tsv = &ListPartsOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumAlgorithm\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumAlgorithm = types.ChecksumAlgorithm(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Initiator\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInitiator(&sv.Initiator, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxParts\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxParts = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextPartNumberMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextPartNumberMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"PartNumberMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.PartNumberMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Part\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentPartsUnwrapped(&sv.Parts, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.StorageClass(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"UploadId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.UploadId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutBucketAbac struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketAbac) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketAbac) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketAbac(response, &metadata)\n\t}\n\toutput := &PutBucketAbacOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketAbac(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketAccelerateConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketAccelerateConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketAccelerateConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketAccelerateConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketAccelerateConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketAccelerateConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketAcl struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketAcl) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketAcl) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketAcl(response, &metadata)\n\t}\n\toutput := &PutBucketAclOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketAcl(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketAnalyticsConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketAnalyticsConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketAnalyticsConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketAnalyticsConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketAnalyticsConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketCors struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketCors) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketCors) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketCors(response, &metadata)\n\t}\n\toutput := &PutBucketCorsOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketCors(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketEncryption struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketEncryption) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketEncryption) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketEncryption(response, &metadata)\n\t}\n\toutput := &PutBucketEncryptionOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketEncryption(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketIntelligentTieringConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketIntelligentTieringConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketIntelligentTieringConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketIntelligentTieringConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketInventoryConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketInventoryConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketInventoryConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketInventoryConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketInventoryConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketInventoryConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketLifecycleConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketLifecycleConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketLifecycleConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketLifecycleConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketLifecycleConfigurationOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutBucketLifecycleConfigurationOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketLifecycleConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutBucketLifecycleConfigurationOutput(v *PutBucketLifecycleConfigurationOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-transition-default-minimum-object-size\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.TransitionDefaultMinimumObjectSize = types.TransitionDefaultMinimumObjectSize(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutBucketLogging struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketLogging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketLogging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketLogging(response, &metadata)\n\t}\n\toutput := &PutBucketLoggingOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketLogging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketMetricsConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketMetricsConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketMetricsConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketMetricsConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketMetricsConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketMetricsConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketNotificationConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketNotificationConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketNotificationConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketNotificationConfiguration(response, &metadata)\n\t}\n\toutput := &PutBucketNotificationConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketNotificationConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketOwnershipControls struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketOwnershipControls) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketOwnershipControls) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketOwnershipControls(response, &metadata)\n\t}\n\toutput := &PutBucketOwnershipControlsOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketOwnershipControls(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketPolicy struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketPolicy) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketPolicy(response, &metadata)\n\t}\n\toutput := &PutBucketPolicyOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketPolicy(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketReplication struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketReplication) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketReplication) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketReplication(response, &metadata)\n\t}\n\toutput := &PutBucketReplicationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketReplication(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketRequestPayment struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketRequestPayment) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketRequestPayment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketRequestPayment(response, &metadata)\n\t}\n\toutput := &PutBucketRequestPaymentOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketRequestPayment(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketTagging struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketTagging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketTagging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketTagging(response, &metadata)\n\t}\n\toutput := &PutBucketTaggingOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketTagging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketVersioning struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketVersioning) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketVersioning) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketVersioning(response, &metadata)\n\t}\n\toutput := &PutBucketVersioningOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketVersioning(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutBucketWebsite struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutBucketWebsite) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutBucketWebsite) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutBucketWebsite(response, &metadata)\n\t}\n\toutput := &PutBucketWebsiteOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutBucketWebsite(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpPutObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutObject(response, &metadata)\n\t}\n\toutput := &PutObjectOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutObjectOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"EncryptionTypeMismatch\", errorCode):\n\t\treturn awsRestxml_deserializeErrorEncryptionTypeMismatch(response, errorBody)\n\n\tcase strings.EqualFold(\"InvalidRequest\", errorCode):\n\t\treturn awsRestxml_deserializeErrorInvalidRequest(response, errorBody)\n\n\tcase strings.EqualFold(\"InvalidWriteOffset\", errorCode):\n\t\treturn awsRestxml_deserializeErrorInvalidWriteOffset(response, errorBody)\n\n\tcase strings.EqualFold(\"TooManyParts\", errorCode):\n\t\treturn awsRestxml_deserializeErrorTooManyParts(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutObjectOutput(v *PutObjectOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32c\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32C = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc64nvme\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC64NVME = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha1\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA1 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha256\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA256 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-type\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumType = types.ChecksumType(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"ETag\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ETag = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-expiration\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.Expiration = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-object-size\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseInt(headerValues[0], 0, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.Size = ptr.Int64(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-context\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSEncryptionContext = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutObjectAcl struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutObjectAcl) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutObjectAcl) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutObjectAcl(response, &metadata)\n\t}\n\toutput := &PutObjectAclOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutObjectAclOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutObjectAcl(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"NoSuchKey\", errorCode):\n\t\treturn awsRestxml_deserializeErrorNoSuchKey(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutObjectAclOutput(v *PutObjectAclOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutObjectLegalHold struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutObjectLegalHold) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutObjectLegalHold) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutObjectLegalHold(response, &metadata)\n\t}\n\toutput := &PutObjectLegalHoldOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutObjectLegalHoldOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutObjectLegalHold(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutObjectLegalHoldOutput(v *PutObjectLegalHoldOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutObjectLockConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutObjectLockConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutObjectLockConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutObjectLockConfiguration(response, &metadata)\n\t}\n\toutput := &PutObjectLockConfigurationOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutObjectLockConfigurationOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutObjectLockConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutObjectLockConfigurationOutput(v *PutObjectLockConfigurationOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutObjectRetention struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutObjectRetention) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutObjectRetention) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutObjectRetention(response, &metadata)\n\t}\n\toutput := &PutObjectRetentionOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutObjectRetentionOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutObjectRetention(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutObjectRetentionOutput(v *PutObjectRetentionOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutObjectTagging struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutObjectTagging) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutObjectTagging) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutObjectTagging(response, &metadata)\n\t}\n\toutput := &PutObjectTaggingOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsPutObjectTaggingOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutObjectTagging(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsPutObjectTaggingOutput(v *PutObjectTaggingOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.VersionId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpPutPublicAccessBlock struct {\n}\n\nfunc (*awsRestxml_deserializeOpPutPublicAccessBlock) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpPutPublicAccessBlock) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorPutPublicAccessBlock(response, &metadata)\n\t}\n\toutput := &PutPublicAccessBlockOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorPutPublicAccessBlock(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpRenameObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpRenameObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpRenameObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorRenameObject(response, &metadata)\n\t}\n\toutput := &RenameObjectOutput{}\n\tout.Result = output\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorRenameObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"IdempotencyParameterMismatch\", errorCode):\n\t\treturn awsRestxml_deserializeErrorIdempotencyParameterMismatch(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpRestoreObject struct {\n}\n\nfunc (*awsRestxml_deserializeOpRestoreObject) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpRestoreObject) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorRestoreObject(response, &metadata)\n\t}\n\toutput := &RestoreObjectOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsRestoreObjectOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorRestoreObject(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tcase strings.EqualFold(\"ObjectAlreadyInActiveTierError\", errorCode):\n\t\treturn awsRestxml_deserializeErrorObjectAlreadyInActiveTierError(response, errorBody)\n\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsRestoreObjectOutput(v *RestoreObjectOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-restore-output-path\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RestoreOutputPath = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpSelectObjectContent struct {\n}\n\nfunc (*awsRestxml_deserializeOpSelectObjectContent) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpSelectObjectContent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorSelectObjectContent(response, &metadata)\n\t}\n\toutput := &SelectObjectContentOutput{}\n\tout.Result = output\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorSelectObjectContent(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpUpdateBucketMetadataInventoryTableConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpUpdateBucketMetadataInventoryTableConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpUpdateBucketMetadataInventoryTableConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorUpdateBucketMetadataInventoryTableConfiguration(response, &metadata)\n\t}\n\toutput := &UpdateBucketMetadataInventoryTableConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorUpdateBucketMetadataInventoryTableConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpUpdateBucketMetadataJournalTableConfiguration struct {\n}\n\nfunc (*awsRestxml_deserializeOpUpdateBucketMetadataJournalTableConfiguration) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpUpdateBucketMetadataJournalTableConfiguration) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorUpdateBucketMetadataJournalTableConfiguration(response, &metadata)\n\t}\n\toutput := &UpdateBucketMetadataJournalTableConfigurationOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorUpdateBucketMetadataJournalTableConfiguration(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\ntype awsRestxml_deserializeOpUploadPart struct {\n}\n\nfunc (*awsRestxml_deserializeOpUploadPart) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpUploadPart) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorUploadPart(response, &metadata)\n\t}\n\toutput := &UploadPartOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsUploadPartOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorUploadPart(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsUploadPartOutput(v *UploadPartOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc32c\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC32C = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-crc64nvme\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumCRC64NVME = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha1\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA1 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-checksum-sha256\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ChecksumSHA256 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"ETag\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ETag = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpUploadPartCopy struct {\n}\n\nfunc (*awsRestxml_deserializeOpUploadPartCopy) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpUploadPartCopy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorUploadPartCopy(response, &metadata)\n\t}\n\toutput := &UploadPartCopyOutput{}\n\tout.Result = output\n\n\terr = awsRestxml_deserializeOpHttpBindingsUploadPartCopyOutput(output, response)\n\tif err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"failed to decode response with invalid Http bindings, %w\", err)}\n\t}\n\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(response.Body, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn out, metadata, nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentCopyPartResult(&output.CopyPartResult, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorUploadPartCopy(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeOpHttpBindingsUploadPartCopyOutput(v *UploadPartCopyOutput, response *smithyhttp.Response) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported deserialization for nil %T\", v)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-bucket-key-enabled\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tvv, err := strconv.ParseBool(headerValues[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv.BucketKeyEnabled = ptr.Bool(vv)\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-copy-source-version-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.CopySourceVersionId = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-request-charged\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.RequestCharged = types.RequestCharged(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.ServerSideEncryption = types.ServerSideEncryption(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-algorithm\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerAlgorithm = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-customer-key-MD5\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSECustomerKeyMD5 = ptr.String(headerValues[0])\n\t}\n\n\tif headerValues := response.Header.Values(\"x-amz-server-side-encryption-aws-kms-key-id\"); len(headerValues) != 0 {\n\t\theaderValues[0] = strings.TrimSpace(headerValues[0])\n\t\tv.SSEKMSKeyId = ptr.String(headerValues[0])\n\t}\n\n\treturn nil\n}\nfunc awsRestxml_deserializeOpDocumentUploadPartCopyOutput(v **UploadPartCopyOutput, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *UploadPartCopyOutput\n\tif *v == nil {\n\t\tsv = &UploadPartCopyOutput{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"CopyPartResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCopyPartResult(&sv.CopyPartResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\ntype awsRestxml_deserializeOpWriteGetObjectResponse struct {\n}\n\nfunc (*awsRestxml_deserializeOpWriteGetObjectResponse) ID() string {\n\treturn \"OperationDeserializer\"\n}\n\nfunc (m *awsRestxml_deserializeOpWriteGetObjectResponse) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (\n\tout middleware.DeserializeOutput, metadata middleware.Metadata, err error,\n) {\n\tout, metadata, err = next.HandleDeserialize(ctx, in)\n\tif err != nil {\n\t\treturn out, metadata, err\n\t}\n\n\t_, span := tracing.StartSpan(ctx, \"OperationDeserializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.deserialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\tresponse, ok := out.RawResponse.(*smithyhttp.Response)\n\tif !ok {\n\t\treturn out, metadata, &smithy.DeserializationError{Err: fmt.Errorf(\"unknown transport type %T\", out.RawResponse)}\n\t}\n\n\tif response.StatusCode < 200 || response.StatusCode >= 300 {\n\t\treturn out, metadata, awsRestxml_deserializeOpErrorWriteGetObjectResponse(response, &metadata)\n\t}\n\toutput := &WriteGetObjectResponseOutput{}\n\tout.Result = output\n\n\tif _, err = io.Copy(ioutil.Discard, response.Body); err != nil {\n\t\treturn out, metadata, &smithy.DeserializationError{\n\t\t\tErr: fmt.Errorf(\"failed to discard response body, %w\", err),\n\t\t}\n\t}\n\n\tspan.End()\n\treturn out, metadata, err\n}\n\nfunc awsRestxml_deserializeOpErrorWriteGetObjectResponse(response *smithyhttp.Response, metadata *middleware.Metadata) error {\n\tvar errorBuffer bytes.Buffer\n\tif _, err := io.Copy(&errorBuffer, response.Body); err != nil {\n\t\treturn &smithy.DeserializationError{Err: fmt.Errorf(\"failed to copy error response body, %w\", err)}\n\t}\n\terrorBody := bytes.NewReader(errorBuffer.Bytes())\n\n\terrorCode := \"UnknownError\"\n\terrorMessage := errorCode\n\n\terrorComponents, err := s3shared.GetErrorResponseComponents(errorBody, s3shared.ErrorResponseDeserializerOptions{\n\t\tUseStatusCode: true, StatusCode: response.StatusCode,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif hostID := errorComponents.HostID; len(hostID) != 0 {\n\t\ts3shared.SetHostIDMetadata(metadata, hostID)\n\t}\n\tif reqID := errorComponents.RequestID; len(reqID) != 0 {\n\t\tawsmiddleware.SetRequestIDMetadata(metadata, reqID)\n\t}\n\tif len(errorComponents.Code) != 0 {\n\t\terrorCode = errorComponents.Code\n\t}\n\tif len(errorComponents.Message) != 0 {\n\t\terrorMessage = errorComponents.Message\n\t}\n\terrorBody.Seek(0, io.SeekStart)\n\tswitch {\n\tdefault:\n\t\tgenericError := &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\t\treturn genericError\n\n\t}\n}\n\nfunc awsRestxml_deserializeEventStreamSelectObjectContentEventStream(v *types.SelectObjectContentEventStream, msg *eventstream.Message) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected serialization of nil %T\", v)\n\t}\n\n\teventType := msg.Headers.Get(eventstreamapi.EventTypeHeader)\n\tif eventType == nil {\n\t\treturn fmt.Errorf(\"%s event header not present\", eventstreamapi.EventTypeHeader)\n\t}\n\n\tswitch {\n\tcase strings.EqualFold(\"Cont\", eventType.String()):\n\t\tvv := &types.SelectObjectContentEventStreamMemberCont{}\n\t\tif err := awsRestxml_deserializeEventMessageContinuationEvent(&vv.Value, msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*v = vv\n\t\treturn nil\n\n\tcase strings.EqualFold(\"End\", eventType.String()):\n\t\tvv := &types.SelectObjectContentEventStreamMemberEnd{}\n\t\tif err := awsRestxml_deserializeEventMessageEndEvent(&vv.Value, msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*v = vv\n\t\treturn nil\n\n\tcase strings.EqualFold(\"Progress\", eventType.String()):\n\t\tvv := &types.SelectObjectContentEventStreamMemberProgress{}\n\t\tif err := awsRestxml_deserializeEventMessageProgressEvent(&vv.Value, msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*v = vv\n\t\treturn nil\n\n\tcase strings.EqualFold(\"Records\", eventType.String()):\n\t\tvv := &types.SelectObjectContentEventStreamMemberRecords{}\n\t\tif err := awsRestxml_deserializeEventMessageRecordsEvent(&vv.Value, msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*v = vv\n\t\treturn nil\n\n\tcase strings.EqualFold(\"Stats\", eventType.String()):\n\t\tvv := &types.SelectObjectContentEventStreamMemberStats{}\n\t\tif err := awsRestxml_deserializeEventMessageStatsEvent(&vv.Value, msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*v = vv\n\t\treturn nil\n\n\tdefault:\n\t\tbuffer := bytes.NewBuffer(nil)\n\t\teventstream.NewEncoder().Encode(buffer, *msg)\n\t\t*v = &types.UnknownUnionMember{\n\t\t\tTag:   eventType.String(),\n\t\t\tValue: buffer.Bytes(),\n\t\t}\n\t\treturn nil\n\n\t}\n}\n\nfunc awsRestxml_deserializeEventStreamExceptionSelectObjectContentEventStream(msg *eventstream.Message) error {\n\texceptionType := msg.Headers.Get(eventstreamapi.ExceptionTypeHeader)\n\tif exceptionType == nil {\n\t\treturn fmt.Errorf(\"%s event header not present\", eventstreamapi.ExceptionTypeHeader)\n\t}\n\n\tswitch {\n\tdefault:\n\t\tbr := bytes.NewReader(msg.Payload)\n\t\tvar buff [1024]byte\n\t\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\n\t\tbody := io.TeeReader(br, ringBuffer)\n\t\tdecoder := json.NewDecoder(body)\n\t\tdecoder.UseNumber()\n\t\terrorComponents, err := awsxml.GetErrorResponseComponents(br, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terrorCode := \"UnknownError\"\n\t\terrorMessage := errorCode\n\t\tif ev := exceptionType.String(); len(ev) > 0 {\n\t\t\terrorCode = ev\n\t\t} else if ev := errorComponents.Code; len(ev) > 0 {\n\t\t\terrorCode = ev\n\t\t}\n\t\tif ev := errorComponents.Message; len(ev) > 0 {\n\t\t\terrorMessage = ev\n\t\t}\n\t\treturn &smithy.GenericAPIError{\n\t\t\tCode:    errorCode,\n\t\t\tMessage: errorMessage,\n\t\t}\n\n\t}\n}\n\nfunc awsRestxml_deserializeEventMessageRecordsEvent(v *types.RecordsEvent, msg *eventstream.Message) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected serialization of nil %T\", v)\n\t}\n\n\tif msg.Payload != nil {\n\t\tbsv := make([]byte, len(msg.Payload))\n\t\tcopy(bsv, msg.Payload)\n\n\t\tv.Payload = bsv\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_deserializeEventMessageStatsEvent(v *types.StatsEvent, msg *eventstream.Message) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected serialization of nil %T\", v)\n\t}\n\n\tbr := bytes.NewReader(msg.Payload)\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(br, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentStats(&v.Details, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc awsRestxml_deserializeEventMessageProgressEvent(v *types.ProgressEvent, msg *eventstream.Message) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected serialization of nil %T\", v)\n\t}\n\n\tbr := bytes.NewReader(msg.Payload)\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(br, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentProgress(&v.Details, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc awsRestxml_deserializeEventMessageContinuationEvent(v *types.ContinuationEvent, msg *eventstream.Message) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected serialization of nil %T\", v)\n\t}\n\n\tbr := bytes.NewReader(msg.Payload)\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(br, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentContinuationEvent(&v, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc awsRestxml_deserializeEventMessageEndEvent(v *types.EndEvent, msg *eventstream.Message) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected serialization of nil %T\", v)\n\t}\n\n\tbr := bytes.NewReader(msg.Payload)\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(br, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentEndEvent(&v, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentContinuationEvent(v **types.ContinuationEvent, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ContinuationEvent\n\tif *v == nil {\n\t\tsv = &types.ContinuationEvent{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentEndEvent(v **types.EndEvent, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.EndEvent\n\tif *v == nil {\n\t\tsv = &types.EndEvent{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentProgress(v **types.Progress, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Progress\n\tif *v == nil {\n\t\tsv = &types.Progress{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"BytesProcessed\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.BytesProcessed = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BytesReturned\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.BytesReturned = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BytesScanned\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.BytesScanned = ptr.Int64(i64)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentStats(v **types.Stats, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Stats\n\tif *v == nil {\n\t\tsv = &types.Stats{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"BytesProcessed\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.BytesProcessed = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BytesReturned\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.BytesReturned = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BytesScanned\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.BytesScanned = ptr.Int64(i64)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeErrorBucketAlreadyExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.BucketAlreadyExists{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorBucketAlreadyOwnedByYou(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.BucketAlreadyOwnedByYou{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorEncryptionTypeMismatch(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.EncryptionTypeMismatch{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorIdempotencyParameterMismatch(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.IdempotencyParameterMismatch{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorInvalidObjectState(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.InvalidObjectState{}\n\tvar buff [1024]byte\n\tringBuffer := smithyio.NewRingBuffer(buff[:])\n\tbody := io.TeeReader(errorBody, ringBuffer)\n\trootDecoder := xml.NewDecoder(body)\n\tt, err := smithyxml.FetchRootElement(rootDecoder)\n\tif err == io.EOF {\n\t\treturn output\n\t}\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\tdecoder := smithyxml.WrapNodeDecoder(rootDecoder, t)\n\terr = awsRestxml_deserializeDocumentInvalidObjectState(&output, decoder)\n\tif err != nil {\n\t\tvar snapshot bytes.Buffer\n\t\tio.Copy(&snapshot, ringBuffer)\n\t\treturn &smithy.DeserializationError{\n\t\t\tErr:      fmt.Errorf(\"failed to decode response body, %w\", err),\n\t\t\tSnapshot: snapshot.Bytes(),\n\t\t}\n\t}\n\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorInvalidRequest(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.InvalidRequest{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorInvalidWriteOffset(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.InvalidWriteOffset{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorNoSuchBucket(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.NoSuchBucket{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorNoSuchKey(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.NoSuchKey{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorNoSuchUpload(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.NoSuchUpload{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorNotFound(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.NotFound{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorObjectAlreadyInActiveTierError(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.ObjectAlreadyInActiveTierError{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorObjectNotInActiveTierError(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.ObjectNotInActiveTierError{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeErrorTooManyParts(response *smithyhttp.Response, errorBody *bytes.Reader) error {\n\toutput := &types.TooManyParts{}\n\treturn output\n}\n\nfunc awsRestxml_deserializeDocumentAbacStatus(v **types.AbacStatus, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AbacStatus\n\tif *v == nil {\n\t\tsv = &types.AbacStatus{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.BucketAbacStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAbortIncompleteMultipartUpload(v **types.AbortIncompleteMultipartUpload, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AbortIncompleteMultipartUpload\n\tif *v == nil {\n\t\tsv = &types.AbortIncompleteMultipartUpload{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DaysAfterInitiation\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.DaysAfterInitiation = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAccessControlTranslation(v **types.AccessControlTranslation, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AccessControlTranslation\n\tif *v == nil {\n\t\tsv = &types.AccessControlTranslation{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Owner = types.OwnerOverride(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAllowedHeaders(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = xtv\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAllowedHeadersUnwrapped(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv string\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = xtv\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentAllowedMethods(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = xtv\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAllowedMethodsUnwrapped(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv string\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = xtv\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentAllowedOrigins(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = xtv\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAllowedOriginsUnwrapped(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv string\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = xtv\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentAnalyticsAndOperator(v **types.AnalyticsAndOperator, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AnalyticsAndOperator\n\tif *v == nil {\n\t\tsv = &types.AnalyticsAndOperator{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSetUnwrapped(&sv.Tags, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAnalyticsConfiguration(v **types.AnalyticsConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AnalyticsConfiguration\n\tif *v == nil {\n\t\tsv = &types.AnalyticsConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClassAnalysis\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentStorageClassAnalysis(&sv.StorageClassAnalysis, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAnalyticsConfigurationList(v *[]types.AnalyticsConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.AnalyticsConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.AnalyticsConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.AnalyticsConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAnalyticsConfigurationListUnwrapped(v *[]types.AnalyticsConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.AnalyticsConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.AnalyticsConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.AnalyticsConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentAnalyticsConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentAnalyticsExportDestination(v **types.AnalyticsExportDestination, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AnalyticsExportDestination\n\tif *v == nil {\n\t\tsv = &types.AnalyticsExportDestination{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"S3BucketDestination\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsS3BucketDestination(&sv.S3BucketDestination, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAnalyticsFilter(v *types.AnalyticsFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar uv types.AnalyticsFilter\n\tvar memberFound bool\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tif memberFound {\n\t\t\tif err = decoder.Decoder.Skip(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"And\", t.Name.Local):\n\t\t\tvar mv types.AnalyticsAndOperator\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &mv\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsAndOperator(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmv = *destAddr\n\t\t\tuv = &types.AnalyticsFilterMemberAnd{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tvar mv string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tmv = xtv\n\t\t\t}\n\t\t\tuv = &types.AnalyticsFilterMemberPrefix{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tvar mv types.Tag\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &mv\n\t\t\tif err := awsRestxml_deserializeDocumentTag(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmv = *destAddr\n\t\t\tuv = &types.AnalyticsFilterMemberTag{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tdefault:\n\t\t\tuv = &types.UnknownUnionMember{Tag: t.Name.Local}\n\t\t\tmemberFound = true\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = uv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentAnalyticsS3BucketDestination(v **types.AnalyticsS3BucketDestination, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.AnalyticsS3BucketDestination\n\tif *v == nil {\n\t\tsv = &types.AnalyticsS3BucketDestination{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BucketAccountId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.BucketAccountId = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Format\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Format = types.AnalyticsS3ExportFileFormat(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentBlockedEncryptionTypes(v **types.BlockedEncryptionTypes, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.BlockedEncryptionTypes\n\tif *v == nil {\n\t\tsv = &types.BlockedEncryptionTypes{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"EncryptionType\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentEncryptionTypeListUnwrapped(&sv.EncryptionType, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentBucket(v **types.Bucket, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Bucket\n\tif *v == nil {\n\t\tsv = &types.Bucket{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"BucketArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.BucketArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BucketRegion\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.BucketRegion = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"CreationDate\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.CreationDate = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Name\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Name = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentBucketAlreadyExists(v **types.BucketAlreadyExists, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.BucketAlreadyExists\n\tif *v == nil {\n\t\tsv = &types.BucketAlreadyExists{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentBucketAlreadyOwnedByYou(v **types.BucketAlreadyOwnedByYou, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.BucketAlreadyOwnedByYou\n\tif *v == nil {\n\t\tsv = &types.BucketAlreadyOwnedByYou{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentBuckets(v *[]types.Bucket, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Bucket\n\tif *v == nil {\n\t\tsv = make([]types.Bucket, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tvar col types.Bucket\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentBucket(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentBucketsUnwrapped(v *[]types.Bucket, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Bucket\n\tif *v == nil {\n\t\tsv = make([]types.Bucket, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Bucket\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentBucket(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentChecksum(v **types.Checksum, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Checksum\n\tif *v == nil {\n\t\tsv = &types.Checksum{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumCRC32\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32C\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32C = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC64NVME\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC64NVME = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA1\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA1 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA256\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA256 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentChecksumAlgorithmList(v *[]types.ChecksumAlgorithm, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.ChecksumAlgorithm\n\tif *v == nil {\n\t\tsv = make([]types.ChecksumAlgorithm, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.ChecksumAlgorithm\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = types.ChecksumAlgorithm(xtv)\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentChecksumAlgorithmListUnwrapped(v *[]types.ChecksumAlgorithm, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.ChecksumAlgorithm\n\tif *v == nil {\n\t\tsv = make([]types.ChecksumAlgorithm, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.ChecksumAlgorithm\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = types.ChecksumAlgorithm(xtv)\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentCommonPrefix(v **types.CommonPrefix, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.CommonPrefix\n\tif *v == nil {\n\t\tsv = &types.CommonPrefix{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCommonPrefixList(v *[]types.CommonPrefix, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.CommonPrefix\n\tif *v == nil {\n\t\tsv = make([]types.CommonPrefix, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.CommonPrefix\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentCommonPrefix(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCommonPrefixListUnwrapped(v *[]types.CommonPrefix, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.CommonPrefix\n\tif *v == nil {\n\t\tsv = make([]types.CommonPrefix, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.CommonPrefix\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentCommonPrefix(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentCondition(v **types.Condition, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Condition\n\tif *v == nil {\n\t\tsv = &types.Condition{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"HttpErrorCodeReturnedEquals\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.HttpErrorCodeReturnedEquals = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"KeyPrefixEquals\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.KeyPrefixEquals = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCopyObjectResult(v **types.CopyObjectResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.CopyObjectResult\n\tif *v == nil {\n\t\tsv = &types.CopyObjectResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumCRC32\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32C\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32C = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC64NVME\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC64NVME = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA1\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA1 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA256\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA256 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"LastModified\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.LastModified = ptr.Time(t)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCopyPartResult(v **types.CopyPartResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.CopyPartResult\n\tif *v == nil {\n\t\tsv = &types.CopyPartResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumCRC32\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32C\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32C = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC64NVME\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC64NVME = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA1\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA1 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA256\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA256 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"LastModified\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.LastModified = ptr.Time(t)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCORSRule(v **types.CORSRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.CORSRule\n\tif *v == nil {\n\t\tsv = &types.CORSRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AllowedHeader\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAllowedHeadersUnwrapped(&sv.AllowedHeaders, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"AllowedMethod\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAllowedMethodsUnwrapped(&sv.AllowedMethods, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"AllowedOrigin\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAllowedOriginsUnwrapped(&sv.AllowedOrigins, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ExposeHeader\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentExposeHeadersUnwrapped(&sv.ExposeHeaders, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ID = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxAgeSeconds\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxAgeSeconds = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCORSRules(v *[]types.CORSRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.CORSRule\n\tif *v == nil {\n\t\tsv = make([]types.CORSRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.CORSRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentCORSRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentCORSRulesUnwrapped(v *[]types.CORSRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.CORSRule\n\tif *v == nil {\n\t\tsv = make([]types.CORSRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.CORSRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentCORSRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentDefaultRetention(v **types.DefaultRetention, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.DefaultRetention\n\tif *v == nil {\n\t\tsv = &types.DefaultRetention{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Days\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Days = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Mode\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Mode = types.ObjectLockRetentionMode(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Years\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Years = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDeletedObject(v **types.DeletedObject, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.DeletedObject\n\tif *v == nil {\n\t\tsv = &types.DeletedObject{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DeleteMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected DeleteMarker to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.DeleteMarker = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"DeleteMarkerVersionId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.DeleteMarkerVersionId = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"VersionId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.VersionId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDeletedObjects(v *[]types.DeletedObject, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.DeletedObject\n\tif *v == nil {\n\t\tsv = make([]types.DeletedObject, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.DeletedObject\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentDeletedObject(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDeletedObjectsUnwrapped(v *[]types.DeletedObject, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.DeletedObject\n\tif *v == nil {\n\t\tsv = make([]types.DeletedObject, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.DeletedObject\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentDeletedObject(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentDeleteMarkerEntry(v **types.DeleteMarkerEntry, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.DeleteMarkerEntry\n\tif *v == nil {\n\t\tsv = &types.DeleteMarkerEntry{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"IsLatest\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsLatest to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsLatest = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"LastModified\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.LastModified = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"VersionId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.VersionId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDeleteMarkerReplication(v **types.DeleteMarkerReplication, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.DeleteMarkerReplication\n\tif *v == nil {\n\t\tsv = &types.DeleteMarkerReplication{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.DeleteMarkerReplicationStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDeleteMarkers(v *[]types.DeleteMarkerEntry, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.DeleteMarkerEntry\n\tif *v == nil {\n\t\tsv = make([]types.DeleteMarkerEntry, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.DeleteMarkerEntry\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentDeleteMarkerEntry(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDeleteMarkersUnwrapped(v *[]types.DeleteMarkerEntry, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.DeleteMarkerEntry\n\tif *v == nil {\n\t\tsv = make([]types.DeleteMarkerEntry, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.DeleteMarkerEntry\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentDeleteMarkerEntry(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentDestination(v **types.Destination, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Destination\n\tif *v == nil {\n\t\tsv = &types.Destination{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessControlTranslation\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAccessControlTranslation(&sv.AccessControlTranslation, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Account\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Account = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"EncryptionConfiguration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentEncryptionConfiguration(&sv.EncryptionConfiguration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Metrics\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMetrics(&sv.Metrics, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ReplicationTime\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationTime(&sv.ReplicationTime, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.StorageClass(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentDestinationResult(v **types.DestinationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.DestinationResult\n\tif *v == nil {\n\t\tsv = &types.DestinationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"TableBucketArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableBucketArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableBucketType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableBucketType = types.S3TablesBucketType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableNamespace\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableNamespace = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentEncryptionConfiguration(v **types.EncryptionConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.EncryptionConfiguration\n\tif *v == nil {\n\t\tsv = &types.EncryptionConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ReplicaKmsKeyID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ReplicaKmsKeyID = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentEncryptionTypeList(v *[]types.EncryptionType, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.EncryptionType\n\tif *v == nil {\n\t\tsv = make([]types.EncryptionType, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"EncryptionType\", t.Name.Local):\n\t\t\tvar col types.EncryptionType\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = types.EncryptionType(xtv)\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentEncryptionTypeListUnwrapped(v *[]types.EncryptionType, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.EncryptionType\n\tif *v == nil {\n\t\tsv = make([]types.EncryptionType, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.EncryptionType\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = types.EncryptionType(xtv)\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentEncryptionTypeMismatch(v **types.EncryptionTypeMismatch, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.EncryptionTypeMismatch\n\tif *v == nil {\n\t\tsv = &types.EncryptionTypeMismatch{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentError(v **types.Error, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Error\n\tif *v == nil {\n\t\tsv = &types.Error{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Code\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Code = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Message\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Message = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"VersionId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.VersionId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentErrorDetails(v **types.ErrorDetails, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ErrorDetails\n\tif *v == nil {\n\t\tsv = &types.ErrorDetails{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ErrorCode\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ErrorCode = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ErrorMessage\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ErrorMessage = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentErrorDocument(v **types.ErrorDocument, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ErrorDocument\n\tif *v == nil {\n\t\tsv = &types.ErrorDocument{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentErrors(v *[]types.Error, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Error\n\tif *v == nil {\n\t\tsv = make([]types.Error, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.Error\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentError(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentErrorsUnwrapped(v *[]types.Error, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Error\n\tif *v == nil {\n\t\tsv = make([]types.Error, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Error\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentError(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentEventBridgeConfiguration(v **types.EventBridgeConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.EventBridgeConfiguration\n\tif *v == nil {\n\t\tsv = &types.EventBridgeConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentEventList(v *[]types.Event, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Event\n\tif *v == nil {\n\t\tsv = make([]types.Event, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.Event\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = types.Event(xtv)\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentEventListUnwrapped(v *[]types.Event, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Event\n\tif *v == nil {\n\t\tsv = make([]types.Event, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Event\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = types.Event(xtv)\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentExistingObjectReplication(v **types.ExistingObjectReplication, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ExistingObjectReplication\n\tif *v == nil {\n\t\tsv = &types.ExistingObjectReplication{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.ExistingObjectReplicationStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentExposeHeaders(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = xtv\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentExposeHeadersUnwrapped(v *[]string, decoder smithyxml.NodeDecoder) error {\n\tvar sv []string\n\tif *v == nil {\n\t\tsv = make([]string, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv string\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = xtv\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentFilterRule(v **types.FilterRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.FilterRule\n\tif *v == nil {\n\t\tsv = &types.FilterRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Name\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Name = types.FilterRuleName(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Value\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Value = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentFilterRuleList(v *[]types.FilterRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.FilterRule\n\tif *v == nil {\n\t\tsv = make([]types.FilterRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.FilterRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentFilterRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentFilterRuleListUnwrapped(v *[]types.FilterRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.FilterRule\n\tif *v == nil {\n\t\tsv = make([]types.FilterRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.FilterRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentFilterRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentGetBucketMetadataConfigurationResult(v **types.GetBucketMetadataConfigurationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.GetBucketMetadataConfigurationResult\n\tif *v == nil {\n\t\tsv = &types.GetBucketMetadataConfigurationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"MetadataConfigurationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMetadataConfigurationResult(&sv.MetadataConfigurationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentGetBucketMetadataTableConfigurationResult(v **types.GetBucketMetadataTableConfigurationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.GetBucketMetadataTableConfigurationResult\n\tif *v == nil {\n\t\tsv = &types.GetBucketMetadataTableConfigurationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Error\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentErrorDetails(&sv.Error, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MetadataTableConfigurationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMetadataTableConfigurationResult(&sv.MetadataTableConfigurationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentGetObjectAttributesParts(v **types.GetObjectAttributesParts, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.GetObjectAttributesParts\n\tif *v == nil {\n\t\tsv = &types.GetObjectAttributesParts{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"IsTruncated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsTruncated to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsTruncated = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"MaxParts\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.MaxParts = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NextPartNumberMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.NextPartNumberMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"PartNumberMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.PartNumberMarker = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Part\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentPartsListUnwrapped(&sv.Parts, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"PartsCount\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.TotalPartsCount = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentGrant(v **types.Grant, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Grant\n\tif *v == nil {\n\t\tsv = &types.Grant{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Grantee\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGrantee(&sv.Grantee, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Permission\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Permission = types.Permission(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentGrantee(v **types.Grantee, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Grantee\n\tif *v == nil {\n\t\tsv = &types.Grantee{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor _, attr := range decoder.StartEl.Attr {\n\t\tname := attr.Name.Local\n\t\tif len(attr.Name.Space) != 0 {\n\t\t\tname = attr.Name.Space + `:` + attr.Name.Local\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"xsi:type\", name):\n\t\t\tval := []byte(attr.Value)\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Type = types.Type(xtv)\n\t\t\t}\n\n\t\t}\n\t}\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DisplayName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.DisplayName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"EmailAddress\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.EmailAddress = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ID = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"URI\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.URI = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentGrants(v *[]types.Grant, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Grant\n\tif *v == nil {\n\t\tsv = make([]types.Grant, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Grant\", t.Name.Local):\n\t\t\tvar col types.Grant\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentGrant(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentGrantsUnwrapped(v *[]types.Grant, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Grant\n\tif *v == nil {\n\t\tsv = make([]types.Grant, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Grant\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentGrant(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentIdempotencyParameterMismatch(v **types.IdempotencyParameterMismatch, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.IdempotencyParameterMismatch\n\tif *v == nil {\n\t\tsv = &types.IdempotencyParameterMismatch{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentIndexDocument(v **types.IndexDocument, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.IndexDocument\n\tif *v == nil {\n\t\tsv = &types.IndexDocument{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Suffix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Suffix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInitiator(v **types.Initiator, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Initiator\n\tif *v == nil {\n\t\tsv = &types.Initiator{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DisplayName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.DisplayName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ID = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentIntelligentTieringAndOperator(v **types.IntelligentTieringAndOperator, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.IntelligentTieringAndOperator\n\tif *v == nil {\n\t\tsv = &types.IntelligentTieringAndOperator{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSetUnwrapped(&sv.Tags, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentIntelligentTieringConfiguration(v **types.IntelligentTieringConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.IntelligentTieringConfiguration\n\tif *v == nil {\n\t\tsv = &types.IntelligentTieringConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentIntelligentTieringFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.IntelligentTieringStatus(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tiering\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTieringListUnwrapped(&sv.Tierings, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentIntelligentTieringConfigurationList(v *[]types.IntelligentTieringConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.IntelligentTieringConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.IntelligentTieringConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.IntelligentTieringConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentIntelligentTieringConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentIntelligentTieringConfigurationListUnwrapped(v *[]types.IntelligentTieringConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.IntelligentTieringConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.IntelligentTieringConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.IntelligentTieringConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentIntelligentTieringConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentIntelligentTieringFilter(v **types.IntelligentTieringFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.IntelligentTieringFilter\n\tif *v == nil {\n\t\tsv = &types.IntelligentTieringFilter{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"And\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentIntelligentTieringAndOperator(&sv.And, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTag(&sv.Tag, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInvalidObjectState(v **types.InvalidObjectState, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InvalidObjectState\n\tif *v == nil {\n\t\tsv = &types.InvalidObjectState{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessTier\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.AccessTier = types.IntelligentTieringAccessTier(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.StorageClass(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInvalidRequest(v **types.InvalidRequest, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InvalidRequest\n\tif *v == nil {\n\t\tsv = &types.InvalidRequest{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInvalidWriteOffset(v **types.InvalidWriteOffset, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InvalidWriteOffset\n\tif *v == nil {\n\t\tsv = &types.InvalidWriteOffset{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryConfiguration(v **types.InventoryConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventoryConfiguration\n\tif *v == nil {\n\t\tsv = &types.InventoryConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Destination\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryDestination(&sv.Destination, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IncludedObjectVersions\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.IncludedObjectVersions = types.InventoryIncludedObjectVersions(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsEnabled\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsEnabled to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsEnabled = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"OptionalFields\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryOptionalFields(&sv.OptionalFields, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Schedule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventorySchedule(&sv.Schedule, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryConfigurationList(v *[]types.InventoryConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.InventoryConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.InventoryConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.InventoryConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryConfigurationListUnwrapped(v *[]types.InventoryConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.InventoryConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.InventoryConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.InventoryConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentInventoryConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentInventoryDestination(v **types.InventoryDestination, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventoryDestination\n\tif *v == nil {\n\t\tsv = &types.InventoryDestination{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"S3BucketDestination\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryS3BucketDestination(&sv.S3BucketDestination, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryEncryption(v **types.InventoryEncryption, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventoryEncryption\n\tif *v == nil {\n\t\tsv = &types.InventoryEncryption{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"SSE-KMS\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentSSEKMS(&sv.SSEKMS, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SSE-S3\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentSSES3(&sv.SSES3, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryFilter(v **types.InventoryFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventoryFilter\n\tif *v == nil {\n\t\tsv = &types.InventoryFilter{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryOptionalFields(v *[]types.InventoryOptionalField, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.InventoryOptionalField\n\tif *v == nil {\n\t\tsv = make([]types.InventoryOptionalField, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tmemberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdecoder = memberDecoder\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Field\", t.Name.Local):\n\t\t\tvar col types.InventoryOptionalField\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tcol = types.InventoryOptionalField(xtv)\n\t\t\t}\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryOptionalFieldsUnwrapped(v *[]types.InventoryOptionalField, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.InventoryOptionalField\n\tif *v == nil {\n\t\tsv = make([]types.InventoryOptionalField, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.InventoryOptionalField\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tval, err := decoder.Value()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val == nil {\n\t\t\tbreak\n\t\t}\n\t\t{\n\t\t\txtv := string(val)\n\t\t\tmv = types.InventoryOptionalField(xtv)\n\t\t}\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentInventoryS3BucketDestination(v **types.InventoryS3BucketDestination, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventoryS3BucketDestination\n\tif *v == nil {\n\t\tsv = &types.InventoryS3BucketDestination{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccountId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.AccountId = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Bucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Bucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Encryption\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryEncryption(&sv.Encryption, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Format\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Format = types.InventoryFormat(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventorySchedule(v **types.InventorySchedule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventorySchedule\n\tif *v == nil {\n\t\tsv = &types.InventorySchedule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Frequency\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Frequency = types.InventoryFrequency(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentInventoryTableConfigurationResult(v **types.InventoryTableConfigurationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.InventoryTableConfigurationResult\n\tif *v == nil {\n\t\tsv = &types.InventoryTableConfigurationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ConfigurationState\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ConfigurationState = types.InventoryConfigurationState(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Error\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentErrorDetails(&sv.Error, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableStatus\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableStatus = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentJournalTableConfigurationResult(v **types.JournalTableConfigurationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.JournalTableConfigurationResult\n\tif *v == nil {\n\t\tsv = &types.JournalTableConfigurationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Error\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentErrorDetails(&sv.Error, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RecordExpiration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentRecordExpiration(&sv.RecordExpiration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableStatus\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableStatus = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLambdaFunctionConfiguration(v **types.LambdaFunctionConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.LambdaFunctionConfiguration\n\tif *v == nil {\n\t\tsv = &types.LambdaFunctionConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Event\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentEventListUnwrapped(&sv.Events, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentNotificationConfigurationFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"CloudFunction\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.LambdaFunctionArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLambdaFunctionConfigurationList(v *[]types.LambdaFunctionConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.LambdaFunctionConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.LambdaFunctionConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.LambdaFunctionConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentLambdaFunctionConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLambdaFunctionConfigurationListUnwrapped(v *[]types.LambdaFunctionConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.LambdaFunctionConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.LambdaFunctionConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.LambdaFunctionConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentLambdaFunctionConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentLifecycleExpiration(v **types.LifecycleExpiration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.LifecycleExpiration\n\tif *v == nil {\n\t\tsv = &types.LifecycleExpiration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Date\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Date = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Days\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Days = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ExpiredObjectDeleteMarker\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected ExpiredObjectDeleteMarker to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.ExpiredObjectDeleteMarker = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLifecycleRule(v **types.LifecycleRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.LifecycleRule\n\tif *v == nil {\n\t\tsv = &types.LifecycleRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AbortIncompleteMultipartUpload\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAbortIncompleteMultipartUpload(&sv.AbortIncompleteMultipartUpload, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Expiration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentLifecycleExpiration(&sv.Expiration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentLifecycleRuleFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ID = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NoncurrentVersionExpiration\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentNoncurrentVersionExpiration(&sv.NoncurrentVersionExpiration, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NoncurrentVersionTransition\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentNoncurrentVersionTransitionListUnwrapped(&sv.NoncurrentVersionTransitions, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.ExpirationStatus(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Transition\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTransitionListUnwrapped(&sv.Transitions, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLifecycleRuleAndOperator(v **types.LifecycleRuleAndOperator, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.LifecycleRuleAndOperator\n\tif *v == nil {\n\t\tsv = &types.LifecycleRuleAndOperator{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ObjectSizeGreaterThan\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.ObjectSizeGreaterThan = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ObjectSizeLessThan\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.ObjectSizeLessThan = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSetUnwrapped(&sv.Tags, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLifecycleRuleFilter(v **types.LifecycleRuleFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.LifecycleRuleFilter\n\tif *v == nil {\n\t\tsv = &types.LifecycleRuleFilter{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"And\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentLifecycleRuleAndOperator(&sv.And, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ObjectSizeGreaterThan\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.ObjectSizeGreaterThan = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ObjectSizeLessThan\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.ObjectSizeLessThan = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTag(&sv.Tag, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLifecycleRules(v *[]types.LifecycleRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.LifecycleRule\n\tif *v == nil {\n\t\tsv = make([]types.LifecycleRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.LifecycleRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentLifecycleRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentLifecycleRulesUnwrapped(v *[]types.LifecycleRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.LifecycleRule\n\tif *v == nil {\n\t\tsv = make([]types.LifecycleRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.LifecycleRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentLifecycleRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentLoggingEnabled(v **types.LoggingEnabled, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.LoggingEnabled\n\tif *v == nil {\n\t\tsv = &types.LoggingEnabled{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"TargetBucket\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TargetBucket = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TargetGrants\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTargetGrants(&sv.TargetGrants, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TargetObjectKeyFormat\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTargetObjectKeyFormat(&sv.TargetObjectKeyFormat, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TargetPrefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TargetPrefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetadataConfigurationResult(v **types.MetadataConfigurationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.MetadataConfigurationResult\n\tif *v == nil {\n\t\tsv = &types.MetadataConfigurationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DestinationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentDestinationResult(&sv.DestinationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"InventoryTableConfigurationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInventoryTableConfigurationResult(&sv.InventoryTableConfigurationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"JournalTableConfigurationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentJournalTableConfigurationResult(&sv.JournalTableConfigurationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetadataTableConfigurationResult(v **types.MetadataTableConfigurationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.MetadataTableConfigurationResult\n\tif *v == nil {\n\t\tsv = &types.MetadataTableConfigurationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"S3TablesDestinationResult\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentS3TablesDestinationResult(&sv.S3TablesDestinationResult, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetrics(v **types.Metrics, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Metrics\n\tif *v == nil {\n\t\tsv = &types.Metrics{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"EventThreshold\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationTimeValue(&sv.EventThreshold, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.MetricsStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetricsAndOperator(v **types.MetricsAndOperator, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.MetricsAndOperator\n\tif *v == nil {\n\t\tsv = &types.MetricsAndOperator{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessPointArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.AccessPointArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSetUnwrapped(&sv.Tags, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetricsConfiguration(v **types.MetricsConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.MetricsConfiguration\n\tif *v == nil {\n\t\tsv = &types.MetricsConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentMetricsFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetricsConfigurationList(v *[]types.MetricsConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.MetricsConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.MetricsConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.MetricsConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentMetricsConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMetricsConfigurationListUnwrapped(v *[]types.MetricsConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.MetricsConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.MetricsConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.MetricsConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentMetricsConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentMetricsFilter(v *types.MetricsFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar uv types.MetricsFilter\n\tvar memberFound bool\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tif memberFound {\n\t\t\tif err = decoder.Decoder.Skip(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessPointArn\", t.Name.Local):\n\t\t\tvar mv string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tmv = xtv\n\t\t\t}\n\t\t\tuv = &types.MetricsFilterMemberAccessPointArn{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tcase strings.EqualFold(\"And\", t.Name.Local):\n\t\t\tvar mv types.MetricsAndOperator\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &mv\n\t\t\tif err := awsRestxml_deserializeDocumentMetricsAndOperator(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmv = *destAddr\n\t\t\tuv = &types.MetricsFilterMemberAnd{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tvar mv string\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tmv = xtv\n\t\t\t}\n\t\t\tuv = &types.MetricsFilterMemberPrefix{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tvar mv types.Tag\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &mv\n\t\t\tif err := awsRestxml_deserializeDocumentTag(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tmv = *destAddr\n\t\t\tuv = &types.MetricsFilterMemberTag{Value: mv}\n\t\t\tmemberFound = true\n\n\t\tdefault:\n\t\t\tuv = &types.UnknownUnionMember{Tag: t.Name.Local}\n\t\t\tmemberFound = true\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = uv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMultipartUpload(v **types.MultipartUpload, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.MultipartUpload\n\tif *v == nil {\n\t\tsv = &types.MultipartUpload{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumAlgorithm\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumAlgorithm = types.ChecksumAlgorithm(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Initiated\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Initiated = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Initiator\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentInitiator(&sv.Initiator, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.StorageClass(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"UploadId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.UploadId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMultipartUploadList(v *[]types.MultipartUpload, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.MultipartUpload\n\tif *v == nil {\n\t\tsv = make([]types.MultipartUpload, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.MultipartUpload\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentMultipartUpload(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentMultipartUploadListUnwrapped(v *[]types.MultipartUpload, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.MultipartUpload\n\tif *v == nil {\n\t\tsv = make([]types.MultipartUpload, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.MultipartUpload\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentMultipartUpload(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentNoncurrentVersionExpiration(v **types.NoncurrentVersionExpiration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NoncurrentVersionExpiration\n\tif *v == nil {\n\t\tsv = &types.NoncurrentVersionExpiration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"NewerNoncurrentVersions\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.NewerNoncurrentVersions = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NoncurrentDays\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.NoncurrentDays = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNoncurrentVersionTransition(v **types.NoncurrentVersionTransition, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NoncurrentVersionTransition\n\tif *v == nil {\n\t\tsv = &types.NoncurrentVersionTransition{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"NewerNoncurrentVersions\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.NewerNoncurrentVersions = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"NoncurrentDays\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.NoncurrentDays = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.TransitionStorageClass(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNoncurrentVersionTransitionList(v *[]types.NoncurrentVersionTransition, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.NoncurrentVersionTransition\n\tif *v == nil {\n\t\tsv = make([]types.NoncurrentVersionTransition, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.NoncurrentVersionTransition\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentNoncurrentVersionTransition(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNoncurrentVersionTransitionListUnwrapped(v *[]types.NoncurrentVersionTransition, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.NoncurrentVersionTransition\n\tif *v == nil {\n\t\tsv = make([]types.NoncurrentVersionTransition, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.NoncurrentVersionTransition\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentNoncurrentVersionTransition(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentNoSuchBucket(v **types.NoSuchBucket, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NoSuchBucket\n\tif *v == nil {\n\t\tsv = &types.NoSuchBucket{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNoSuchKey(v **types.NoSuchKey, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NoSuchKey\n\tif *v == nil {\n\t\tsv = &types.NoSuchKey{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNoSuchUpload(v **types.NoSuchUpload, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NoSuchUpload\n\tif *v == nil {\n\t\tsv = &types.NoSuchUpload{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNotFound(v **types.NotFound, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NotFound\n\tif *v == nil {\n\t\tsv = &types.NotFound{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentNotificationConfigurationFilter(v **types.NotificationConfigurationFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.NotificationConfigurationFilter\n\tif *v == nil {\n\t\tsv = &types.NotificationConfigurationFilter{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"S3Key\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentS3KeyFilter(&sv.Key, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObject(v **types.Object, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Object\n\tif *v == nil {\n\t\tsv = &types.Object{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumAlgorithm\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentChecksumAlgorithmListUnwrapped(&sv.ChecksumAlgorithm, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"LastModified\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.LastModified = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RestoreStatus\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentRestoreStatus(&sv.RestoreStatus, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Size\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Size = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.ObjectStorageClass(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectAlreadyInActiveTierError(v **types.ObjectAlreadyInActiveTierError, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectAlreadyInActiveTierError\n\tif *v == nil {\n\t\tsv = &types.ObjectAlreadyInActiveTierError{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectList(v *[]types.Object, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Object\n\tif *v == nil {\n\t\tsv = make([]types.Object, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.Object\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentObject(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectListUnwrapped(v *[]types.Object, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Object\n\tif *v == nil {\n\t\tsv = make([]types.Object, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Object\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentObject(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentObjectLockConfiguration(v **types.ObjectLockConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectLockConfiguration\n\tif *v == nil {\n\t\tsv = &types.ObjectLockConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ObjectLockEnabled\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ObjectLockEnabled = types.ObjectLockEnabled(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Rule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentObjectLockRule(&sv.Rule, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectLockLegalHold(v **types.ObjectLockLegalHold, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectLockLegalHold\n\tif *v == nil {\n\t\tsv = &types.ObjectLockLegalHold{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.ObjectLockLegalHoldStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectLockRetention(v **types.ObjectLockRetention, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectLockRetention\n\tif *v == nil {\n\t\tsv = &types.ObjectLockRetention{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Mode\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Mode = types.ObjectLockRetentionMode(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RetainUntilDate\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.RetainUntilDate = ptr.Time(t)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectLockRule(v **types.ObjectLockRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectLockRule\n\tif *v == nil {\n\t\tsv = &types.ObjectLockRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DefaultRetention\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentDefaultRetention(&sv.DefaultRetention, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectNotInActiveTierError(v **types.ObjectNotInActiveTierError, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectNotInActiveTierError\n\tif *v == nil {\n\t\tsv = &types.ObjectNotInActiveTierError{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectPart(v **types.ObjectPart, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectPart\n\tif *v == nil {\n\t\tsv = &types.ObjectPart{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumCRC32\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32C\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32C = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC64NVME\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC64NVME = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA1\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA1 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA256\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA256 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"PartNumber\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.PartNumber = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Size\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Size = ptr.Int64(i64)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectVersion(v **types.ObjectVersion, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ObjectVersion\n\tif *v == nil {\n\t\tsv = &types.ObjectVersion{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumAlgorithm\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentChecksumAlgorithmListUnwrapped(&sv.ChecksumAlgorithm, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumType\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumType = types.ChecksumType(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IsLatest\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsLatest to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsLatest = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"LastModified\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.LastModified = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Owner\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwner(&sv.Owner, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RestoreStatus\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentRestoreStatus(&sv.RestoreStatus, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Size\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Size = ptr.Int64(i64)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.ObjectVersionStorageClass(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"VersionId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.VersionId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectVersionList(v *[]types.ObjectVersion, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.ObjectVersion\n\tif *v == nil {\n\t\tsv = make([]types.ObjectVersion, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.ObjectVersion\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentObjectVersion(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentObjectVersionListUnwrapped(v *[]types.ObjectVersion, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.ObjectVersion\n\tif *v == nil {\n\t\tsv = make([]types.ObjectVersion, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.ObjectVersion\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentObjectVersion(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentOwner(v **types.Owner, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Owner\n\tif *v == nil {\n\t\tsv = &types.Owner{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DisplayName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.DisplayName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ID = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentOwnershipControls(v **types.OwnershipControls, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.OwnershipControls\n\tif *v == nil {\n\t\tsv = &types.OwnershipControls{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Rule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentOwnershipControlsRulesUnwrapped(&sv.Rules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentOwnershipControlsRule(v **types.OwnershipControlsRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.OwnershipControlsRule\n\tif *v == nil {\n\t\tsv = &types.OwnershipControlsRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ObjectOwnership\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ObjectOwnership = types.ObjectOwnership(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentOwnershipControlsRules(v *[]types.OwnershipControlsRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.OwnershipControlsRule\n\tif *v == nil {\n\t\tsv = make([]types.OwnershipControlsRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.OwnershipControlsRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentOwnershipControlsRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentOwnershipControlsRulesUnwrapped(v *[]types.OwnershipControlsRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.OwnershipControlsRule\n\tif *v == nil {\n\t\tsv = make([]types.OwnershipControlsRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.OwnershipControlsRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentOwnershipControlsRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentPart(v **types.Part, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Part\n\tif *v == nil {\n\t\tsv = &types.Part{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ChecksumCRC32\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC32C\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC32C = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumCRC64NVME\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumCRC64NVME = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA1\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA1 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ChecksumSHA256\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ChecksumSHA256 = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ETag\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ETag = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"LastModified\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.LastModified = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"PartNumber\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.PartNumber = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Size\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Size = ptr.Int64(i64)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentPartitionedPrefix(v **types.PartitionedPrefix, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.PartitionedPrefix\n\tif *v == nil {\n\t\tsv = &types.PartitionedPrefix{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"PartitionDateSource\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.PartitionDateSource = types.PartitionDateSource(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentParts(v *[]types.Part, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Part\n\tif *v == nil {\n\t\tsv = make([]types.Part, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.Part\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentPart(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentPartsUnwrapped(v *[]types.Part, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Part\n\tif *v == nil {\n\t\tsv = make([]types.Part, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Part\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentPart(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentPartsList(v *[]types.ObjectPart, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.ObjectPart\n\tif *v == nil {\n\t\tsv = make([]types.ObjectPart, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.ObjectPart\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentObjectPart(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentPartsListUnwrapped(v *[]types.ObjectPart, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.ObjectPart\n\tif *v == nil {\n\t\tsv = make([]types.ObjectPart, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.ObjectPart\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentObjectPart(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentPolicyStatus(v **types.PolicyStatus, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.PolicyStatus\n\tif *v == nil {\n\t\tsv = &types.PolicyStatus{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"IsPublic\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsPublic to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsPublic = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentPublicAccessBlockConfiguration(v **types.PublicAccessBlockConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.PublicAccessBlockConfiguration\n\tif *v == nil {\n\t\tsv = &types.PublicAccessBlockConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"BlockPublicAcls\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected Setting to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.BlockPublicAcls = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BlockPublicPolicy\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected Setting to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.BlockPublicPolicy = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"IgnorePublicAcls\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected Setting to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IgnorePublicAcls = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RestrictPublicBuckets\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected Setting to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.RestrictPublicBuckets = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentQueueConfiguration(v **types.QueueConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.QueueConfiguration\n\tif *v == nil {\n\t\tsv = &types.QueueConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Event\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentEventListUnwrapped(&sv.Events, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentNotificationConfigurationFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Queue\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.QueueArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentQueueConfigurationList(v *[]types.QueueConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.QueueConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.QueueConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.QueueConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentQueueConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentQueueConfigurationListUnwrapped(v *[]types.QueueConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.QueueConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.QueueConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.QueueConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentQueueConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentRecordExpiration(v **types.RecordExpiration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.RecordExpiration\n\tif *v == nil {\n\t\tsv = &types.RecordExpiration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Days\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Days = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Expiration\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Expiration = types.ExpirationState(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentRedirect(v **types.Redirect, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Redirect\n\tif *v == nil {\n\t\tsv = &types.Redirect{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"HostName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.HostName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"HttpRedirectCode\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.HttpRedirectCode = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Protocol\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Protocol = types.Protocol(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ReplaceKeyPrefixWith\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ReplaceKeyPrefixWith = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ReplaceKeyWith\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ReplaceKeyWith = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentRedirectAllRequestsTo(v **types.RedirectAllRequestsTo, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.RedirectAllRequestsTo\n\tif *v == nil {\n\t\tsv = &types.RedirectAllRequestsTo{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"HostName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.HostName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Protocol\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Protocol = types.Protocol(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicaModifications(v **types.ReplicaModifications, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicaModifications\n\tif *v == nil {\n\t\tsv = &types.ReplicaModifications{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.ReplicaModificationsStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationConfiguration(v **types.ReplicationConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicationConfiguration\n\tif *v == nil {\n\t\tsv = &types.ReplicationConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Role\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Role = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Rule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationRulesUnwrapped(&sv.Rules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationRule(v **types.ReplicationRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicationRule\n\tif *v == nil {\n\t\tsv = &types.ReplicationRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DeleteMarkerReplication\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentDeleteMarkerReplication(&sv.DeleteMarkerReplication, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Destination\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentDestination(&sv.Destination, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ExistingObjectReplication\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentExistingObjectReplication(&sv.ExistingObjectReplication, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationRuleFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"ID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.ID = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Priority\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Priority = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SourceSelectionCriteria\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentSourceSelectionCriteria(&sv.SourceSelectionCriteria, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.ReplicationRuleStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationRuleAndOperator(v **types.ReplicationRuleAndOperator, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicationRuleAndOperator\n\tif *v == nil {\n\t\tsv = &types.ReplicationRuleAndOperator{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTagSetUnwrapped(&sv.Tags, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationRuleFilter(v **types.ReplicationRuleFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicationRuleFilter\n\tif *v == nil {\n\t\tsv = &types.ReplicationRuleFilter{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"And\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationRuleAndOperator(&sv.And, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Prefix\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Prefix = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentTag(&sv.Tag, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationRules(v *[]types.ReplicationRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.ReplicationRule\n\tif *v == nil {\n\t\tsv = make([]types.ReplicationRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.ReplicationRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationRulesUnwrapped(v *[]types.ReplicationRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.ReplicationRule\n\tif *v == nil {\n\t\tsv = make([]types.ReplicationRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.ReplicationRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentReplicationRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentReplicationTime(v **types.ReplicationTime, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicationTime\n\tif *v == nil {\n\t\tsv = &types.ReplicationTime{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.ReplicationTimeStatus(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Time\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicationTimeValue(&sv.Time, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentReplicationTimeValue(v **types.ReplicationTimeValue, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ReplicationTimeValue\n\tif *v == nil {\n\t\tsv = &types.ReplicationTimeValue{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Minutes\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Minutes = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentRestoreStatus(v **types.RestoreStatus, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.RestoreStatus\n\tif *v == nil {\n\t\tsv = &types.RestoreStatus{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"IsRestoreInProgress\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected IsRestoreInProgress to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.IsRestoreInProgress = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"RestoreExpiryDate\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.RestoreExpiryDate = ptr.Time(t)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentRoutingRule(v **types.RoutingRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.RoutingRule\n\tif *v == nil {\n\t\tsv = &types.RoutingRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Condition\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentCondition(&sv.Condition, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Redirect\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentRedirect(&sv.Redirect, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentRoutingRules(v *[]types.RoutingRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.RoutingRule\n\tif *v == nil {\n\t\tsv = make([]types.RoutingRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"RoutingRule\", t.Name.Local):\n\t\t\tvar col types.RoutingRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentRoutingRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentRoutingRulesUnwrapped(v *[]types.RoutingRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.RoutingRule\n\tif *v == nil {\n\t\tsv = make([]types.RoutingRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.RoutingRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentRoutingRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentS3KeyFilter(v **types.S3KeyFilter, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.S3KeyFilter\n\tif *v == nil {\n\t\tsv = &types.S3KeyFilter{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"FilterRule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentFilterRuleListUnwrapped(&sv.FilterRules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentS3TablesDestinationResult(v **types.S3TablesDestinationResult, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.S3TablesDestinationResult\n\tif *v == nil {\n\t\tsv = &types.S3TablesDestinationResult{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"TableArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableBucketArn\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableBucketArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableName\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableName = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"TableNamespace\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TableNamespace = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentServerSideEncryptionByDefault(v **types.ServerSideEncryptionByDefault, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ServerSideEncryptionByDefault\n\tif *v == nil {\n\t\tsv = &types.ServerSideEncryptionByDefault{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"KMSMasterKeyID\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.KMSMasterKeyID = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SSEAlgorithm\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.SSEAlgorithm = types.ServerSideEncryption(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentServerSideEncryptionConfiguration(v **types.ServerSideEncryptionConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ServerSideEncryptionConfiguration\n\tif *v == nil {\n\t\tsv = &types.ServerSideEncryptionConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Rule\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentServerSideEncryptionRulesUnwrapped(&sv.Rules, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentServerSideEncryptionRule(v **types.ServerSideEncryptionRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.ServerSideEncryptionRule\n\tif *v == nil {\n\t\tsv = &types.ServerSideEncryptionRule{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ApplyServerSideEncryptionByDefault\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentServerSideEncryptionByDefault(&sv.ApplyServerSideEncryptionByDefault, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BlockedEncryptionTypes\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentBlockedEncryptionTypes(&sv.BlockedEncryptionTypes, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"BucketKeyEnabled\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv, err := strconv.ParseBool(string(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"expected BucketKeyEnabled to be of type *bool, got %T instead\", val)\n\t\t\t\t}\n\t\t\t\tsv.BucketKeyEnabled = ptr.Bool(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentServerSideEncryptionRules(v *[]types.ServerSideEncryptionRule, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.ServerSideEncryptionRule\n\tif *v == nil {\n\t\tsv = make([]types.ServerSideEncryptionRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.ServerSideEncryptionRule\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentServerSideEncryptionRule(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentServerSideEncryptionRulesUnwrapped(v *[]types.ServerSideEncryptionRule, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.ServerSideEncryptionRule\n\tif *v == nil {\n\t\tsv = make([]types.ServerSideEncryptionRule, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.ServerSideEncryptionRule\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentServerSideEncryptionRule(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentSessionCredentials(v **types.SessionCredentials, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.SessionCredentials\n\tif *v == nil {\n\t\tsv = &types.SessionCredentials{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessKeyId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.AccessKeyId = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Expiration\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Expiration = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SecretAccessKey\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.SecretAccessKey = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SessionToken\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.SessionToken = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentSimplePrefix(v **types.SimplePrefix, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.SimplePrefix\n\tif *v == nil {\n\t\tsv = &types.SimplePrefix{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentSourceSelectionCriteria(v **types.SourceSelectionCriteria, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.SourceSelectionCriteria\n\tif *v == nil {\n\t\tsv = &types.SourceSelectionCriteria{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"ReplicaModifications\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentReplicaModifications(&sv.ReplicaModifications, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SseKmsEncryptedObjects\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentSseKmsEncryptedObjects(&sv.SseKmsEncryptedObjects, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentSSEKMS(v **types.SSEKMS, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.SSEKMS\n\tif *v == nil {\n\t\tsv = &types.SSEKMS{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"KeyId\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.KeyId = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentSseKmsEncryptedObjects(v **types.SseKmsEncryptedObjects, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.SseKmsEncryptedObjects\n\tif *v == nil {\n\t\tsv = &types.SseKmsEncryptedObjects{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Status\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Status = types.SseKmsEncryptedObjectsStatus(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentSSES3(v **types.SSES3, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.SSES3\n\tif *v == nil {\n\t\tsv = &types.SSES3{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentStorageClassAnalysis(v **types.StorageClassAnalysis, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.StorageClassAnalysis\n\tif *v == nil {\n\t\tsv = &types.StorageClassAnalysis{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"DataExport\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentStorageClassAnalysisDataExport(&sv.DataExport, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentStorageClassAnalysisDataExport(v **types.StorageClassAnalysisDataExport, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.StorageClassAnalysisDataExport\n\tif *v == nil {\n\t\tsv = &types.StorageClassAnalysisDataExport{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Destination\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentAnalyticsExportDestination(&sv.Destination, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"OutputSchemaVersion\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.OutputSchemaVersion = types.StorageClassAnalysisSchemaVersion(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTag(v **types.Tag, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Tag\n\tif *v == nil {\n\t\tsv = &types.Tag{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Key\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Key = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Value\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Value = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTagSet(v *[]types.Tag, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Tag\n\tif *v == nil {\n\t\tsv = make([]types.Tag, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Tag\", t.Name.Local):\n\t\t\tvar col types.Tag\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentTag(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTagSetUnwrapped(v *[]types.Tag, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Tag\n\tif *v == nil {\n\t\tsv = make([]types.Tag, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Tag\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentTag(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentTargetGrant(v **types.TargetGrant, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.TargetGrant\n\tif *v == nil {\n\t\tsv = &types.TargetGrant{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Grantee\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentGrantee(&sv.Grantee, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Permission\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Permission = types.BucketLogsPermission(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTargetGrants(v *[]types.TargetGrant, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.TargetGrant\n\tif *v == nil {\n\t\tsv = make([]types.TargetGrant, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Grant\", t.Name.Local):\n\t\t\tvar col types.TargetGrant\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentTargetGrant(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTargetGrantsUnwrapped(v *[]types.TargetGrant, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.TargetGrant\n\tif *v == nil {\n\t\tsv = make([]types.TargetGrant, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.TargetGrant\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentTargetGrant(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentTargetObjectKeyFormat(v **types.TargetObjectKeyFormat, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.TargetObjectKeyFormat\n\tif *v == nil {\n\t\tsv = &types.TargetObjectKeyFormat{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"PartitionedPrefix\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentPartitionedPrefix(&sv.PartitionedPrefix, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"SimplePrefix\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentSimplePrefix(&sv.SimplePrefix, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTiering(v **types.Tiering, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Tiering\n\tif *v == nil {\n\t\tsv = &types.Tiering{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"AccessTier\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.AccessTier = types.IntelligentTieringAccessTier(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Days\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Days = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTieringList(v *[]types.Tiering, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Tiering\n\tif *v == nil {\n\t\tsv = make([]types.Tiering, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.Tiering\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentTiering(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTieringListUnwrapped(v *[]types.Tiering, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Tiering\n\tif *v == nil {\n\t\tsv = make([]types.Tiering, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Tiering\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentTiering(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentTooManyParts(v **types.TooManyParts, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.TooManyParts\n\tif *v == nil {\n\t\tsv = &types.TooManyParts{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTopicConfiguration(v **types.TopicConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.TopicConfiguration\n\tif *v == nil {\n\t\tsv = &types.TopicConfiguration{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Event\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentEventListUnwrapped(&sv.Events, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Filter\", t.Name.Local):\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tif err := awsRestxml_deserializeDocumentNotificationConfigurationFilter(&sv.Filter, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Id\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.Id = ptr.String(xtv)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Topic\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.TopicArn = ptr.String(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTopicConfigurationList(v *[]types.TopicConfiguration, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.TopicConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.TopicConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.TopicConfiguration\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentTopicConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTopicConfigurationListUnwrapped(v *[]types.TopicConfiguration, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.TopicConfiguration\n\tif *v == nil {\n\t\tsv = make([]types.TopicConfiguration, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.TopicConfiguration\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentTopicConfiguration(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\nfunc awsRestxml_deserializeDocumentTransition(v **types.Transition, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv *types.Transition\n\tif *v == nil {\n\t\tsv = &types.Transition{}\n\t} else {\n\t\tsv = *v\n\t}\n\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\toriginalDecoder := decoder\n\t\tdecoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)\n\t\tswitch {\n\t\tcase strings.EqualFold(\"Date\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tt, err := smithytime.ParseDateTime(xtv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Date = ptr.Time(t)\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"Days\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\ti64, err := strconv.ParseInt(xtv, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsv.Days = ptr.Int32(int32(i64))\n\t\t\t}\n\n\t\tcase strings.EqualFold(\"StorageClass\", t.Name.Local):\n\t\t\tval, err := decoder.Value()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t{\n\t\t\t\txtv := string(val)\n\t\t\t\tsv.StorageClass = types.TransitionStorageClass(xtv)\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Do nothing and ignore the unexpected tag element\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTransitionList(v *[]types.Transition, decoder smithyxml.NodeDecoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unexpected nil of type %T\", v)\n\t}\n\tvar sv []types.Transition\n\tif *v == nil {\n\t\tsv = make([]types.Transition, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\toriginalDecoder := decoder\n\tfor {\n\t\tt, done, err := decoder.Token()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase strings.EqualFold(\"member\", t.Name.Local):\n\t\t\tvar col types.Transition\n\t\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\t\tdestAddr := &col\n\t\t\tif err := awsRestxml_deserializeDocumentTransition(&destAddr, nodeDecoder); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcol = *destAddr\n\t\t\tsv = append(sv, col)\n\n\t\tdefault:\n\t\t\terr = decoder.Decoder.Skip()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t\tdecoder = originalDecoder\n\t}\n\t*v = sv\n\treturn nil\n}\n\nfunc awsRestxml_deserializeDocumentTransitionListUnwrapped(v *[]types.Transition, decoder smithyxml.NodeDecoder) error {\n\tvar sv []types.Transition\n\tif *v == nil {\n\t\tsv = make([]types.Transition, 0)\n\t} else {\n\t\tsv = *v\n\t}\n\n\tswitch {\n\tdefault:\n\t\tvar mv types.Transition\n\t\tt := decoder.StartEl\n\t\t_ = t\n\t\tnodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)\n\t\tdestAddr := &mv\n\t\tif err := awsRestxml_deserializeDocumentTransition(&destAddr, nodeDecoder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv = *destAddr\n\t\tsv = append(sv, mv)\n\t}\n\t*v = sv\n\treturn nil\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/generated.json",
        "content": "{\n    \"dependencies\": {\n        \"github.com/aws/aws-sdk-go-v2\": \"v1.4.0\",\n        \"github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream\": \"v0.0.0-00010101000000-000000000000\",\n        \"github.com/aws/aws-sdk-go-v2/internal/configsources\": \"v0.0.0-00010101000000-000000000000\",\n        \"github.com/aws/aws-sdk-go-v2/internal/endpoints/v2\": \"v2.0.0-00010101000000-000000000000\",\n        \"github.com/aws/aws-sdk-go-v2/internal/v4a\": \"v0.0.0-00010101000000-000000000000\",\n        \"github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding\": \"v1.0.5\",\n        \"github.com/aws/aws-sdk-go-v2/service/internal/checksum\": \"v0.0.0-00010101000000-000000000000\",\n        \"github.com/aws/aws-sdk-go-v2/service/internal/presigned-url\": \"v1.0.7\",\n        \"github.com/aws/aws-sdk-go-v2/service/internal/s3shared\": \"v1.2.3\",\n        \"github.com/aws/smithy-go\": \"v1.4.0\"\n    },\n    \"files\": [\n        \"api_client.go\",\n        \"api_client_test.go\",\n        \"api_op_AbortMultipartUpload.go\",\n        \"api_op_CompleteMultipartUpload.go\",\n        \"api_op_CopyObject.go\",\n        \"api_op_CreateBucket.go\",\n        \"api_op_CreateBucketMetadataConfiguration.go\",\n        \"api_op_CreateBucketMetadataTableConfiguration.go\",\n        \"api_op_CreateMultipartUpload.go\",\n        \"api_op_CreateSession.go\",\n        \"api_op_DeleteBucket.go\",\n        \"api_op_DeleteBucketAnalyticsConfiguration.go\",\n        \"api_op_DeleteBucketCors.go\",\n        \"api_op_DeleteBucketEncryption.go\",\n        \"api_op_DeleteBucketIntelligentTieringConfiguration.go\",\n        \"api_op_DeleteBucketInventoryConfiguration.go\",\n        \"api_op_DeleteBucketLifecycle.go\",\n        \"api_op_DeleteBucketMetadataConfiguration.go\",\n        \"api_op_DeleteBucketMetadataTableConfiguration.go\",\n        \"api_op_DeleteBucketMetricsConfiguration.go\",\n        \"api_op_DeleteBucketOwnershipControls.go\",\n        \"api_op_DeleteBucketPolicy.go\",\n        \"api_op_DeleteBucketReplication.go\",\n        \"api_op_DeleteBucketTagging.go\",\n        \"api_op_DeleteBucketWebsite.go\",\n        \"api_op_DeleteObject.go\",\n        \"api_op_DeleteObjectTagging.go\",\n        \"api_op_DeleteObjects.go\",\n        \"api_op_DeletePublicAccessBlock.go\",\n        \"api_op_GetBucketAbac.go\",\n        \"api_op_GetBucketAccelerateConfiguration.go\",\n        \"api_op_GetBucketAcl.go\",\n        \"api_op_GetBucketAnalyticsConfiguration.go\",\n        \"api_op_GetBucketCors.go\",\n        \"api_op_GetBucketEncryption.go\",\n        \"api_op_GetBucketIntelligentTieringConfiguration.go\",\n        \"api_op_GetBucketInventoryConfiguration.go\",\n        \"api_op_GetBucketLifecycleConfiguration.go\",\n        \"api_op_GetBucketLocation.go\",\n        \"api_op_GetBucketLogging.go\",\n        \"api_op_GetBucketMetadataConfiguration.go\",\n        \"api_op_GetBucketMetadataTableConfiguration.go\",\n        \"api_op_GetBucketMetricsConfiguration.go\",\n        \"api_op_GetBucketNotificationConfiguration.go\",\n        \"api_op_GetBucketOwnershipControls.go\",\n        \"api_op_GetBucketPolicy.go\",\n        \"api_op_GetBucketPolicyStatus.go\",\n        \"api_op_GetBucketReplication.go\",\n        \"api_op_GetBucketRequestPayment.go\",\n        \"api_op_GetBucketTagging.go\",\n        \"api_op_GetBucketVersioning.go\",\n        \"api_op_GetBucketWebsite.go\",\n        \"api_op_GetObject.go\",\n        \"api_op_GetObjectAcl.go\",\n        \"api_op_GetObjectAttributes.go\",\n        \"api_op_GetObjectLegalHold.go\",\n        \"api_op_GetObjectLockConfiguration.go\",\n        \"api_op_GetObjectRetention.go\",\n        \"api_op_GetObjectTagging.go\",\n        \"api_op_GetObjectTorrent.go\",\n        \"api_op_GetPublicAccessBlock.go\",\n        \"api_op_HeadBucket.go\",\n        \"api_op_HeadObject.go\",\n        \"api_op_ListBucketAnalyticsConfigurations.go\",\n        \"api_op_ListBucketIntelligentTieringConfigurations.go\",\n        \"api_op_ListBucketInventoryConfigurations.go\",\n        \"api_op_ListBucketMetricsConfigurations.go\",\n        \"api_op_ListBuckets.go\",\n        \"api_op_ListDirectoryBuckets.go\",\n        \"api_op_ListMultipartUploads.go\",\n        \"api_op_ListObjectVersions.go\",\n        \"api_op_ListObjects.go\",\n        \"api_op_ListObjectsV2.go\",\n        \"api_op_ListParts.go\",\n        \"api_op_PutBucketAbac.go\",\n        \"api_op_PutBucketAccelerateConfiguration.go\",\n        \"api_op_PutBucketAcl.go\",\n        \"api_op_PutBucketAnalyticsConfiguration.go\",\n        \"api_op_PutBucketCors.go\",\n        \"api_op_PutBucketEncryption.go\",\n        \"api_op_PutBucketIntelligentTieringConfiguration.go\",\n        \"api_op_PutBucketInventoryConfiguration.go\",\n        \"api_op_PutBucketLifecycleConfiguration.go\",\n        \"api_op_PutBucketLogging.go\",\n        \"api_op_PutBucketMetricsConfiguration.go\",\n        \"api_op_PutBucketNotificationConfiguration.go\",\n        \"api_op_PutBucketOwnershipControls.go\",\n        \"api_op_PutBucketPolicy.go\",\n        \"api_op_PutBucketReplication.go\",\n        \"api_op_PutBucketRequestPayment.go\",\n        \"api_op_PutBucketTagging.go\",\n        \"api_op_PutBucketVersioning.go\",\n        \"api_op_PutBucketWebsite.go\",\n        \"api_op_PutObject.go\",\n        \"api_op_PutObjectAcl.go\",\n        \"api_op_PutObjectLegalHold.go\",\n        \"api_op_PutObjectLockConfiguration.go\",\n        \"api_op_PutObjectRetention.go\",\n        \"api_op_PutObjectTagging.go\",\n        \"api_op_PutPublicAccessBlock.go\",\n        \"api_op_RenameObject.go\",\n        \"api_op_RestoreObject.go\",\n        \"api_op_SelectObjectContent.go\",\n        \"api_op_UpdateBucketMetadataInventoryTableConfiguration.go\",\n        \"api_op_UpdateBucketMetadataJournalTableConfiguration.go\",\n        \"api_op_UploadPart.go\",\n        \"api_op_UploadPartCopy.go\",\n        \"api_op_WriteGetObjectResponse.go\",\n        \"auth.go\",\n        \"deserializers.go\",\n        \"doc.go\",\n        \"endpoints.go\",\n        \"endpoints_config_test.go\",\n        \"endpoints_test.go\",\n        \"eventstream.go\",\n        \"generated.json\",\n        \"internal/endpoints/endpoints.go\",\n        \"internal/endpoints/endpoints_test.go\",\n        \"options.go\",\n        \"protocol_test.go\",\n        \"serializers.go\",\n        \"snapshot_test.go\",\n        \"sra_operation_order_test.go\",\n        \"types/enums.go\",\n        \"types/errors.go\",\n        \"types/types.go\",\n        \"types/types_exported_test.go\",\n        \"validators.go\"\n    ],\n    \"go\": \"1.23\",\n    \"module\": \"github.com/aws/aws-sdk-go-v2/service/s3\",\n    \"unstable\": false\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/go_module_metadata.go",
        "content": "// Code generated by internal/repotools/cmd/updatemodulemeta DO NOT EDIT.\n\npackage s3\n\n// goModuleVersion is the tagged release for this module\nconst goModuleVersion = \"1.92.0\"\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/serializers.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\tsmithy \"github.com/aws/smithy-go\"\n\t\"github.com/aws/smithy-go/encoding/httpbinding\"\n\tsmithyxml \"github.com/aws/smithy-go/encoding/xml\"\n\t\"github.com/aws/smithy-go/middleware\"\n\tsmithytime \"github.com/aws/smithy-go/time\"\n\t\"github.com/aws/smithy-go/tracing\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype awsRestxml_serializeOpAbortMultipartUpload struct {\n}\n\nfunc (*awsRestxml_serializeOpAbortMultipartUpload) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpAbortMultipartUpload) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*AbortMultipartUploadInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=AbortMultipartUpload\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsAbortMultipartUploadInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsAbortMultipartUploadInput(v *AbortMultipartUploadInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.IfMatchInitiatedTime != nil {\n\t\tlocationName := \"X-Amz-If-Match-Initiated-Time\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.IfMatchInitiatedTime))\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.UploadId != nil {\n\t\tencoder.SetQuery(\"uploadId\").String(*v.UploadId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCompleteMultipartUpload struct {\n}\n\nfunc (*awsRestxml_serializeOpCompleteMultipartUpload) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCompleteMultipartUpload) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CompleteMultipartUploadInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCompleteMultipartUploadInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.MultipartUpload != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CompleteMultipartUpload\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentCompletedMultipartUpload(input.MultipartUpload, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCompleteMultipartUploadInput(v *CompleteMultipartUploadInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ChecksumCRC32 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc32\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32)\n\t}\n\n\tif v.ChecksumCRC32C != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc32c\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32C)\n\t}\n\n\tif v.ChecksumCRC64NVME != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc64nvme\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC64NVME)\n\t}\n\n\tif v.ChecksumSHA1 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Sha1\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA1)\n\t}\n\n\tif v.ChecksumSHA256 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Sha256\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA256)\n\t}\n\n\tif len(v.ChecksumType) > 0 {\n\t\tlocationName := \"X-Amz-Checksum-Type\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumType))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.IfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfMatch)\n\t}\n\n\tif v.IfNoneMatch != nil {\n\t\tlocationName := \"If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfNoneMatch)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.MpuObjectSize != nil {\n\t\tlocationName := \"X-Amz-Mp-Object-Size\"\n\t\tencoder.SetHeader(locationName).Long(*v.MpuObjectSize)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.UploadId != nil {\n\t\tencoder.SetQuery(\"uploadId\").String(*v.UploadId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCopyObject struct {\n}\n\nfunc (*awsRestxml_serializeOpCopyObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCopyObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CopyObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=CopyObject\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCopyObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCopyObjectInput(v *CopyObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ACL) > 0 {\n\t\tlocationName := \"X-Amz-Acl\"\n\t\tencoder.SetHeader(locationName).String(string(v.ACL))\n\t}\n\n\tif v.BucketKeyEnabled != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Bucket-Key-Enabled\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BucketKeyEnabled)\n\t}\n\n\tif v.CacheControl != nil {\n\t\tlocationName := \"Cache-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.CacheControl)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentDisposition != nil {\n\t\tlocationName := \"Content-Disposition\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentDisposition)\n\t}\n\n\tif v.ContentEncoding != nil {\n\t\tlocationName := \"Content-Encoding\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentEncoding)\n\t}\n\n\tif v.ContentLanguage != nil {\n\t\tlocationName := \"Content-Language\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentLanguage)\n\t}\n\n\tif v.ContentType != nil {\n\t\tlocationName := \"Content-Type\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentType)\n\t}\n\n\tif v.CopySource != nil {\n\t\tlocationName := \"X-Amz-Copy-Source\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySource)\n\t}\n\n\tif v.CopySourceIfMatch != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceIfMatch)\n\t}\n\n\tif v.CopySourceIfModifiedSince != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-Modified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.CopySourceIfModifiedSince))\n\t}\n\n\tif v.CopySourceIfNoneMatch != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceIfNoneMatch)\n\t}\n\n\tif v.CopySourceIfUnmodifiedSince != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-Unmodified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.CopySourceIfUnmodifiedSince))\n\t}\n\n\tif v.CopySourceSSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceSSECustomerAlgorithm)\n\t}\n\n\tif v.CopySourceSSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceSSECustomerKey)\n\t}\n\n\tif v.CopySourceSSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceSSECustomerKeyMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.ExpectedSourceBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Source-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedSourceBucketOwner)\n\t}\n\n\tif v.Expires != nil {\n\t\tlocationName := \"Expires\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.Expires))\n\t}\n\n\tif v.GrantFullControl != nil {\n\t\tlocationName := \"X-Amz-Grant-Full-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantFullControl)\n\t}\n\n\tif v.GrantRead != nil {\n\t\tlocationName := \"X-Amz-Grant-Read\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantRead)\n\t}\n\n\tif v.GrantReadACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Read-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantReadACP)\n\t}\n\n\tif v.GrantWriteACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Write-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWriteACP)\n\t}\n\n\tif v.IfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfMatch)\n\t}\n\n\tif v.IfNoneMatch != nil {\n\t\tlocationName := \"If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfNoneMatch)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.Metadata != nil {\n\t\thv := encoder.Headers(\"X-Amz-Meta-\")\n\t\tfor mapKey, mapVal := range v.Metadata {\n\t\t\thv.SetHeader(http.CanonicalHeaderKey(mapKey)).String(mapVal)\n\t\t}\n\t}\n\n\tif len(v.MetadataDirective) > 0 {\n\t\tlocationName := \"X-Amz-Metadata-Directive\"\n\t\tencoder.SetHeader(locationName).String(string(v.MetadataDirective))\n\t}\n\n\tif len(v.ObjectLockLegalHoldStatus) > 0 {\n\t\tlocationName := \"X-Amz-Object-Lock-Legal-Hold\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockLegalHoldStatus))\n\t}\n\n\tif len(v.ObjectLockMode) > 0 {\n\t\tlocationName := \"X-Amz-Object-Lock-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockMode))\n\t}\n\n\tif v.ObjectLockRetainUntilDate != nil {\n\t\tlocationName := \"X-Amz-Object-Lock-Retain-Until-Date\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatDateTime(*v.ObjectLockRetainUntilDate))\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif len(v.ServerSideEncryption) > 0 {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption\"\n\t\tencoder.SetHeader(locationName).String(string(v.ServerSideEncryption))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.SSEKMSEncryptionContext != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Context\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSEncryptionContext)\n\t}\n\n\tif v.SSEKMSKeyId != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Aws-Kms-Key-Id\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSKeyId)\n\t}\n\n\tif len(v.StorageClass) > 0 {\n\t\tlocationName := \"X-Amz-Storage-Class\"\n\t\tencoder.SetHeader(locationName).String(string(v.StorageClass))\n\t}\n\n\tif v.Tagging != nil {\n\t\tlocationName := \"X-Amz-Tagging\"\n\t\tencoder.SetHeader(locationName).String(*v.Tagging)\n\t}\n\n\tif len(v.TaggingDirective) > 0 {\n\t\tlocationName := \"X-Amz-Tagging-Directive\"\n\t\tencoder.SetHeader(locationName).String(string(v.TaggingDirective))\n\t}\n\n\tif v.WebsiteRedirectLocation != nil {\n\t\tlocationName := \"X-Amz-Website-Redirect-Location\"\n\t\tencoder.SetHeader(locationName).String(*v.WebsiteRedirectLocation)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCreateBucket struct {\n}\n\nfunc (*awsRestxml_serializeOpCreateBucket) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCreateBucket) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CreateBucketInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCreateBucketInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.CreateBucketConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CreateBucketConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentCreateBucketConfiguration(input.CreateBucketConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCreateBucketInput(v *CreateBucketInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ACL) > 0 {\n\t\tlocationName := \"X-Amz-Acl\"\n\t\tencoder.SetHeader(locationName).String(string(v.ACL))\n\t}\n\n\tif v.GrantFullControl != nil {\n\t\tlocationName := \"X-Amz-Grant-Full-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantFullControl)\n\t}\n\n\tif v.GrantRead != nil {\n\t\tlocationName := \"X-Amz-Grant-Read\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantRead)\n\t}\n\n\tif v.GrantReadACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Read-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantReadACP)\n\t}\n\n\tif v.GrantWrite != nil {\n\t\tlocationName := \"X-Amz-Grant-Write\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWrite)\n\t}\n\n\tif v.GrantWriteACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Write-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWriteACP)\n\t}\n\n\tif v.ObjectLockEnabledForBucket != nil {\n\t\tlocationName := \"X-Amz-Bucket-Object-Lock-Enabled\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.ObjectLockEnabledForBucket)\n\t}\n\n\tif len(v.ObjectOwnership) > 0 {\n\t\tlocationName := \"X-Amz-Object-Ownership\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectOwnership))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCreateBucketMetadataConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpCreateBucketMetadataConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCreateBucketMetadataConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CreateBucketMetadataConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCreateBucketMetadataConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.MetadataConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"MetadataConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentMetadataConfiguration(input.MetadataConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCreateBucketMetadataConfigurationInput(v *CreateBucketMetadataConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCreateBucketMetadataTableConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpCreateBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCreateBucketMetadataTableConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CreateBucketMetadataTableConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataTable\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCreateBucketMetadataTableConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.MetadataTableConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"MetadataTableConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentMetadataTableConfiguration(input.MetadataTableConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCreateBucketMetadataTableConfigurationInput(v *CreateBucketMetadataTableConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCreateMultipartUpload struct {\n}\n\nfunc (*awsRestxml_serializeOpCreateMultipartUpload) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCreateMultipartUpload) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CreateMultipartUploadInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?uploads\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCreateMultipartUploadInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCreateMultipartUploadInput(v *CreateMultipartUploadInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ACL) > 0 {\n\t\tlocationName := \"X-Amz-Acl\"\n\t\tencoder.SetHeader(locationName).String(string(v.ACL))\n\t}\n\n\tif v.BucketKeyEnabled != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Bucket-Key-Enabled\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BucketKeyEnabled)\n\t}\n\n\tif v.CacheControl != nil {\n\t\tlocationName := \"Cache-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.CacheControl)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif len(v.ChecksumType) > 0 {\n\t\tlocationName := \"X-Amz-Checksum-Type\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumType))\n\t}\n\n\tif v.ContentDisposition != nil {\n\t\tlocationName := \"Content-Disposition\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentDisposition)\n\t}\n\n\tif v.ContentEncoding != nil {\n\t\tlocationName := \"Content-Encoding\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentEncoding)\n\t}\n\n\tif v.ContentLanguage != nil {\n\t\tlocationName := \"Content-Language\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentLanguage)\n\t}\n\n\tif v.ContentType != nil {\n\t\tlocationName := \"Content-Type\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentType)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Expires != nil {\n\t\tlocationName := \"Expires\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.Expires))\n\t}\n\n\tif v.GrantFullControl != nil {\n\t\tlocationName := \"X-Amz-Grant-Full-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantFullControl)\n\t}\n\n\tif v.GrantRead != nil {\n\t\tlocationName := \"X-Amz-Grant-Read\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantRead)\n\t}\n\n\tif v.GrantReadACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Read-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantReadACP)\n\t}\n\n\tif v.GrantWriteACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Write-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWriteACP)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.Metadata != nil {\n\t\thv := encoder.Headers(\"X-Amz-Meta-\")\n\t\tfor mapKey, mapVal := range v.Metadata {\n\t\t\thv.SetHeader(http.CanonicalHeaderKey(mapKey)).String(mapVal)\n\t\t}\n\t}\n\n\tif len(v.ObjectLockLegalHoldStatus) > 0 {\n\t\tlocationName := \"X-Amz-Object-Lock-Legal-Hold\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockLegalHoldStatus))\n\t}\n\n\tif len(v.ObjectLockMode) > 0 {\n\t\tlocationName := \"X-Amz-Object-Lock-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockMode))\n\t}\n\n\tif v.ObjectLockRetainUntilDate != nil {\n\t\tlocationName := \"X-Amz-Object-Lock-Retain-Until-Date\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatDateTime(*v.ObjectLockRetainUntilDate))\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif len(v.ServerSideEncryption) > 0 {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption\"\n\t\tencoder.SetHeader(locationName).String(string(v.ServerSideEncryption))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.SSEKMSEncryptionContext != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Context\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSEncryptionContext)\n\t}\n\n\tif v.SSEKMSKeyId != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Aws-Kms-Key-Id\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSKeyId)\n\t}\n\n\tif len(v.StorageClass) > 0 {\n\t\tlocationName := \"X-Amz-Storage-Class\"\n\t\tencoder.SetHeader(locationName).String(string(v.StorageClass))\n\t}\n\n\tif v.Tagging != nil {\n\t\tlocationName := \"X-Amz-Tagging\"\n\t\tencoder.SetHeader(locationName).String(*v.Tagging)\n\t}\n\n\tif v.WebsiteRedirectLocation != nil {\n\t\tlocationName := \"X-Amz-Website-Redirect-Location\"\n\t\tencoder.SetHeader(locationName).String(*v.WebsiteRedirectLocation)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpCreateSession struct {\n}\n\nfunc (*awsRestxml_serializeOpCreateSession) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpCreateSession) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*CreateSessionInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?session\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsCreateSessionInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsCreateSessionInput(v *CreateSessionInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.BucketKeyEnabled != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Bucket-Key-Enabled\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BucketKeyEnabled)\n\t}\n\n\tif len(v.ServerSideEncryption) > 0 {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption\"\n\t\tencoder.SetHeader(locationName).String(string(v.ServerSideEncryption))\n\t}\n\n\tif len(v.SessionMode) > 0 {\n\t\tlocationName := \"X-Amz-Create-Session-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.SessionMode))\n\t}\n\n\tif v.SSEKMSEncryptionContext != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Context\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSEncryptionContext)\n\t}\n\n\tif v.SSEKMSKeyId != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Aws-Kms-Key-Id\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSKeyId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucket struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucket) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucket) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketInput(v *DeleteBucketInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketAnalyticsConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketAnalyticsConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketAnalyticsConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?analytics\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketAnalyticsConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketAnalyticsConfigurationInput(v *DeleteBucketAnalyticsConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketCors struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketCors) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketCors) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketCorsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?cors\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketCorsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketCorsInput(v *DeleteBucketCorsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketEncryption struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketEncryption) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketEncryption) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketEncryptionInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?encryption\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketEncryptionInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketEncryptionInput(v *DeleteBucketEncryptionInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketIntelligentTieringConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketIntelligentTieringConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?intelligent-tiering\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketIntelligentTieringConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketIntelligentTieringConfigurationInput(v *DeleteBucketIntelligentTieringConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketInventoryConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketInventoryConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketInventoryConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketInventoryConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?inventory\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketInventoryConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketInventoryConfigurationInput(v *DeleteBucketInventoryConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketLifecycle struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketLifecycle) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketLifecycle) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketLifecycleInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?lifecycle\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketLifecycleInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketLifecycleInput(v *DeleteBucketLifecycleInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketMetadataConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketMetadataConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketMetadataConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketMetadataConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketMetadataConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketMetadataConfigurationInput(v *DeleteBucketMetadataConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketMetadataTableConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketMetadataTableConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketMetadataTableConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataTable\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketMetadataTableConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketMetadataTableConfigurationInput(v *DeleteBucketMetadataTableConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketMetricsConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketMetricsConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketMetricsConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketMetricsConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metrics\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketMetricsConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketMetricsConfigurationInput(v *DeleteBucketMetricsConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketOwnershipControls struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketOwnershipControls) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketOwnershipControls) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketOwnershipControlsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?ownershipControls\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketOwnershipControlsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketOwnershipControlsInput(v *DeleteBucketOwnershipControlsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketPolicy struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketPolicy) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketPolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketPolicyInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?policy\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketPolicyInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketPolicyInput(v *DeleteBucketPolicyInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketReplication struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketReplication) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketReplication) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketReplicationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?replication\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketReplicationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketReplicationInput(v *DeleteBucketReplicationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketTagging struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketTagging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketTaggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?tagging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketTaggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketTaggingInput(v *DeleteBucketTaggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteBucketWebsite struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteBucketWebsite) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteBucketWebsite) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteBucketWebsiteInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?website\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteBucketWebsiteInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteBucketWebsiteInput(v *DeleteBucketWebsiteInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteObject struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=DeleteObject\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteObjectInput(v *DeleteObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.BypassGovernanceRetention != nil {\n\t\tlocationName := \"X-Amz-Bypass-Governance-Retention\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BypassGovernanceRetention)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.IfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfMatch)\n\t}\n\n\tif v.IfMatchLastModifiedTime != nil {\n\t\tlocationName := \"X-Amz-If-Match-Last-Modified-Time\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.IfMatchLastModifiedTime))\n\t}\n\n\tif v.IfMatchSize != nil {\n\t\tlocationName := \"X-Amz-If-Match-Size\"\n\t\tencoder.SetHeader(locationName).Long(*v.IfMatchSize)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.MFA != nil {\n\t\tlocationName := \"X-Amz-Mfa\"\n\t\tencoder.SetHeader(locationName).String(*v.MFA)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteObjects struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteObjects) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteObjects) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteObjectsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?delete\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteObjectsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.Delete != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Delete\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentDelete(input.Delete, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteObjectsInput(v *DeleteObjectsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.BypassGovernanceRetention != nil {\n\t\tlocationName := \"X-Amz-Bypass-Governance-Retention\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BypassGovernanceRetention)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.MFA != nil {\n\t\tlocationName := \"X-Amz-Mfa\"\n\t\tencoder.SetHeader(locationName).String(*v.MFA)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeleteObjectTagging struct {\n}\n\nfunc (*awsRestxml_serializeOpDeleteObjectTagging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeleteObjectTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeleteObjectTaggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?tagging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeleteObjectTaggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeleteObjectTaggingInput(v *DeleteObjectTaggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpDeletePublicAccessBlock struct {\n}\n\nfunc (*awsRestxml_serializeOpDeletePublicAccessBlock) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpDeletePublicAccessBlock) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*DeletePublicAccessBlockInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?publicAccessBlock\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"DELETE\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsDeletePublicAccessBlockInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsDeletePublicAccessBlockInput(v *DeletePublicAccessBlockInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketAbac struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketAbac) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketAbac) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketAbacInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?abac\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketAbacInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketAbacInput(v *GetBucketAbacInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketAccelerateConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketAccelerateConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketAccelerateConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketAccelerateConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?accelerate\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketAccelerateConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketAccelerateConfigurationInput(v *GetBucketAccelerateConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketAcl struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketAcl) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketAcl) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketAclInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?acl\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketAclInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketAclInput(v *GetBucketAclInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketAnalyticsConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketAnalyticsConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketAnalyticsConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?analytics&x-id=GetBucketAnalyticsConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketAnalyticsConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketAnalyticsConfigurationInput(v *GetBucketAnalyticsConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketCors struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketCors) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketCors) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketCorsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?cors\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketCorsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketCorsInput(v *GetBucketCorsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketEncryption struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketEncryption) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketEncryption) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketEncryptionInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?encryption\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketEncryptionInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketEncryptionInput(v *GetBucketEncryptionInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketIntelligentTieringConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketIntelligentTieringConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?intelligent-tiering&x-id=GetBucketIntelligentTieringConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketIntelligentTieringConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketIntelligentTieringConfigurationInput(v *GetBucketIntelligentTieringConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketInventoryConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketInventoryConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketInventoryConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketInventoryConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?inventory&x-id=GetBucketInventoryConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketInventoryConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketInventoryConfigurationInput(v *GetBucketInventoryConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketLifecycleConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketLifecycleConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketLifecycleConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketLifecycleConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?lifecycle\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketLifecycleConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketLifecycleConfigurationInput(v *GetBucketLifecycleConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketLocation struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketLocation) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketLocation) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketLocationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?location\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketLocationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketLocationInput(v *GetBucketLocationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketLogging struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketLogging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketLogging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketLoggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?logging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketLoggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketLoggingInput(v *GetBucketLoggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketMetadataConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketMetadataConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketMetadataConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketMetadataConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketMetadataConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketMetadataConfigurationInput(v *GetBucketMetadataConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketMetadataTableConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketMetadataTableConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketMetadataTableConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataTable\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketMetadataTableConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketMetadataTableConfigurationInput(v *GetBucketMetadataTableConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketMetricsConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketMetricsConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketMetricsConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketMetricsConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metrics&x-id=GetBucketMetricsConfiguration\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketMetricsConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketMetricsConfigurationInput(v *GetBucketMetricsConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketNotificationConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketNotificationConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketNotificationConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketNotificationConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?notification\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketNotificationConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketNotificationConfigurationInput(v *GetBucketNotificationConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketOwnershipControls struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketOwnershipControls) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketOwnershipControls) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketOwnershipControlsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?ownershipControls\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketOwnershipControlsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketOwnershipControlsInput(v *GetBucketOwnershipControlsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketPolicy struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketPolicy) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketPolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketPolicyInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?policy\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketPolicyInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketPolicyInput(v *GetBucketPolicyInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketPolicyStatus struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketPolicyStatus) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketPolicyStatus) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketPolicyStatusInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?policyStatus\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketPolicyStatusInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketPolicyStatusInput(v *GetBucketPolicyStatusInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketReplication struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketReplication) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketReplication) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketReplicationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?replication\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketReplicationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketReplicationInput(v *GetBucketReplicationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketRequestPayment struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketRequestPayment) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketRequestPayment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketRequestPaymentInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?requestPayment\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketRequestPaymentInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketRequestPaymentInput(v *GetBucketRequestPaymentInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketTagging struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketTagging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketTaggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?tagging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketTaggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketTaggingInput(v *GetBucketTaggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketVersioning struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketVersioning) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketVersioning) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketVersioningInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?versioning\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketVersioningInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketVersioningInput(v *GetBucketVersioningInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetBucketWebsite struct {\n}\n\nfunc (*awsRestxml_serializeOpGetBucketWebsite) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetBucketWebsite) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetBucketWebsiteInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?website\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetBucketWebsiteInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetBucketWebsiteInput(v *GetBucketWebsiteInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObject struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=GetObject\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectInput(v *GetObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumMode) > 0 {\n\t\tlocationName := \"X-Amz-Checksum-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumMode))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.IfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfMatch)\n\t}\n\n\tif v.IfModifiedSince != nil {\n\t\tlocationName := \"If-Modified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.IfModifiedSince))\n\t}\n\n\tif v.IfNoneMatch != nil {\n\t\tlocationName := \"If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfNoneMatch)\n\t}\n\n\tif v.IfUnmodifiedSince != nil {\n\t\tlocationName := \"If-Unmodified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.IfUnmodifiedSince))\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.PartNumber != nil {\n\t\tencoder.SetQuery(\"partNumber\").Integer(*v.PartNumber)\n\t}\n\n\tif v.Range != nil {\n\t\tlocationName := \"Range\"\n\t\tencoder.SetHeader(locationName).String(*v.Range)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.ResponseCacheControl != nil {\n\t\tencoder.SetQuery(\"response-cache-control\").String(*v.ResponseCacheControl)\n\t}\n\n\tif v.ResponseContentDisposition != nil {\n\t\tencoder.SetQuery(\"response-content-disposition\").String(*v.ResponseContentDisposition)\n\t}\n\n\tif v.ResponseContentEncoding != nil {\n\t\tencoder.SetQuery(\"response-content-encoding\").String(*v.ResponseContentEncoding)\n\t}\n\n\tif v.ResponseContentLanguage != nil {\n\t\tencoder.SetQuery(\"response-content-language\").String(*v.ResponseContentLanguage)\n\t}\n\n\tif v.ResponseContentType != nil {\n\t\tencoder.SetQuery(\"response-content-type\").String(*v.ResponseContentType)\n\t}\n\n\tif v.ResponseExpires != nil {\n\t\tencoder.SetQuery(\"response-expires\").String(smithytime.FormatHTTPDate(*v.ResponseExpires))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectAcl struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectAcl) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectAcl) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectAclInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?acl\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectAclInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectAclInput(v *GetObjectAclInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectAttributes struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectAttributes) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectAttributes) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectAttributesInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?attributes\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectAttributesInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectAttributesInput(v *GetObjectAttributesInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.MaxParts != nil {\n\t\tlocationName := \"X-Amz-Max-Parts\"\n\t\tencoder.SetHeader(locationName).Integer(*v.MaxParts)\n\t}\n\n\tif v.ObjectAttributes != nil {\n\t\tlocationName := \"X-Amz-Object-Attributes\"\n\t\tif len(v.ObjectAttributes) == 0 {\n\t\t\tencoder.AddHeader(locationName).String(\"\")\n\t\t}\n\t\tfor i := range v.ObjectAttributes {\n\t\t\tif len(v.ObjectAttributes[i]) > 0 {\n\t\t\t\tescaped := string(v.ObjectAttributes[i])\n\t\t\t\tif strings.Index(string(v.ObjectAttributes[i]), `,`) != -1 || strings.Index(string(v.ObjectAttributes[i]), `\"`) != -1 {\n\t\t\t\t\tescaped = strconv.Quote(string(v.ObjectAttributes[i]))\n\t\t\t\t}\n\n\t\t\t\tencoder.AddHeader(locationName).String(string(escaped))\n\t\t\t}\n\t\t}\n\t}\n\n\tif v.PartNumberMarker != nil {\n\t\tlocationName := \"X-Amz-Part-Number-Marker\"\n\t\tencoder.SetHeader(locationName).String(*v.PartNumberMarker)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectLegalHold struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectLegalHold) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectLegalHold) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectLegalHoldInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?legal-hold\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectLegalHoldInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectLegalHoldInput(v *GetObjectLegalHoldInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectLockConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectLockConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectLockConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectLockConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?object-lock\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectLockConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectLockConfigurationInput(v *GetObjectLockConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectRetention struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectRetention) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectRetention) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectRetentionInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?retention\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectRetentionInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectRetentionInput(v *GetObjectRetentionInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectTagging struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectTagging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectTaggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?tagging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectTaggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectTaggingInput(v *GetObjectTaggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetObjectTorrent struct {\n}\n\nfunc (*awsRestxml_serializeOpGetObjectTorrent) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetObjectTorrent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetObjectTorrentInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?torrent\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetObjectTorrentInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetObjectTorrentInput(v *GetObjectTorrentInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpGetPublicAccessBlock struct {\n}\n\nfunc (*awsRestxml_serializeOpGetPublicAccessBlock) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpGetPublicAccessBlock) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*GetPublicAccessBlockInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?publicAccessBlock\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsGetPublicAccessBlockInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsGetPublicAccessBlockInput(v *GetPublicAccessBlockInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpHeadBucket struct {\n}\n\nfunc (*awsRestxml_serializeOpHeadBucket) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpHeadBucket) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*HeadBucketInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"HEAD\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsHeadBucketInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsHeadBucketInput(v *HeadBucketInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpHeadObject struct {\n}\n\nfunc (*awsRestxml_serializeOpHeadObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpHeadObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*HeadObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"HEAD\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsHeadObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsHeadObjectInput(v *HeadObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumMode) > 0 {\n\t\tlocationName := \"X-Amz-Checksum-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumMode))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.IfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfMatch)\n\t}\n\n\tif v.IfModifiedSince != nil {\n\t\tlocationName := \"If-Modified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.IfModifiedSince))\n\t}\n\n\tif v.IfNoneMatch != nil {\n\t\tlocationName := \"If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfNoneMatch)\n\t}\n\n\tif v.IfUnmodifiedSince != nil {\n\t\tlocationName := \"If-Unmodified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.IfUnmodifiedSince))\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.PartNumber != nil {\n\t\tencoder.SetQuery(\"partNumber\").Integer(*v.PartNumber)\n\t}\n\n\tif v.Range != nil {\n\t\tlocationName := \"Range\"\n\t\tencoder.SetHeader(locationName).String(*v.Range)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.ResponseCacheControl != nil {\n\t\tencoder.SetQuery(\"response-cache-control\").String(*v.ResponseCacheControl)\n\t}\n\n\tif v.ResponseContentDisposition != nil {\n\t\tencoder.SetQuery(\"response-content-disposition\").String(*v.ResponseContentDisposition)\n\t}\n\n\tif v.ResponseContentEncoding != nil {\n\t\tencoder.SetQuery(\"response-content-encoding\").String(*v.ResponseContentEncoding)\n\t}\n\n\tif v.ResponseContentLanguage != nil {\n\t\tencoder.SetQuery(\"response-content-language\").String(*v.ResponseContentLanguage)\n\t}\n\n\tif v.ResponseContentType != nil {\n\t\tencoder.SetQuery(\"response-content-type\").String(*v.ResponseContentType)\n\t}\n\n\tif v.ResponseExpires != nil {\n\t\tencoder.SetQuery(\"response-expires\").String(smithytime.FormatHTTPDate(*v.ResponseExpires))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListBucketAnalyticsConfigurations struct {\n}\n\nfunc (*awsRestxml_serializeOpListBucketAnalyticsConfigurations) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListBucketAnalyticsConfigurations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListBucketAnalyticsConfigurationsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?analytics&x-id=ListBucketAnalyticsConfigurations\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListBucketAnalyticsConfigurationsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListBucketAnalyticsConfigurationsInput(v *ListBucketAnalyticsConfigurationsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListBucketIntelligentTieringConfigurations struct {\n}\n\nfunc (*awsRestxml_serializeOpListBucketIntelligentTieringConfigurations) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListBucketIntelligentTieringConfigurations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListBucketIntelligentTieringConfigurationsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?intelligent-tiering&x-id=ListBucketIntelligentTieringConfigurations\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListBucketIntelligentTieringConfigurationsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListBucketIntelligentTieringConfigurationsInput(v *ListBucketIntelligentTieringConfigurationsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListBucketInventoryConfigurations struct {\n}\n\nfunc (*awsRestxml_serializeOpListBucketInventoryConfigurations) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListBucketInventoryConfigurations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListBucketInventoryConfigurationsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?inventory&x-id=ListBucketInventoryConfigurations\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListBucketInventoryConfigurationsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListBucketInventoryConfigurationsInput(v *ListBucketInventoryConfigurationsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListBucketMetricsConfigurations struct {\n}\n\nfunc (*awsRestxml_serializeOpListBucketMetricsConfigurations) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListBucketMetricsConfigurations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListBucketMetricsConfigurationsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metrics&x-id=ListBucketMetricsConfigurations\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListBucketMetricsConfigurationsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListBucketMetricsConfigurationsInput(v *ListBucketMetricsConfigurationsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListBuckets struct {\n}\n\nfunc (*awsRestxml_serializeOpListBuckets) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListBuckets) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListBucketsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?x-id=ListBuckets\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListBucketsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListBucketsInput(v *ListBucketsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.BucketRegion != nil {\n\t\tencoder.SetQuery(\"bucket-region\").String(*v.BucketRegion)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.MaxBuckets != nil {\n\t\tencoder.SetQuery(\"max-buckets\").Integer(*v.MaxBuckets)\n\t}\n\n\tif v.Prefix != nil {\n\t\tencoder.SetQuery(\"prefix\").String(*v.Prefix)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListDirectoryBuckets struct {\n}\n\nfunc (*awsRestxml_serializeOpListDirectoryBuckets) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListDirectoryBuckets) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListDirectoryBucketsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?x-id=ListDirectoryBuckets\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListDirectoryBucketsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListDirectoryBucketsInput(v *ListDirectoryBucketsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.MaxDirectoryBuckets != nil {\n\t\tencoder.SetQuery(\"max-directory-buckets\").Integer(*v.MaxDirectoryBuckets)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListMultipartUploads struct {\n}\n\nfunc (*awsRestxml_serializeOpListMultipartUploads) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListMultipartUploads) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListMultipartUploadsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?uploads\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListMultipartUploadsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListMultipartUploadsInput(v *ListMultipartUploadsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.Delimiter != nil {\n\t\tencoder.SetQuery(\"delimiter\").String(*v.Delimiter)\n\t}\n\n\tif len(v.EncodingType) > 0 {\n\t\tencoder.SetQuery(\"encoding-type\").String(string(v.EncodingType))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.KeyMarker != nil {\n\t\tencoder.SetQuery(\"key-marker\").String(*v.KeyMarker)\n\t}\n\n\tif v.MaxUploads != nil {\n\t\tencoder.SetQuery(\"max-uploads\").Integer(*v.MaxUploads)\n\t}\n\n\tif v.Prefix != nil {\n\t\tencoder.SetQuery(\"prefix\").String(*v.Prefix)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.UploadIdMarker != nil {\n\t\tencoder.SetQuery(\"upload-id-marker\").String(*v.UploadIdMarker)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListObjects struct {\n}\n\nfunc (*awsRestxml_serializeOpListObjects) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListObjects) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListObjectsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListObjectsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListObjectsInput(v *ListObjectsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.Delimiter != nil {\n\t\tencoder.SetQuery(\"delimiter\").String(*v.Delimiter)\n\t}\n\n\tif len(v.EncodingType) > 0 {\n\t\tencoder.SetQuery(\"encoding-type\").String(string(v.EncodingType))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Marker != nil {\n\t\tencoder.SetQuery(\"marker\").String(*v.Marker)\n\t}\n\n\tif v.MaxKeys != nil {\n\t\tencoder.SetQuery(\"max-keys\").Integer(*v.MaxKeys)\n\t}\n\n\tif v.OptionalObjectAttributes != nil {\n\t\tlocationName := \"X-Amz-Optional-Object-Attributes\"\n\t\tif len(v.OptionalObjectAttributes) == 0 {\n\t\t\tencoder.AddHeader(locationName).String(\"\")\n\t\t}\n\t\tfor i := range v.OptionalObjectAttributes {\n\t\t\tif len(v.OptionalObjectAttributes[i]) > 0 {\n\t\t\t\tescaped := string(v.OptionalObjectAttributes[i])\n\t\t\t\tif strings.Index(string(v.OptionalObjectAttributes[i]), `,`) != -1 || strings.Index(string(v.OptionalObjectAttributes[i]), `\"`) != -1 {\n\t\t\t\t\tescaped = strconv.Quote(string(v.OptionalObjectAttributes[i]))\n\t\t\t\t}\n\n\t\t\t\tencoder.AddHeader(locationName).String(string(escaped))\n\t\t\t}\n\t\t}\n\t}\n\n\tif v.Prefix != nil {\n\t\tencoder.SetQuery(\"prefix\").String(*v.Prefix)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListObjectsV2 struct {\n}\n\nfunc (*awsRestxml_serializeOpListObjectsV2) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListObjectsV2) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListObjectsV2Input)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?list-type=2\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListObjectsV2Input(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListObjectsV2Input(v *ListObjectsV2Input, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ContinuationToken != nil {\n\t\tencoder.SetQuery(\"continuation-token\").String(*v.ContinuationToken)\n\t}\n\n\tif v.Delimiter != nil {\n\t\tencoder.SetQuery(\"delimiter\").String(*v.Delimiter)\n\t}\n\n\tif len(v.EncodingType) > 0 {\n\t\tencoder.SetQuery(\"encoding-type\").String(string(v.EncodingType))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.FetchOwner != nil {\n\t\tencoder.SetQuery(\"fetch-owner\").Boolean(*v.FetchOwner)\n\t}\n\n\tif v.MaxKeys != nil {\n\t\tencoder.SetQuery(\"max-keys\").Integer(*v.MaxKeys)\n\t}\n\n\tif v.OptionalObjectAttributes != nil {\n\t\tlocationName := \"X-Amz-Optional-Object-Attributes\"\n\t\tif len(v.OptionalObjectAttributes) == 0 {\n\t\t\tencoder.AddHeader(locationName).String(\"\")\n\t\t}\n\t\tfor i := range v.OptionalObjectAttributes {\n\t\t\tif len(v.OptionalObjectAttributes[i]) > 0 {\n\t\t\t\tescaped := string(v.OptionalObjectAttributes[i])\n\t\t\t\tif strings.Index(string(v.OptionalObjectAttributes[i]), `,`) != -1 || strings.Index(string(v.OptionalObjectAttributes[i]), `\"`) != -1 {\n\t\t\t\t\tescaped = strconv.Quote(string(v.OptionalObjectAttributes[i]))\n\t\t\t\t}\n\n\t\t\t\tencoder.AddHeader(locationName).String(string(escaped))\n\t\t\t}\n\t\t}\n\t}\n\n\tif v.Prefix != nil {\n\t\tencoder.SetQuery(\"prefix\").String(*v.Prefix)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.StartAfter != nil {\n\t\tencoder.SetQuery(\"start-after\").String(*v.StartAfter)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListObjectVersions struct {\n}\n\nfunc (*awsRestxml_serializeOpListObjectVersions) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListObjectVersions) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListObjectVersionsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?versions\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListObjectVersionsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListObjectVersionsInput(v *ListObjectVersionsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.Delimiter != nil {\n\t\tencoder.SetQuery(\"delimiter\").String(*v.Delimiter)\n\t}\n\n\tif len(v.EncodingType) > 0 {\n\t\tencoder.SetQuery(\"encoding-type\").String(string(v.EncodingType))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.KeyMarker != nil {\n\t\tencoder.SetQuery(\"key-marker\").String(*v.KeyMarker)\n\t}\n\n\tif v.MaxKeys != nil {\n\t\tencoder.SetQuery(\"max-keys\").Integer(*v.MaxKeys)\n\t}\n\n\tif v.OptionalObjectAttributes != nil {\n\t\tlocationName := \"X-Amz-Optional-Object-Attributes\"\n\t\tif len(v.OptionalObjectAttributes) == 0 {\n\t\t\tencoder.AddHeader(locationName).String(\"\")\n\t\t}\n\t\tfor i := range v.OptionalObjectAttributes {\n\t\t\tif len(v.OptionalObjectAttributes[i]) > 0 {\n\t\t\t\tescaped := string(v.OptionalObjectAttributes[i])\n\t\t\t\tif strings.Index(string(v.OptionalObjectAttributes[i]), `,`) != -1 || strings.Index(string(v.OptionalObjectAttributes[i]), `\"`) != -1 {\n\t\t\t\t\tescaped = strconv.Quote(string(v.OptionalObjectAttributes[i]))\n\t\t\t\t}\n\n\t\t\t\tencoder.AddHeader(locationName).String(string(escaped))\n\t\t\t}\n\t\t}\n\t}\n\n\tif v.Prefix != nil {\n\t\tencoder.SetQuery(\"prefix\").String(*v.Prefix)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionIdMarker != nil {\n\t\tencoder.SetQuery(\"version-id-marker\").String(*v.VersionIdMarker)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpListParts struct {\n}\n\nfunc (*awsRestxml_serializeOpListParts) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpListParts) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*ListPartsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=ListParts\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"GET\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsListPartsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsListPartsInput(v *ListPartsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.MaxParts != nil {\n\t\tencoder.SetQuery(\"max-parts\").Integer(*v.MaxParts)\n\t}\n\n\tif v.PartNumberMarker != nil {\n\t\tencoder.SetQuery(\"part-number-marker\").String(*v.PartNumberMarker)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.UploadId != nil {\n\t\tencoder.SetQuery(\"uploadId\").String(*v.UploadId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketAbac struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketAbac) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketAbac) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketAbacInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?abac\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketAbacInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.AbacStatus != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AbacStatus\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentAbacStatus(input.AbacStatus, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketAbacInput(v *PutBucketAbacInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketAccelerateConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketAccelerateConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketAccelerateConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketAccelerateConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?accelerate\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketAccelerateConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.AccelerateConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccelerateConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentAccelerateConfiguration(input.AccelerateConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketAccelerateConfigurationInput(v *PutBucketAccelerateConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketAcl struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketAcl) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketAcl) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketAclInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?acl\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketAclInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.AccessControlPolicy != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessControlPolicy\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentAccessControlPolicy(input.AccessControlPolicy, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketAclInput(v *PutBucketAclInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ACL) > 0 {\n\t\tlocationName := \"X-Amz-Acl\"\n\t\tencoder.SetHeader(locationName).String(string(v.ACL))\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.GrantFullControl != nil {\n\t\tlocationName := \"X-Amz-Grant-Full-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantFullControl)\n\t}\n\n\tif v.GrantRead != nil {\n\t\tlocationName := \"X-Amz-Grant-Read\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantRead)\n\t}\n\n\tif v.GrantReadACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Read-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantReadACP)\n\t}\n\n\tif v.GrantWrite != nil {\n\t\tlocationName := \"X-Amz-Grant-Write\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWrite)\n\t}\n\n\tif v.GrantWriteACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Write-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWriteACP)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketAnalyticsConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketAnalyticsConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketAnalyticsConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?analytics\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketAnalyticsConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.AnalyticsConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AnalyticsConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentAnalyticsConfiguration(input.AnalyticsConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketAnalyticsConfigurationInput(v *PutBucketAnalyticsConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketCors struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketCors) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketCors) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketCorsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?cors\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketCorsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.CORSConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CORSConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentCORSConfiguration(input.CORSConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketCorsInput(v *PutBucketCorsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketEncryption struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketEncryption) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketEncryption) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketEncryptionInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?encryption\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketEncryptionInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.ServerSideEncryptionConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ServerSideEncryptionConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketEncryptionInput(v *PutBucketEncryptionInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketIntelligentTieringConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketIntelligentTieringConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?intelligent-tiering\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketIntelligentTieringConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.IntelligentTieringConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"IntelligentTieringConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentIntelligentTieringConfiguration(input.IntelligentTieringConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketIntelligentTieringConfigurationInput(v *PutBucketIntelligentTieringConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketInventoryConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketInventoryConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketInventoryConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketInventoryConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?inventory\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketInventoryConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.InventoryConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"InventoryConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentInventoryConfiguration(input.InventoryConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketInventoryConfigurationInput(v *PutBucketInventoryConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketLifecycleConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketLifecycleConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketLifecycleConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketLifecycleConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?lifecycle\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketLifecycleConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.LifecycleConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"LifecycleConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentBucketLifecycleConfiguration(input.LifecycleConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketLifecycleConfigurationInput(v *PutBucketLifecycleConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif len(v.TransitionDefaultMinimumObjectSize) > 0 {\n\t\tlocationName := \"X-Amz-Transition-Default-Minimum-Object-Size\"\n\t\tencoder.SetHeader(locationName).String(string(v.TransitionDefaultMinimumObjectSize))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketLogging struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketLogging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketLogging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketLoggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?logging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketLoggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.BucketLoggingStatus != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BucketLoggingStatus\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentBucketLoggingStatus(input.BucketLoggingStatus, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketLoggingInput(v *PutBucketLoggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketMetricsConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketMetricsConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketMetricsConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketMetricsConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metrics\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketMetricsConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.MetricsConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"MetricsConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentMetricsConfiguration(input.MetricsConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketMetricsConfigurationInput(v *PutBucketMetricsConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Id != nil {\n\t\tencoder.SetQuery(\"id\").String(*v.Id)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketNotificationConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketNotificationConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketNotificationConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketNotificationConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?notification\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketNotificationConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.NotificationConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NotificationConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentNotificationConfiguration(input.NotificationConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketNotificationConfigurationInput(v *PutBucketNotificationConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.SkipDestinationValidation != nil {\n\t\tlocationName := \"X-Amz-Skip-Destination-Validation\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.SkipDestinationValidation)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketOwnershipControls struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketOwnershipControls) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketOwnershipControls) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketOwnershipControlsInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?ownershipControls\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketOwnershipControlsInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.OwnershipControls != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"OwnershipControls\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentOwnershipControls(input.OwnershipControls, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketOwnershipControlsInput(v *PutBucketOwnershipControlsInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketPolicy struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketPolicy) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketPolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketPolicyInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?policy\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketPolicyInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\trestEncoder.SetHeader(\"Content-Type\").String(\"text/plain\")\n\t}\n\n\tif input.Policy != nil {\n\t\tpayload := strings.NewReader(*input.Policy)\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketPolicyInput(v *PutBucketPolicyInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ConfirmRemoveSelfBucketAccess != nil {\n\t\tlocationName := \"X-Amz-Confirm-Remove-Self-Bucket-Access\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.ConfirmRemoveSelfBucketAccess)\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketReplication struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketReplication) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketReplication) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketReplicationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?replication\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketReplicationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.ReplicationConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ReplicationConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentReplicationConfiguration(input.ReplicationConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketReplicationInput(v *PutBucketReplicationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Token != nil {\n\t\tlocationName := \"X-Amz-Bucket-Object-Lock-Token\"\n\t\tencoder.SetHeader(locationName).String(*v.Token)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketRequestPayment struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketRequestPayment) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketRequestPayment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketRequestPaymentInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?requestPayment\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketRequestPaymentInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.RequestPaymentConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RequestPaymentConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentRequestPaymentConfiguration(input.RequestPaymentConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketRequestPaymentInput(v *PutBucketRequestPaymentInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketTagging struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketTagging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketTaggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?tagging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketTaggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.Tagging != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tagging\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentTagging(input.Tagging, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketTaggingInput(v *PutBucketTaggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketVersioning struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketVersioning) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketVersioning) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketVersioningInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?versioning\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketVersioningInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.VersioningConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"VersioningConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentVersioningConfiguration(input.VersioningConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketVersioningInput(v *PutBucketVersioningInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.MFA != nil {\n\t\tlocationName := \"X-Amz-Mfa\"\n\t\tencoder.SetHeader(locationName).String(*v.MFA)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutBucketWebsite struct {\n}\n\nfunc (*awsRestxml_serializeOpPutBucketWebsite) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutBucketWebsite) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutBucketWebsiteInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?website\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutBucketWebsiteInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.WebsiteConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"WebsiteConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentWebsiteConfiguration(input.WebsiteConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutBucketWebsiteInput(v *PutBucketWebsiteInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutObject struct {\n}\n\nfunc (*awsRestxml_serializeOpPutObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=PutObject\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/octet-stream\")\n\t}\n\n\tif input.Body != nil {\n\t\tpayload := input.Body\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutObjectInput(v *PutObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ACL) > 0 {\n\t\tlocationName := \"X-Amz-Acl\"\n\t\tencoder.SetHeader(locationName).String(string(v.ACL))\n\t}\n\n\tif v.BucketKeyEnabled != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Bucket-Key-Enabled\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BucketKeyEnabled)\n\t}\n\n\tif v.CacheControl != nil {\n\t\tlocationName := \"Cache-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.CacheControl)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ChecksumCRC32 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc32\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32)\n\t}\n\n\tif v.ChecksumCRC32C != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc32c\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32C)\n\t}\n\n\tif v.ChecksumCRC64NVME != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc64nvme\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC64NVME)\n\t}\n\n\tif v.ChecksumSHA1 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Sha1\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA1)\n\t}\n\n\tif v.ChecksumSHA256 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Sha256\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA256)\n\t}\n\n\tif v.ContentDisposition != nil {\n\t\tlocationName := \"Content-Disposition\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentDisposition)\n\t}\n\n\tif v.ContentEncoding != nil {\n\t\tlocationName := \"Content-Encoding\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentEncoding)\n\t}\n\n\tif v.ContentLanguage != nil {\n\t\tlocationName := \"Content-Language\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentLanguage)\n\t}\n\n\tif v.ContentLength != nil {\n\t\tlocationName := \"Content-Length\"\n\t\tencoder.SetHeader(locationName).Long(*v.ContentLength)\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ContentType != nil {\n\t\tlocationName := \"Content-Type\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentType)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Expires != nil {\n\t\tlocationName := \"Expires\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.Expires))\n\t}\n\n\tif v.GrantFullControl != nil {\n\t\tlocationName := \"X-Amz-Grant-Full-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantFullControl)\n\t}\n\n\tif v.GrantRead != nil {\n\t\tlocationName := \"X-Amz-Grant-Read\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantRead)\n\t}\n\n\tif v.GrantReadACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Read-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantReadACP)\n\t}\n\n\tif v.GrantWriteACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Write-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWriteACP)\n\t}\n\n\tif v.IfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfMatch)\n\t}\n\n\tif v.IfNoneMatch != nil {\n\t\tlocationName := \"If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.IfNoneMatch)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.Metadata != nil {\n\t\thv := encoder.Headers(\"X-Amz-Meta-\")\n\t\tfor mapKey, mapVal := range v.Metadata {\n\t\t\thv.SetHeader(http.CanonicalHeaderKey(mapKey)).String(mapVal)\n\t\t}\n\t}\n\n\tif len(v.ObjectLockLegalHoldStatus) > 0 {\n\t\tlocationName := \"X-Amz-Object-Lock-Legal-Hold\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockLegalHoldStatus))\n\t}\n\n\tif len(v.ObjectLockMode) > 0 {\n\t\tlocationName := \"X-Amz-Object-Lock-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockMode))\n\t}\n\n\tif v.ObjectLockRetainUntilDate != nil {\n\t\tlocationName := \"X-Amz-Object-Lock-Retain-Until-Date\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatDateTime(*v.ObjectLockRetainUntilDate))\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif len(v.ServerSideEncryption) > 0 {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption\"\n\t\tencoder.SetHeader(locationName).String(string(v.ServerSideEncryption))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.SSEKMSEncryptionContext != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Context\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSEncryptionContext)\n\t}\n\n\tif v.SSEKMSKeyId != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Aws-Kms-Key-Id\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSKeyId)\n\t}\n\n\tif len(v.StorageClass) > 0 {\n\t\tlocationName := \"X-Amz-Storage-Class\"\n\t\tencoder.SetHeader(locationName).String(string(v.StorageClass))\n\t}\n\n\tif v.Tagging != nil {\n\t\tlocationName := \"X-Amz-Tagging\"\n\t\tencoder.SetHeader(locationName).String(*v.Tagging)\n\t}\n\n\tif v.WebsiteRedirectLocation != nil {\n\t\tlocationName := \"X-Amz-Website-Redirect-Location\"\n\t\tencoder.SetHeader(locationName).String(*v.WebsiteRedirectLocation)\n\t}\n\n\tif v.WriteOffsetBytes != nil {\n\t\tlocationName := \"X-Amz-Write-Offset-Bytes\"\n\t\tencoder.SetHeader(locationName).Long(*v.WriteOffsetBytes)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutObjectAcl struct {\n}\n\nfunc (*awsRestxml_serializeOpPutObjectAcl) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutObjectAcl) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutObjectAclInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?acl\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutObjectAclInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.AccessControlPolicy != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessControlPolicy\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentAccessControlPolicy(input.AccessControlPolicy, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutObjectAclInput(v *PutObjectAclInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ACL) > 0 {\n\t\tlocationName := \"X-Amz-Acl\"\n\t\tencoder.SetHeader(locationName).String(string(v.ACL))\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.GrantFullControl != nil {\n\t\tlocationName := \"X-Amz-Grant-Full-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantFullControl)\n\t}\n\n\tif v.GrantRead != nil {\n\t\tlocationName := \"X-Amz-Grant-Read\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantRead)\n\t}\n\n\tif v.GrantReadACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Read-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantReadACP)\n\t}\n\n\tif v.GrantWrite != nil {\n\t\tlocationName := \"X-Amz-Grant-Write\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWrite)\n\t}\n\n\tif v.GrantWriteACP != nil {\n\t\tlocationName := \"X-Amz-Grant-Write-Acp\"\n\t\tencoder.SetHeader(locationName).String(*v.GrantWriteACP)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutObjectLegalHold struct {\n}\n\nfunc (*awsRestxml_serializeOpPutObjectLegalHold) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutObjectLegalHold) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutObjectLegalHoldInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?legal-hold\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutObjectLegalHoldInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.LegalHold != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"LegalHold\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentObjectLockLegalHold(input.LegalHold, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutObjectLegalHoldInput(v *PutObjectLegalHoldInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutObjectLockConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpPutObjectLockConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutObjectLockConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutObjectLockConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?object-lock\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutObjectLockConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.ObjectLockConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectLockConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentObjectLockConfiguration(input.ObjectLockConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutObjectLockConfigurationInput(v *PutObjectLockConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.Token != nil {\n\t\tlocationName := \"X-Amz-Bucket-Object-Lock-Token\"\n\t\tencoder.SetHeader(locationName).String(*v.Token)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutObjectRetention struct {\n}\n\nfunc (*awsRestxml_serializeOpPutObjectRetention) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutObjectRetention) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutObjectRetentionInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?retention\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutObjectRetentionInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.Retention != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Retention\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentObjectLockRetention(input.Retention, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutObjectRetentionInput(v *PutObjectRetentionInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.BypassGovernanceRetention != nil {\n\t\tlocationName := \"X-Amz-Bypass-Governance-Retention\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BypassGovernanceRetention)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutObjectTagging struct {\n}\n\nfunc (*awsRestxml_serializeOpPutObjectTagging) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutObjectTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutObjectTaggingInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?tagging\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutObjectTaggingInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.Tagging != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tagging\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentTagging(input.Tagging, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutObjectTaggingInput(v *PutObjectTaggingInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpPutPublicAccessBlock struct {\n}\n\nfunc (*awsRestxml_serializeOpPutPublicAccessBlock) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpPutPublicAccessBlock) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*PutPublicAccessBlockInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?publicAccessBlock\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsPutPublicAccessBlockInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.PublicAccessBlockConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"PublicAccessBlockConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentPublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsPutPublicAccessBlockInput(v *PutPublicAccessBlockInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpRenameObject struct {\n}\n\nfunc (*awsRestxml_serializeOpRenameObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpRenameObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*RenameObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?renameObject\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsRenameObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsRenameObjectInput(v *RenameObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ClientToken != nil {\n\t\tlocationName := \"X-Amz-Client-Token\"\n\t\tencoder.SetHeader(locationName).String(*v.ClientToken)\n\t}\n\n\tif v.DestinationIfMatch != nil {\n\t\tlocationName := \"If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.DestinationIfMatch)\n\t}\n\n\tif v.DestinationIfModifiedSince != nil {\n\t\tlocationName := \"If-Modified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.DestinationIfModifiedSince))\n\t}\n\n\tif v.DestinationIfNoneMatch != nil {\n\t\tlocationName := \"If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.DestinationIfNoneMatch)\n\t}\n\n\tif v.DestinationIfUnmodifiedSince != nil {\n\t\tlocationName := \"If-Unmodified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.DestinationIfUnmodifiedSince))\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.RenameSource != nil {\n\t\tlocationName := \"X-Amz-Rename-Source\"\n\t\tencoder.SetHeader(locationName).String(*v.RenameSource)\n\t}\n\n\tif v.SourceIfMatch != nil {\n\t\tlocationName := \"X-Amz-Rename-Source-If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.SourceIfMatch)\n\t}\n\n\tif v.SourceIfModifiedSince != nil {\n\t\tlocationName := \"X-Amz-Rename-Source-If-Modified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.SourceIfModifiedSince))\n\t}\n\n\tif v.SourceIfNoneMatch != nil {\n\t\tlocationName := \"X-Amz-Rename-Source-If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.SourceIfNoneMatch)\n\t}\n\n\tif v.SourceIfUnmodifiedSince != nil {\n\t\tlocationName := \"X-Amz-Rename-Source-If-Unmodified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.SourceIfUnmodifiedSince))\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpRestoreObject struct {\n}\n\nfunc (*awsRestxml_serializeOpRestoreObject) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpRestoreObject) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*RestoreObjectInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?restore\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsRestoreObjectInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.RestoreRequest != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RestoreRequest\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentRestoreRequest(input.RestoreRequest, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsRestoreObjectInput(v *RestoreObjectInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.VersionId != nil {\n\t\tencoder.SetQuery(\"versionId\").String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpSelectObjectContent struct {\n}\n\nfunc (*awsRestxml_serializeOpSelectObjectContent) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpSelectObjectContent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*SelectObjectContentInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?select&select-type=2\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsSelectObjectContentInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\n\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\trootAttr := []smithyxml.Attr{}\n\troot := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"SelectObjectContentRequest\",\n\t\t},\n\t\tAttr: rootAttr,\n\t}\n\troot.Attr = append(root.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\tif err := awsRestxml_serializeOpDocumentSelectObjectContentInput(input, xmlEncoder.RootElement(root)); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tif request, err = request.SetStream(bytes.NewReader(xmlEncoder.Bytes())); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsSelectObjectContentInput(v *SelectObjectContentInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\treturn nil\n}\n\nfunc awsRestxml_serializeOpDocumentSelectObjectContentInput(v *SelectObjectContentInput, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Expression != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Expression\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Expression)\n\t}\n\tif len(v.ExpressionType) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ExpressionType\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.ExpressionType))\n\t}\n\tif v.InputSerialization != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"InputSerialization\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInputSerialization(v.InputSerialization, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.OutputSerialization != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"OutputSerialization\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentOutputSerialization(v.OutputSerialization, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.RequestProgress != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RequestProgress\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentRequestProgress(v.RequestProgress, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ScanRange != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ScanRange\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentScanRange(v.ScanRange, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype awsRestxml_serializeOpUpdateBucketMetadataInventoryTableConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpUpdateBucketMetadataInventoryTableConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpUpdateBucketMetadataInventoryTableConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*UpdateBucketMetadataInventoryTableConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataInventoryTable\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsUpdateBucketMetadataInventoryTableConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.InventoryTableConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"InventoryTableConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentInventoryTableConfigurationUpdates(input.InventoryTableConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsUpdateBucketMetadataInventoryTableConfigurationInput(v *UpdateBucketMetadataInventoryTableConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpUpdateBucketMetadataJournalTableConfiguration struct {\n}\n\nfunc (*awsRestxml_serializeOpUpdateBucketMetadataJournalTableConfiguration) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpUpdateBucketMetadataJournalTableConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*UpdateBucketMetadataJournalTableConfigurationInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/?metadataJournalTable\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsUpdateBucketMetadataJournalTableConfigurationInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif input.JournalTableConfiguration != nil {\n\t\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/xml\")\n\t\t}\n\n\t\txmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))\n\t\tpayloadRootAttr := []smithyxml.Attr{}\n\t\tpayloadRoot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"JournalTableConfiguration\",\n\t\t\t},\n\t\t\tAttr: payloadRootAttr,\n\t\t}\n\t\tpayloadRoot.Attr = append(payloadRoot.Attr, smithyxml.NewNamespaceAttribute(\"\", \"http://s3.amazonaws.com/doc/2006-03-01/\"))\n\t\tif err := awsRestxml_serializeDocumentJournalTableConfigurationUpdates(input.JournalTableConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t\tpayload := bytes.NewReader(xmlEncoder.Bytes())\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsUpdateBucketMetadataJournalTableConfigurationInput(v *UpdateBucketMetadataJournalTableConfigurationInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpUploadPart struct {\n}\n\nfunc (*awsRestxml_serializeOpUploadPart) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpUploadPart) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*UploadPartInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=UploadPart\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsUploadPartInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/octet-stream\")\n\t}\n\n\tif input.Body != nil {\n\t\tpayload := input.Body\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsUploadPartInput(v *UploadPartInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif len(v.ChecksumAlgorithm) > 0 {\n\t\tlocationName := \"X-Amz-Sdk-Checksum-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(string(v.ChecksumAlgorithm))\n\t}\n\n\tif v.ChecksumCRC32 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc32\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32)\n\t}\n\n\tif v.ChecksumCRC32C != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc32c\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32C)\n\t}\n\n\tif v.ChecksumCRC64NVME != nil {\n\t\tlocationName := \"X-Amz-Checksum-Crc64nvme\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC64NVME)\n\t}\n\n\tif v.ChecksumSHA1 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Sha1\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA1)\n\t}\n\n\tif v.ChecksumSHA256 != nil {\n\t\tlocationName := \"X-Amz-Checksum-Sha256\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA256)\n\t}\n\n\tif v.ContentLength != nil {\n\t\tlocationName := \"Content-Length\"\n\t\tencoder.SetHeader(locationName).Long(*v.ContentLength)\n\t}\n\n\tif v.ContentMD5 != nil {\n\t\tlocationName := \"Content-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.PartNumber != nil {\n\t\tencoder.SetQuery(\"partNumber\").Integer(*v.PartNumber)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.UploadId != nil {\n\t\tencoder.SetQuery(\"uploadId\").String(*v.UploadId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpUploadPartCopy struct {\n}\n\nfunc (*awsRestxml_serializeOpUploadPartCopy) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpUploadPartCopy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*UploadPartCopyInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/{Key+}?x-id=UploadPartCopy\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"PUT\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsUploadPartCopyInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsUploadPartCopyInput(v *UploadPartCopyInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.CopySource != nil {\n\t\tlocationName := \"X-Amz-Copy-Source\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySource)\n\t}\n\n\tif v.CopySourceIfMatch != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceIfMatch)\n\t}\n\n\tif v.CopySourceIfModifiedSince != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-Modified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.CopySourceIfModifiedSince))\n\t}\n\n\tif v.CopySourceIfNoneMatch != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-None-Match\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceIfNoneMatch)\n\t}\n\n\tif v.CopySourceIfUnmodifiedSince != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-If-Unmodified-Since\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.CopySourceIfUnmodifiedSince))\n\t}\n\n\tif v.CopySourceRange != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Range\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceRange)\n\t}\n\n\tif v.CopySourceSSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceSSECustomerAlgorithm)\n\t}\n\n\tif v.CopySourceSSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceSSECustomerKey)\n\t}\n\n\tif v.CopySourceSSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.CopySourceSSECustomerKeyMD5)\n\t}\n\n\tif v.ExpectedBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedBucketOwner)\n\t}\n\n\tif v.ExpectedSourceBucketOwner != nil {\n\t\tlocationName := \"X-Amz-Source-Expected-Bucket-Owner\"\n\t\tencoder.SetHeader(locationName).String(*v.ExpectedSourceBucketOwner)\n\t}\n\n\tif v.Key == nil || len(*v.Key) == 0 {\n\t\treturn &smithy.SerializationError{Err: fmt.Errorf(\"input member Key must not be empty\")}\n\t}\n\tif v.Key != nil {\n\t\tif err := encoder.SetURI(\"Key\").String(*v.Key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.PartNumber != nil {\n\t\tencoder.SetQuery(\"partNumber\").Integer(*v.PartNumber)\n\t}\n\n\tif len(v.RequestPayer) > 0 {\n\t\tlocationName := \"X-Amz-Request-Payer\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestPayer))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKey != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKey)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.UploadId != nil {\n\t\tencoder.SetQuery(\"uploadId\").String(*v.UploadId)\n\t}\n\n\treturn nil\n}\n\ntype awsRestxml_serializeOpWriteGetObjectResponse struct {\n}\n\nfunc (*awsRestxml_serializeOpWriteGetObjectResponse) ID() string {\n\treturn \"OperationSerializer\"\n}\n\nfunc (m *awsRestxml_serializeOpWriteGetObjectResponse) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (\n\tout middleware.SerializeOutput, metadata middleware.Metadata, err error,\n) {\n\t_, span := tracing.StartSpan(ctx, \"OperationSerializer\")\n\tendTimer := startMetricTimer(ctx, \"client.call.serialization_duration\")\n\tdefer endTimer()\n\tdefer span.End()\n\trequest, ok := in.Request.(*smithyhttp.Request)\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown transport type %T\", in.Request)}\n\t}\n\n\tinput, ok := in.Parameters.(*WriteGetObjectResponseInput)\n\t_ = input\n\tif !ok {\n\t\treturn out, metadata, &smithy.SerializationError{Err: fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)}\n\t}\n\n\topPath, opQuery := httpbinding.SplitURI(\"/WriteGetObjectResponse\")\n\trequest.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)\n\trequest.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)\n\trequest.Method = \"POST\"\n\tvar restEncoder *httpbinding.Encoder\n\tif request.URL.RawPath == \"\" {\n\t\trestEncoder, err = httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)\n\t} else {\n\t\trequest.URL.RawPath = smithyhttp.JoinPath(request.URL.RawPath, opPath)\n\t\trestEncoder, err = httpbinding.NewEncoderWithRawPath(request.URL.Path, request.URL.RawPath, request.URL.RawQuery, request.Header)\n\t}\n\n\tif err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif err := awsRestxml_serializeOpHttpBindingsWriteGetObjectResponseInput(input, restEncoder); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\n\tif !restEncoder.HasHeader(\"Content-Type\") {\n\t\tctx = smithyhttp.SetIsContentTypeDefaultValue(ctx, true)\n\t\trestEncoder.SetHeader(\"Content-Type\").String(\"application/octet-stream\")\n\t}\n\n\tif input.Body != nil {\n\t\tpayload := input.Body\n\t\tif request, err = request.SetStream(payload); err != nil {\n\t\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t\t}\n\t}\n\n\tif request.Request, err = restEncoder.Encode(request.Request); err != nil {\n\t\treturn out, metadata, &smithy.SerializationError{Err: err}\n\t}\n\tin.Request = request\n\n\tendTimer()\n\tspan.End()\n\treturn next.HandleSerialize(ctx, in)\n}\nfunc awsRestxml_serializeOpHttpBindingsWriteGetObjectResponseInput(v *WriteGetObjectResponseInput, encoder *httpbinding.Encoder) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"unsupported serialization of nil %T\", v)\n\t}\n\n\tif v.AcceptRanges != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Accept-Ranges\"\n\t\tencoder.SetHeader(locationName).String(*v.AcceptRanges)\n\t}\n\n\tif v.BucketKeyEnabled != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Server-Side-Encryption-Bucket-Key-Enabled\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.BucketKeyEnabled)\n\t}\n\n\tif v.CacheControl != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Cache-Control\"\n\t\tencoder.SetHeader(locationName).String(*v.CacheControl)\n\t}\n\n\tif v.ChecksumCRC32 != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Checksum-Crc32\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32)\n\t}\n\n\tif v.ChecksumCRC32C != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Checksum-Crc32c\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC32C)\n\t}\n\n\tif v.ChecksumCRC64NVME != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Checksum-Crc64nvme\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumCRC64NVME)\n\t}\n\n\tif v.ChecksumSHA1 != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Checksum-Sha1\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA1)\n\t}\n\n\tif v.ChecksumSHA256 != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Checksum-Sha256\"\n\t\tencoder.SetHeader(locationName).String(*v.ChecksumSHA256)\n\t}\n\n\tif v.ContentDisposition != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Content-Disposition\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentDisposition)\n\t}\n\n\tif v.ContentEncoding != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Content-Encoding\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentEncoding)\n\t}\n\n\tif v.ContentLanguage != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Content-Language\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentLanguage)\n\t}\n\n\tif v.ContentLength != nil {\n\t\tlocationName := \"Content-Length\"\n\t\tencoder.SetHeader(locationName).Long(*v.ContentLength)\n\t}\n\n\tif v.ContentRange != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Content-Range\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentRange)\n\t}\n\n\tif v.ContentType != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Content-Type\"\n\t\tencoder.SetHeader(locationName).String(*v.ContentType)\n\t}\n\n\tif v.DeleteMarker != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Delete-Marker\"\n\t\tencoder.SetHeader(locationName).Boolean(*v.DeleteMarker)\n\t}\n\n\tif v.ErrorCode != nil {\n\t\tlocationName := \"X-Amz-Fwd-Error-Code\"\n\t\tencoder.SetHeader(locationName).String(*v.ErrorCode)\n\t}\n\n\tif v.ErrorMessage != nil {\n\t\tlocationName := \"X-Amz-Fwd-Error-Message\"\n\t\tencoder.SetHeader(locationName).String(*v.ErrorMessage)\n\t}\n\n\tif v.ETag != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Etag\"\n\t\tencoder.SetHeader(locationName).String(*v.ETag)\n\t}\n\n\tif v.Expiration != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Expiration\"\n\t\tencoder.SetHeader(locationName).String(*v.Expiration)\n\t}\n\n\tif v.Expires != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Expires\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.Expires))\n\t}\n\n\tif v.LastModified != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-Last-Modified\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatHTTPDate(*v.LastModified))\n\t}\n\n\tif v.Metadata != nil {\n\t\thv := encoder.Headers(\"X-Amz-Meta-\")\n\t\tfor mapKey, mapVal := range v.Metadata {\n\t\t\thv.SetHeader(http.CanonicalHeaderKey(mapKey)).String(mapVal)\n\t\t}\n\t}\n\n\tif v.MissingMeta != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Missing-Meta\"\n\t\tencoder.SetHeader(locationName).Integer(*v.MissingMeta)\n\t}\n\n\tif len(v.ObjectLockLegalHoldStatus) > 0 {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Object-Lock-Legal-Hold\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockLegalHoldStatus))\n\t}\n\n\tif len(v.ObjectLockMode) > 0 {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Object-Lock-Mode\"\n\t\tencoder.SetHeader(locationName).String(string(v.ObjectLockMode))\n\t}\n\n\tif v.ObjectLockRetainUntilDate != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Object-Lock-Retain-Until-Date\"\n\t\tencoder.SetHeader(locationName).String(smithytime.FormatDateTime(*v.ObjectLockRetainUntilDate))\n\t}\n\n\tif v.PartsCount != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Mp-Parts-Count\"\n\t\tencoder.SetHeader(locationName).Integer(*v.PartsCount)\n\t}\n\n\tif len(v.ReplicationStatus) > 0 {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Replication-Status\"\n\t\tencoder.SetHeader(locationName).String(string(v.ReplicationStatus))\n\t}\n\n\tif len(v.RequestCharged) > 0 {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Request-Charged\"\n\t\tencoder.SetHeader(locationName).String(string(v.RequestCharged))\n\t}\n\n\tif v.RequestRoute != nil {\n\t\tlocationName := \"X-Amz-Request-Route\"\n\t\tencoder.SetHeader(locationName).String(*v.RequestRoute)\n\t}\n\n\tif v.RequestToken != nil {\n\t\tlocationName := \"X-Amz-Request-Token\"\n\t\tencoder.SetHeader(locationName).String(*v.RequestToken)\n\t}\n\n\tif v.Restore != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Restore\"\n\t\tencoder.SetHeader(locationName).String(*v.Restore)\n\t}\n\n\tif len(v.ServerSideEncryption) > 0 {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Server-Side-Encryption\"\n\t\tencoder.SetHeader(locationName).String(string(v.ServerSideEncryption))\n\t}\n\n\tif v.SSECustomerAlgorithm != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Server-Side-Encryption-Customer-Algorithm\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerAlgorithm)\n\t}\n\n\tif v.SSECustomerKeyMD5 != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Server-Side-Encryption-Customer-Key-Md5\"\n\t\tencoder.SetHeader(locationName).String(*v.SSECustomerKeyMD5)\n\t}\n\n\tif v.SSEKMSKeyId != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Server-Side-Encryption-Aws-Kms-Key-Id\"\n\t\tencoder.SetHeader(locationName).String(*v.SSEKMSKeyId)\n\t}\n\n\tif v.StatusCode != nil {\n\t\tlocationName := \"X-Amz-Fwd-Status\"\n\t\tencoder.SetHeader(locationName).Integer(*v.StatusCode)\n\t}\n\n\tif len(v.StorageClass) > 0 {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Storage-Class\"\n\t\tencoder.SetHeader(locationName).String(string(v.StorageClass))\n\t}\n\n\tif v.TagCount != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Tagging-Count\"\n\t\tencoder.SetHeader(locationName).Integer(*v.TagCount)\n\t}\n\n\tif v.VersionId != nil {\n\t\tlocationName := \"X-Amz-Fwd-Header-X-Amz-Version-Id\"\n\t\tencoder.SetHeader(locationName).String(*v.VersionId)\n\t}\n\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAbacStatus(v *types.AbacStatus, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAbortIncompleteMultipartUpload(v *types.AbortIncompleteMultipartUpload, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.DaysAfterInitiation != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DaysAfterInitiation\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.DaysAfterInitiation)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAccelerateConfiguration(v *types.AccelerateConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAccessControlPolicy(v *types.AccessControlPolicy, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Grants != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessControlList\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentGrants(v.Grants, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Owner != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Owner\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentOwner(v.Owner, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAccessControlTranslation(v *types.AccessControlTranslation, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Owner) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Owner\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Owner))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAllowedHeaders(v []string, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(v[i])\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAllowedMethods(v []string, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(v[i])\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAllowedOrigins(v []string, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(v[i])\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAnalyticsAndOperator(v *types.AnalyticsAndOperator, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tags != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.Tags, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAnalyticsConfiguration(v *types.AnalyticsConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentAnalyticsFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\tif v.StorageClassAnalysis != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"StorageClassAnalysis\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentStorageClassAnalysis(v.StorageClassAnalysis, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAnalyticsExportDestination(v *types.AnalyticsExportDestination, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.S3BucketDestination != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"S3BucketDestination\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentAnalyticsS3BucketDestination(v.S3BucketDestination, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAnalyticsFilter(v types.AnalyticsFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tswitch uv := v.(type) {\n\tcase *types.AnalyticsFilterMemberAnd:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"And\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tif err := awsRestxml_serializeDocumentAnalyticsAndOperator(&uv.Value, av); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *types.AnalyticsFilterMemberPrefix:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tav.String(uv.Value)\n\n\tcase *types.AnalyticsFilterMemberTag:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tif err := awsRestxml_serializeDocumentTag(&uv.Value, av); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"attempted to serialize unknown member type %T for union %T\", uv, v)\n\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentAnalyticsS3BucketDestination(v *types.AnalyticsS3BucketDestination, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Bucket != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Bucket\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Bucket)\n\t}\n\tif v.BucketAccountId != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BucketAccountId\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.BucketAccountId)\n\t}\n\tif len(v.Format) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Format\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Format))\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentBlockedEncryptionTypes(v *types.BlockedEncryptionTypes, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.EncryptionType != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EncryptionType\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentEncryptionTypeList(v.EncryptionType, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentBucketInfo(v *types.BucketInfo, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.DataRedundancy) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DataRedundancy\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.DataRedundancy))\n\t}\n\tif len(v.Type) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Type\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Type))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentBucketLifecycleConfiguration(v *types.BucketLifecycleConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Rules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Rule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentLifecycleRules(v.Rules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentBucketLoggingStatus(v *types.BucketLoggingStatus, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.LoggingEnabled != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"LoggingEnabled\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentLoggingEnabled(v.LoggingEnabled, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCompletedMultipartUpload(v *types.CompletedMultipartUpload, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Parts != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Part\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentCompletedPartList(v.Parts, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCompletedPart(v *types.CompletedPart, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ChecksumCRC32 != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ChecksumCRC32\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ChecksumCRC32)\n\t}\n\tif v.ChecksumCRC32C != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ChecksumCRC32C\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ChecksumCRC32C)\n\t}\n\tif v.ChecksumCRC64NVME != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ChecksumCRC64NVME\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ChecksumCRC64NVME)\n\t}\n\tif v.ChecksumSHA1 != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ChecksumSHA1\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ChecksumSHA1)\n\t}\n\tif v.ChecksumSHA256 != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ChecksumSHA256\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ChecksumSHA256)\n\t}\n\tif v.ETag != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ETag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ETag)\n\t}\n\tif v.PartNumber != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"PartNumber\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.PartNumber)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCompletedPartList(v []types.CompletedPart, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentCompletedPart(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCondition(v *types.Condition, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.HttpErrorCodeReturnedEquals != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"HttpErrorCodeReturnedEquals\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.HttpErrorCodeReturnedEquals)\n\t}\n\tif v.KeyPrefixEquals != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"KeyPrefixEquals\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.KeyPrefixEquals)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCORSConfiguration(v *types.CORSConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.CORSRules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CORSRule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentCORSRules(v.CORSRules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCORSRule(v *types.CORSRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AllowedHeaders != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AllowedHeader\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentAllowedHeaders(v.AllowedHeaders, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.AllowedMethods != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AllowedMethod\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentAllowedMethods(v.AllowedMethods, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.AllowedOrigins != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AllowedOrigin\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentAllowedOrigins(v.AllowedOrigins, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ExposeHeaders != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ExposeHeader\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentExposeHeaders(v.ExposeHeaders, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ID)\n\t}\n\tif v.MaxAgeSeconds != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"MaxAgeSeconds\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.MaxAgeSeconds)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCORSRules(v []types.CORSRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentCORSRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCreateBucketConfiguration(v *types.CreateBucketConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Bucket != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Bucket\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentBucketInfo(v.Bucket, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Location != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Location\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentLocationInfo(v.Location, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.LocationConstraint) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"LocationConstraint\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.LocationConstraint))\n\t}\n\tif v.Tags != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tags\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.Tags, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCSVInput(v *types.CSVInput, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AllowQuotedRecordDelimiter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AllowQuotedRecordDelimiter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.AllowQuotedRecordDelimiter)\n\t}\n\tif v.Comments != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Comments\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Comments)\n\t}\n\tif v.FieldDelimiter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"FieldDelimiter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.FieldDelimiter)\n\t}\n\tif len(v.FileHeaderInfo) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"FileHeaderInfo\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.FileHeaderInfo))\n\t}\n\tif v.QuoteCharacter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"QuoteCharacter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.QuoteCharacter)\n\t}\n\tif v.QuoteEscapeCharacter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"QuoteEscapeCharacter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.QuoteEscapeCharacter)\n\t}\n\tif v.RecordDelimiter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RecordDelimiter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.RecordDelimiter)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentCSVOutput(v *types.CSVOutput, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.FieldDelimiter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"FieldDelimiter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.FieldDelimiter)\n\t}\n\tif v.QuoteCharacter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"QuoteCharacter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.QuoteCharacter)\n\t}\n\tif v.QuoteEscapeCharacter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"QuoteEscapeCharacter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.QuoteEscapeCharacter)\n\t}\n\tif len(v.QuoteFields) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"QuoteFields\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.QuoteFields))\n\t}\n\tif v.RecordDelimiter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RecordDelimiter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.RecordDelimiter)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentDefaultRetention(v *types.DefaultRetention, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Days != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Days\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Days)\n\t}\n\tif len(v.Mode) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Mode\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Mode))\n\t}\n\tif v.Years != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Years\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Years)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentDelete(v *types.Delete, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Objects != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Object\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentObjectIdentifierList(v.Objects, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Quiet != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Quiet\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.Quiet)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentDeleteMarkerReplication(v *types.DeleteMarkerReplication, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentDestination(v *types.Destination, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AccessControlTranslation != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessControlTranslation\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentAccessControlTranslation(v.AccessControlTranslation, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Account != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Account\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Account)\n\t}\n\tif v.Bucket != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Bucket\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Bucket)\n\t}\n\tif v.EncryptionConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EncryptionConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentEncryptionConfiguration(v.EncryptionConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Metrics != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Metrics\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentMetrics(v.Metrics, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ReplicationTime != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ReplicationTime\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicationTime(v.ReplicationTime, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.StorageClass) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"StorageClass\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.StorageClass))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentEncryption(v *types.Encryption, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.EncryptionType) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EncryptionType\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.EncryptionType))\n\t}\n\tif v.KMSContext != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"KMSContext\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.KMSContext)\n\t}\n\tif v.KMSKeyId != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"KMSKeyId\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.KMSKeyId)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentEncryptionConfiguration(v *types.EncryptionConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ReplicaKmsKeyID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ReplicaKmsKeyID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ReplicaKmsKeyID)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentEncryptionTypeList(v []types.EncryptionType, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"EncryptionType\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(string(v[i]))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentErrorDocument(v *types.ErrorDocument, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Key != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Key\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Key)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentEventBridgeConfiguration(v *types.EventBridgeConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentEventList(v []types.Event, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(string(v[i]))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentExistingObjectReplication(v *types.ExistingObjectReplication, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentExposeHeaders(v []string, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(v[i])\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentFilterRule(v *types.FilterRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Name) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Name\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Name))\n\t}\n\tif v.Value != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Value\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Value)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentFilterRuleList(v []types.FilterRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentFilterRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentGlacierJobParameters(v *types.GlacierJobParameters, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Tier) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tier\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Tier))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentGrant(v *types.Grant, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Grantee != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\trootAttr = append(rootAttr, smithyxml.NewNamespaceAttribute(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"))\n\t\tif len(v.Grantee.Type) > 0 {\n\t\t\tvar av string\n\t\t\tav = string(v.Grantee.Type)\n\t\t\trootAttr = append(rootAttr, smithyxml.NewAttribute(\"xsi:type\", av))\n\t\t}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Grantee\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentGrantee(v.Grantee, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.Permission) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Permission\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Permission))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentGrantee(v *types.Grantee, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.DisplayName != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DisplayName\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.DisplayName)\n\t}\n\tif v.EmailAddress != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EmailAddress\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.EmailAddress)\n\t}\n\tif v.ID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ID)\n\t}\n\tif v.URI != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"URI\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.URI)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentGrants(v []types.Grant, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"Grant\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentGrant(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentIndexDocument(v *types.IndexDocument, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Suffix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Suffix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Suffix)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInputSerialization(v *types.InputSerialization, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.CompressionType) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CompressionType\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.CompressionType))\n\t}\n\tif v.CSV != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CSV\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentCSVInput(v.CSV, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.JSON != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"JSON\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentJSONInput(v.JSON, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Parquet != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Parquet\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentParquetInput(v.Parquet, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentIntelligentTieringAndOperator(v *types.IntelligentTieringAndOperator, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tags != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.Tags, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentIntelligentTieringConfiguration(v *types.IntelligentTieringConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentIntelligentTieringFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\tif v.Tierings != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tiering\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTieringList(v.Tierings, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentIntelligentTieringFilter(v *types.IntelligentTieringFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.And != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"And\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentIntelligentTieringAndOperator(v.And, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tag != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTag(v.Tag, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryConfiguration(v *types.InventoryConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Destination != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Destination\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventoryDestination(v.Destination, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventoryFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\tif len(v.IncludedObjectVersions) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"IncludedObjectVersions\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.IncludedObjectVersions))\n\t}\n\tif v.IsEnabled != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"IsEnabled\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.IsEnabled)\n\t}\n\tif v.OptionalFields != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"OptionalFields\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventoryOptionalFields(v.OptionalFields, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Schedule != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Schedule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventorySchedule(v.Schedule, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryDestination(v *types.InventoryDestination, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.S3BucketDestination != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"S3BucketDestination\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventoryS3BucketDestination(v.S3BucketDestination, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryEncryption(v *types.InventoryEncryption, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.SSEKMS != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SSE-KMS\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentSSEKMS(v.SSEKMS, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.SSES3 != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SSE-S3\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentSSES3(v.SSES3, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryFilter(v *types.InventoryFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryOptionalFields(v []types.InventoryOptionalField, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"Field\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tam.String(string(v[i]))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryS3BucketDestination(v *types.InventoryS3BucketDestination, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AccountId != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccountId\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.AccountId)\n\t}\n\tif v.Bucket != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Bucket\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Bucket)\n\t}\n\tif v.Encryption != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Encryption\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventoryEncryption(v.Encryption, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.Format) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Format\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Format))\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventorySchedule(v *types.InventorySchedule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Frequency) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Frequency\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Frequency))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryTableConfiguration(v *types.InventoryTableConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.ConfigurationState) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ConfigurationState\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.ConfigurationState))\n\t}\n\tif v.EncryptionConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EncryptionConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentMetadataTableEncryptionConfiguration(v.EncryptionConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentInventoryTableConfigurationUpdates(v *types.InventoryTableConfigurationUpdates, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.ConfigurationState) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ConfigurationState\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.ConfigurationState))\n\t}\n\tif v.EncryptionConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EncryptionConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentMetadataTableEncryptionConfiguration(v.EncryptionConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentJournalTableConfiguration(v *types.JournalTableConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.EncryptionConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EncryptionConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentMetadataTableEncryptionConfiguration(v.EncryptionConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.RecordExpiration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RecordExpiration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentRecordExpiration(v.RecordExpiration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentJournalTableConfigurationUpdates(v *types.JournalTableConfigurationUpdates, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.RecordExpiration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RecordExpiration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentRecordExpiration(v.RecordExpiration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentJSONInput(v *types.JSONInput, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Type) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Type\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Type))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentJSONOutput(v *types.JSONOutput, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.RecordDelimiter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RecordDelimiter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.RecordDelimiter)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLambdaFunctionConfiguration(v *types.LambdaFunctionConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Events != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Event\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentEventList(v.Events, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentNotificationConfigurationFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\tif v.LambdaFunctionArn != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CloudFunction\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.LambdaFunctionArn)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLambdaFunctionConfigurationList(v []types.LambdaFunctionConfiguration, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentLambdaFunctionConfiguration(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLifecycleExpiration(v *types.LifecycleExpiration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Date != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Date\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(smithytime.FormatDateTime(*v.Date))\n\t}\n\tif v.Days != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Days\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Days)\n\t}\n\tif v.ExpiredObjectDeleteMarker != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ExpiredObjectDeleteMarker\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.ExpiredObjectDeleteMarker)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLifecycleRule(v *types.LifecycleRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AbortIncompleteMultipartUpload != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AbortIncompleteMultipartUpload\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentAbortIncompleteMultipartUpload(v.AbortIncompleteMultipartUpload, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Expiration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Expiration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentLifecycleExpiration(v.Expiration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentLifecycleRuleFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ID)\n\t}\n\tif v.NoncurrentVersionExpiration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NoncurrentVersionExpiration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentNoncurrentVersionExpiration(v.NoncurrentVersionExpiration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.NoncurrentVersionTransitions != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NoncurrentVersionTransition\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentNoncurrentVersionTransitionList(v.NoncurrentVersionTransitions, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\tif v.Transitions != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Transition\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTransitionList(v.Transitions, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLifecycleRuleAndOperator(v *types.LifecycleRuleAndOperator, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ObjectSizeGreaterThan != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectSizeGreaterThan\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.ObjectSizeGreaterThan)\n\t}\n\tif v.ObjectSizeLessThan != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectSizeLessThan\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.ObjectSizeLessThan)\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tags != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.Tags, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLifecycleRuleFilter(v *types.LifecycleRuleFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.And != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"And\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentLifecycleRuleAndOperator(v.And, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ObjectSizeGreaterThan != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectSizeGreaterThan\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.ObjectSizeGreaterThan)\n\t}\n\tif v.ObjectSizeLessThan != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectSizeLessThan\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.ObjectSizeLessThan)\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tag != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTag(v.Tag, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLifecycleRules(v []types.LifecycleRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentLifecycleRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLocationInfo(v *types.LocationInfo, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Name != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Name\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Name)\n\t}\n\tif len(v.Type) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Type\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Type))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentLoggingEnabled(v *types.LoggingEnabled, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.TargetBucket != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TargetBucket\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.TargetBucket)\n\t}\n\tif v.TargetGrants != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TargetGrants\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTargetGrants(v.TargetGrants, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.TargetObjectKeyFormat != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TargetObjectKeyFormat\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTargetObjectKeyFormat(v.TargetObjectKeyFormat, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.TargetPrefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TargetPrefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.TargetPrefix)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetadataConfiguration(v *types.MetadataConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.InventoryTableConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"InventoryTableConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInventoryTableConfiguration(v.InventoryTableConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.JournalTableConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"JournalTableConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentJournalTableConfiguration(v.JournalTableConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetadataEntry(v *types.MetadataEntry, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Name != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Name\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Name)\n\t}\n\tif v.Value != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Value\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Value)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetadataTableConfiguration(v *types.MetadataTableConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.S3TablesDestination != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"S3TablesDestination\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentS3TablesDestination(v.S3TablesDestination, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetadataTableEncryptionConfiguration(v *types.MetadataTableEncryptionConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.KmsKeyArn != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"KmsKeyArn\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.KmsKeyArn)\n\t}\n\tif len(v.SseAlgorithm) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SseAlgorithm\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.SseAlgorithm))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetrics(v *types.Metrics, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.EventThreshold != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EventThreshold\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicationTimeValue(v.EventThreshold, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetricsAndOperator(v *types.MetricsAndOperator, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AccessPointArn != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessPointArn\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.AccessPointArn)\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tags != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.Tags, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetricsConfiguration(v *types.MetricsConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentMetricsFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentMetricsFilter(v types.MetricsFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tswitch uv := v.(type) {\n\tcase *types.MetricsFilterMemberAccessPointArn:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessPointArn\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tav.String(uv.Value)\n\n\tcase *types.MetricsFilterMemberAnd:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"And\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tif err := awsRestxml_serializeDocumentMetricsAndOperator(&uv.Value, av); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tcase *types.MetricsFilterMemberPrefix:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tav.String(uv.Value)\n\n\tcase *types.MetricsFilterMemberTag:\n\t\tcustomMemberNameAttr := []smithyxml.Attr{}\n\t\tcustomMemberName := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: customMemberNameAttr,\n\t\t}\n\t\tav := value.MemberElement(customMemberName)\n\t\tif err := awsRestxml_serializeDocumentTag(&uv.Value, av); err != nil {\n\t\t\treturn err\n\t\t}\n\n\tdefault:\n\t\treturn fmt.Errorf(\"attempted to serialize unknown member type %T for union %T\", uv, v)\n\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentNoncurrentVersionExpiration(v *types.NoncurrentVersionExpiration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.NewerNoncurrentVersions != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NewerNoncurrentVersions\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.NewerNoncurrentVersions)\n\t}\n\tif v.NoncurrentDays != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NoncurrentDays\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.NoncurrentDays)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentNoncurrentVersionTransition(v *types.NoncurrentVersionTransition, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.NewerNoncurrentVersions != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NewerNoncurrentVersions\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.NewerNoncurrentVersions)\n\t}\n\tif v.NoncurrentDays != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"NoncurrentDays\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.NoncurrentDays)\n\t}\n\tif len(v.StorageClass) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"StorageClass\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.StorageClass))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentNoncurrentVersionTransitionList(v []types.NoncurrentVersionTransition, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentNoncurrentVersionTransition(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentNotificationConfiguration(v *types.NotificationConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.EventBridgeConfiguration != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"EventBridgeConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentEventBridgeConfiguration(v.EventBridgeConfiguration, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.LambdaFunctionConfigurations != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CloudFunctionConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentLambdaFunctionConfigurationList(v.LambdaFunctionConfigurations, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.QueueConfigurations != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"QueueConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentQueueConfigurationList(v.QueueConfigurations, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.TopicConfigurations != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TopicConfiguration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTopicConfigurationList(v.TopicConfigurations, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentNotificationConfigurationFilter(v *types.NotificationConfigurationFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Key != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"S3Key\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentS3KeyFilter(v.Key, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentObjectIdentifier(v *types.ObjectIdentifier, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ETag != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ETag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ETag)\n\t}\n\tif v.Key != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Key\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Key)\n\t}\n\tif v.LastModifiedTime != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"LastModifiedTime\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(smithytime.FormatHTTPDate(*v.LastModifiedTime))\n\t}\n\tif v.Size != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Size\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.Size)\n\t}\n\tif v.VersionId != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"VersionId\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.VersionId)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentObjectIdentifierList(v []types.ObjectIdentifier, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentObjectIdentifier(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentObjectLockConfiguration(v *types.ObjectLockConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.ObjectLockEnabled) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectLockEnabled\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.ObjectLockEnabled))\n\t}\n\tif v.Rule != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Rule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentObjectLockRule(v.Rule, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentObjectLockLegalHold(v *types.ObjectLockLegalHold, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentObjectLockRetention(v *types.ObjectLockRetention, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Mode) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Mode\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Mode))\n\t}\n\tif v.RetainUntilDate != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RetainUntilDate\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(smithytime.FormatDateTime(*v.RetainUntilDate))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentObjectLockRule(v *types.ObjectLockRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.DefaultRetention != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DefaultRetention\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentDefaultRetention(v.DefaultRetention, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentOutputLocation(v *types.OutputLocation, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.S3 != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"S3\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentS3Location(v.S3, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentOutputSerialization(v *types.OutputSerialization, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.CSV != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CSV\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentCSVOutput(v.CSV, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.JSON != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"JSON\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentJSONOutput(v.JSON, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentOwner(v *types.Owner, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.DisplayName != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DisplayName\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.DisplayName)\n\t}\n\tif v.ID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ID)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentOwnershipControls(v *types.OwnershipControls, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Rules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Rule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentOwnershipControlsRules(v.Rules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentOwnershipControlsRule(v *types.OwnershipControlsRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.ObjectOwnership) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ObjectOwnership\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.ObjectOwnership))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentOwnershipControlsRules(v []types.OwnershipControlsRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentOwnershipControlsRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentParquetInput(v *types.ParquetInput, value smithyxml.Value) error {\n\tdefer value.Close()\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentPartitionedPrefix(v *types.PartitionedPrefix, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.PartitionDateSource) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"PartitionDateSource\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.PartitionDateSource))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentPublicAccessBlockConfiguration(v *types.PublicAccessBlockConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.BlockPublicAcls != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BlockPublicAcls\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.BlockPublicAcls)\n\t}\n\tif v.BlockPublicPolicy != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BlockPublicPolicy\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.BlockPublicPolicy)\n\t}\n\tif v.IgnorePublicAcls != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"IgnorePublicAcls\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.IgnorePublicAcls)\n\t}\n\tif v.RestrictPublicBuckets != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RestrictPublicBuckets\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.RestrictPublicBuckets)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentQueueConfiguration(v *types.QueueConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Events != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Event\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentEventList(v.Events, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentNotificationConfigurationFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\tif v.QueueArn != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Queue\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.QueueArn)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentQueueConfigurationList(v []types.QueueConfiguration, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentQueueConfiguration(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRecordExpiration(v *types.RecordExpiration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Days != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Days\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Days)\n\t}\n\tif len(v.Expiration) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Expiration\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Expiration))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRedirect(v *types.Redirect, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.HostName != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"HostName\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.HostName)\n\t}\n\tif v.HttpRedirectCode != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"HttpRedirectCode\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.HttpRedirectCode)\n\t}\n\tif len(v.Protocol) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Protocol\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Protocol))\n\t}\n\tif v.ReplaceKeyPrefixWith != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ReplaceKeyPrefixWith\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ReplaceKeyPrefixWith)\n\t}\n\tif v.ReplaceKeyWith != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ReplaceKeyWith\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ReplaceKeyWith)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRedirectAllRequestsTo(v *types.RedirectAllRequestsTo, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.HostName != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"HostName\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.HostName)\n\t}\n\tif len(v.Protocol) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Protocol\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Protocol))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicaModifications(v *types.ReplicaModifications, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationConfiguration(v *types.ReplicationConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Role != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Role\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Role)\n\t}\n\tif v.Rules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Rule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicationRules(v.Rules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationRule(v *types.ReplicationRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.DeleteMarkerReplication != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DeleteMarkerReplication\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentDeleteMarkerReplication(v.DeleteMarkerReplication, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Destination != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Destination\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentDestination(v.Destination, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ExistingObjectReplication != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ExistingObjectReplication\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentExistingObjectReplication(v.ExistingObjectReplication, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicationRuleFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.ID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.ID)\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Priority != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Priority\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Priority)\n\t}\n\tif v.SourceSelectionCriteria != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SourceSelectionCriteria\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentSourceSelectionCriteria(v.SourceSelectionCriteria, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationRuleAndOperator(v *types.ReplicationRuleAndOperator, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tags != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.Tags, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationRuleFilter(v *types.ReplicationRuleFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.And != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"And\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicationRuleAndOperator(v.And, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif v.Tag != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tag\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTag(v.Tag, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationRules(v []types.ReplicationRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentReplicationRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationTime(v *types.ReplicationTime, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\tif v.Time != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Time\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicationTimeValue(v.Time, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentReplicationTimeValue(v *types.ReplicationTimeValue, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Minutes != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Minutes\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Minutes)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRequestPaymentConfiguration(v *types.RequestPaymentConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Payer) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Payer\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Payer))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRequestProgress(v *types.RequestProgress, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Enabled != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Enabled\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.Enabled)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRestoreRequest(v *types.RestoreRequest, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Days != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Days\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Days)\n\t}\n\tif v.Description != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Description\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Description)\n\t}\n\tif v.GlacierJobParameters != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"GlacierJobParameters\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentGlacierJobParameters(v.GlacierJobParameters, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.OutputLocation != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"OutputLocation\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentOutputLocation(v.OutputLocation, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.SelectParameters != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SelectParameters\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentSelectParameters(v.SelectParameters, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.Tier) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tier\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Tier))\n\t}\n\tif len(v.Type) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Type\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Type))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRoutingRule(v *types.RoutingRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Condition != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Condition\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentCondition(v.Condition, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Redirect != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Redirect\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentRedirect(v.Redirect, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentRoutingRules(v []types.RoutingRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"RoutingRule\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentRoutingRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentS3KeyFilter(v *types.S3KeyFilter, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.FilterRules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"FilterRule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentFilterRuleList(v.FilterRules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentS3Location(v *types.S3Location, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.AccessControlList != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessControlList\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentGrants(v.AccessControlList, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.BucketName != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BucketName\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.BucketName)\n\t}\n\tif len(v.CannedACL) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"CannedACL\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.CannedACL))\n\t}\n\tif v.Encryption != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Encryption\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentEncryption(v.Encryption, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Prefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Prefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Prefix)\n\t}\n\tif len(v.StorageClass) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"StorageClass\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.StorageClass))\n\t}\n\tif v.Tagging != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Tagging\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagging(v.Tagging, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.UserMetadata != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"UserMetadata\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentUserMetadata(v.UserMetadata, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentS3TablesDestination(v *types.S3TablesDestination, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.TableBucketArn != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TableBucketArn\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.TableBucketArn)\n\t}\n\tif v.TableName != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TableName\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.TableName)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentScanRange(v *types.ScanRange, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.End != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"End\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.End)\n\t}\n\tif v.Start != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Start\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Long(*v.Start)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentSelectParameters(v *types.SelectParameters, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Expression != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Expression\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Expression)\n\t}\n\tif len(v.ExpressionType) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ExpressionType\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.ExpressionType))\n\t}\n\tif v.InputSerialization != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"InputSerialization\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentInputSerialization(v.InputSerialization, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.OutputSerialization != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"OutputSerialization\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentOutputSerialization(v.OutputSerialization, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentServerSideEncryptionByDefault(v *types.ServerSideEncryptionByDefault, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.KMSMasterKeyID != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"KMSMasterKeyID\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.KMSMasterKeyID)\n\t}\n\tif len(v.SSEAlgorithm) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SSEAlgorithm\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.SSEAlgorithm))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentServerSideEncryptionConfiguration(v *types.ServerSideEncryptionConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Rules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Rule\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentServerSideEncryptionRules(v.Rules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentServerSideEncryptionRule(v *types.ServerSideEncryptionRule, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ApplyServerSideEncryptionByDefault != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ApplyServerSideEncryptionByDefault\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentServerSideEncryptionByDefault(v.ApplyServerSideEncryptionByDefault, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.BlockedEncryptionTypes != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BlockedEncryptionTypes\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentBlockedEncryptionTypes(v.BlockedEncryptionTypes, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.BucketKeyEnabled != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"BucketKeyEnabled\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Boolean(*v.BucketKeyEnabled)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentServerSideEncryptionRules(v []types.ServerSideEncryptionRule, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentServerSideEncryptionRule(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentSimplePrefix(v *types.SimplePrefix, value smithyxml.Value) error {\n\tdefer value.Close()\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentSourceSelectionCriteria(v *types.SourceSelectionCriteria, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ReplicaModifications != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ReplicaModifications\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentReplicaModifications(v.ReplicaModifications, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.SseKmsEncryptedObjects != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SseKmsEncryptedObjects\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentSseKmsEncryptedObjects(v.SseKmsEncryptedObjects, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentSSEKMS(v *types.SSEKMS, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.KeyId != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"KeyId\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.KeyId)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentSseKmsEncryptedObjects(v *types.SseKmsEncryptedObjects, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentSSES3(v *types.SSES3, value smithyxml.Value) error {\n\tdefer value.Close()\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentStorageClassAnalysis(v *types.StorageClassAnalysis, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.DataExport != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"DataExport\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentStorageClassAnalysisDataExport(v.DataExport, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentStorageClassAnalysisDataExport(v *types.StorageClassAnalysisDataExport, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Destination != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Destination\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentAnalyticsExportDestination(v.Destination, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.OutputSchemaVersion) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"OutputSchemaVersion\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.OutputSchemaVersion))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTag(v *types.Tag, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Key != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Key\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Key)\n\t}\n\tif v.Value != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Value\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Value)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTagging(v *types.Tagging, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.TagSet != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"TagSet\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentTagSet(v.TagSet, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTagSet(v []types.Tag, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"Tag\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentTag(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTargetGrant(v *types.TargetGrant, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Grantee != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\trootAttr = append(rootAttr, smithyxml.NewNamespaceAttribute(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"))\n\t\tif len(v.Grantee.Type) > 0 {\n\t\t\tvar av string\n\t\t\tav = string(v.Grantee.Type)\n\t\t\trootAttr = append(rootAttr, smithyxml.NewAttribute(\"xsi:type\", av))\n\t\t}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Grantee\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentGrantee(v.Grantee, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(v.Permission) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Permission\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Permission))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTargetGrants(v []types.TargetGrant, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"Grant\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentTargetGrant(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTargetObjectKeyFormat(v *types.TargetObjectKeyFormat, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.PartitionedPrefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"PartitionedPrefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentPartitionedPrefix(v.PartitionedPrefix, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.SimplePrefix != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"SimplePrefix\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentSimplePrefix(v.SimplePrefix, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTiering(v *types.Tiering, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.AccessTier) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"AccessTier\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.AccessTier))\n\t}\n\tif v.Days != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Days\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Days)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTieringList(v []types.Tiering, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentTiering(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTopicConfiguration(v *types.TopicConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Events != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Event\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.FlattenedElement(root)\n\t\tif err := awsRestxml_serializeDocumentEventList(v.Events, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Filter != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Filter\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentNotificationConfigurationFilter(v.Filter, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.Id != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Id\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.Id)\n\t}\n\tif v.TopicArn != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Topic\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(*v.TopicArn)\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTopicConfigurationList(v []types.TopicConfiguration, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentTopicConfiguration(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTransition(v *types.Transition, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.Date != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Date\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(smithytime.FormatDateTime(*v.Date))\n\t}\n\tif v.Days != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Days\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.Integer(*v.Days)\n\t}\n\tif len(v.StorageClass) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"StorageClass\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.StorageClass))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentTransitionList(v []types.Transition, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tarray = value.Array()\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentTransition(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentUserMetadata(v []types.MetadataEntry, value smithyxml.Value) error {\n\tvar array *smithyxml.Array\n\tif !value.IsFlattened() {\n\t\tdefer value.Close()\n\t}\n\tcustomMemberNameAttr := []smithyxml.Attr{}\n\tcustomMemberName := smithyxml.StartElement{\n\t\tName: smithyxml.Name{\n\t\t\tLocal: \"MetadataEntry\",\n\t\t},\n\t\tAttr: customMemberNameAttr,\n\t}\n\tarray = value.ArrayWithCustomName(customMemberName)\n\tfor i := range v {\n\t\tam := array.Member()\n\t\tif err := awsRestxml_serializeDocumentMetadataEntry(&v[i], am); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentVersioningConfiguration(v *types.VersioningConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif len(v.MFADelete) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"MfaDelete\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.MFADelete))\n\t}\n\tif len(v.Status) > 0 {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"Status\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tel.String(string(v.Status))\n\t}\n\treturn nil\n}\n\nfunc awsRestxml_serializeDocumentWebsiteConfiguration(v *types.WebsiteConfiguration, value smithyxml.Value) error {\n\tdefer value.Close()\n\tif v.ErrorDocument != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"ErrorDocument\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentErrorDocument(v.ErrorDocument, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.IndexDocument != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"IndexDocument\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentIndexDocument(v.IndexDocument, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.RedirectAllRequestsTo != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RedirectAllRequestsTo\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentRedirectAllRequestsTo(v.RedirectAllRequestsTo, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif v.RoutingRules != nil {\n\t\trootAttr := []smithyxml.Attr{}\n\t\troot := smithyxml.StartElement{\n\t\t\tName: smithyxml.Name{\n\t\t\t\tLocal: \"RoutingRules\",\n\t\t\t},\n\t\t\tAttr: rootAttr,\n\t\t}\n\t\tel := value.MemberElement(root)\n\t\tif err := awsRestxml_serializeDocumentRoutingRules(v.RoutingRules, el); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/types/enums.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage types\n\ntype AnalyticsS3ExportFileFormat string\n\n// Enum values for AnalyticsS3ExportFileFormat\nconst (\n\tAnalyticsS3ExportFileFormatCsv AnalyticsS3ExportFileFormat = \"CSV\"\n)\n\n// Values returns all known values for AnalyticsS3ExportFileFormat. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (AnalyticsS3ExportFileFormat) Values() []AnalyticsS3ExportFileFormat {\n\treturn []AnalyticsS3ExportFileFormat{\n\t\t\"CSV\",\n\t}\n}\n\ntype ArchiveStatus string\n\n// Enum values for ArchiveStatus\nconst (\n\tArchiveStatusArchiveAccess     ArchiveStatus = \"ARCHIVE_ACCESS\"\n\tArchiveStatusDeepArchiveAccess ArchiveStatus = \"DEEP_ARCHIVE_ACCESS\"\n)\n\n// Values returns all known values for ArchiveStatus. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ArchiveStatus) Values() []ArchiveStatus {\n\treturn []ArchiveStatus{\n\t\t\"ARCHIVE_ACCESS\",\n\t\t\"DEEP_ARCHIVE_ACCESS\",\n\t}\n}\n\ntype BucketAbacStatus string\n\n// Enum values for BucketAbacStatus\nconst (\n\tBucketAbacStatusEnabled  BucketAbacStatus = \"Enabled\"\n\tBucketAbacStatusDisabled BucketAbacStatus = \"Disabled\"\n)\n\n// Values returns all known values for BucketAbacStatus. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketAbacStatus) Values() []BucketAbacStatus {\n\treturn []BucketAbacStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype BucketAccelerateStatus string\n\n// Enum values for BucketAccelerateStatus\nconst (\n\tBucketAccelerateStatusEnabled   BucketAccelerateStatus = \"Enabled\"\n\tBucketAccelerateStatusSuspended BucketAccelerateStatus = \"Suspended\"\n)\n\n// Values returns all known values for BucketAccelerateStatus. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketAccelerateStatus) Values() []BucketAccelerateStatus {\n\treturn []BucketAccelerateStatus{\n\t\t\"Enabled\",\n\t\t\"Suspended\",\n\t}\n}\n\ntype BucketCannedACL string\n\n// Enum values for BucketCannedACL\nconst (\n\tBucketCannedACLPrivate           BucketCannedACL = \"private\"\n\tBucketCannedACLPublicRead        BucketCannedACL = \"public-read\"\n\tBucketCannedACLPublicReadWrite   BucketCannedACL = \"public-read-write\"\n\tBucketCannedACLAuthenticatedRead BucketCannedACL = \"authenticated-read\"\n)\n\n// Values returns all known values for BucketCannedACL. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketCannedACL) Values() []BucketCannedACL {\n\treturn []BucketCannedACL{\n\t\t\"private\",\n\t\t\"public-read\",\n\t\t\"public-read-write\",\n\t\t\"authenticated-read\",\n\t}\n}\n\ntype BucketLocationConstraint string\n\n// Enum values for BucketLocationConstraint\nconst (\n\tBucketLocationConstraintAfSouth1     BucketLocationConstraint = \"af-south-1\"\n\tBucketLocationConstraintApEast1      BucketLocationConstraint = \"ap-east-1\"\n\tBucketLocationConstraintApNortheast1 BucketLocationConstraint = \"ap-northeast-1\"\n\tBucketLocationConstraintApNortheast2 BucketLocationConstraint = \"ap-northeast-2\"\n\tBucketLocationConstraintApNortheast3 BucketLocationConstraint = \"ap-northeast-3\"\n\tBucketLocationConstraintApSouth1     BucketLocationConstraint = \"ap-south-1\"\n\tBucketLocationConstraintApSouth2     BucketLocationConstraint = \"ap-south-2\"\n\tBucketLocationConstraintApSoutheast1 BucketLocationConstraint = \"ap-southeast-1\"\n\tBucketLocationConstraintApSoutheast2 BucketLocationConstraint = \"ap-southeast-2\"\n\tBucketLocationConstraintApSoutheast3 BucketLocationConstraint = \"ap-southeast-3\"\n\tBucketLocationConstraintApSoutheast4 BucketLocationConstraint = \"ap-southeast-4\"\n\tBucketLocationConstraintApSoutheast5 BucketLocationConstraint = \"ap-southeast-5\"\n\tBucketLocationConstraintCaCentral1   BucketLocationConstraint = \"ca-central-1\"\n\tBucketLocationConstraintCnNorth1     BucketLocationConstraint = \"cn-north-1\"\n\tBucketLocationConstraintCnNorthwest1 BucketLocationConstraint = \"cn-northwest-1\"\n\tBucketLocationConstraintEu           BucketLocationConstraint = \"EU\"\n\tBucketLocationConstraintEuCentral1   BucketLocationConstraint = \"eu-central-1\"\n\tBucketLocationConstraintEuCentral2   BucketLocationConstraint = \"eu-central-2\"\n\tBucketLocationConstraintEuNorth1     BucketLocationConstraint = \"eu-north-1\"\n\tBucketLocationConstraintEuSouth1     BucketLocationConstraint = \"eu-south-1\"\n\tBucketLocationConstraintEuSouth2     BucketLocationConstraint = \"eu-south-2\"\n\tBucketLocationConstraintEuWest1      BucketLocationConstraint = \"eu-west-1\"\n\tBucketLocationConstraintEuWest2      BucketLocationConstraint = \"eu-west-2\"\n\tBucketLocationConstraintEuWest3      BucketLocationConstraint = \"eu-west-3\"\n\tBucketLocationConstraintIlCentral1   BucketLocationConstraint = \"il-central-1\"\n\tBucketLocationConstraintMeCentral1   BucketLocationConstraint = \"me-central-1\"\n\tBucketLocationConstraintMeSouth1     BucketLocationConstraint = \"me-south-1\"\n\tBucketLocationConstraintSaEast1      BucketLocationConstraint = \"sa-east-1\"\n\tBucketLocationConstraintUsEast2      BucketLocationConstraint = \"us-east-2\"\n\tBucketLocationConstraintUsGovEast1   BucketLocationConstraint = \"us-gov-east-1\"\n\tBucketLocationConstraintUsGovWest1   BucketLocationConstraint = \"us-gov-west-1\"\n\tBucketLocationConstraintUsWest1      BucketLocationConstraint = \"us-west-1\"\n\tBucketLocationConstraintUsWest2      BucketLocationConstraint = \"us-west-2\"\n)\n\n// Values returns all known values for BucketLocationConstraint. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketLocationConstraint) Values() []BucketLocationConstraint {\n\treturn []BucketLocationConstraint{\n\t\t\"af-south-1\",\n\t\t\"ap-east-1\",\n\t\t\"ap-northeast-1\",\n\t\t\"ap-northeast-2\",\n\t\t\"ap-northeast-3\",\n\t\t\"ap-south-1\",\n\t\t\"ap-south-2\",\n\t\t\"ap-southeast-1\",\n\t\t\"ap-southeast-2\",\n\t\t\"ap-southeast-3\",\n\t\t\"ap-southeast-4\",\n\t\t\"ap-southeast-5\",\n\t\t\"ca-central-1\",\n\t\t\"cn-north-1\",\n\t\t\"cn-northwest-1\",\n\t\t\"EU\",\n\t\t\"eu-central-1\",\n\t\t\"eu-central-2\",\n\t\t\"eu-north-1\",\n\t\t\"eu-south-1\",\n\t\t\"eu-south-2\",\n\t\t\"eu-west-1\",\n\t\t\"eu-west-2\",\n\t\t\"eu-west-3\",\n\t\t\"il-central-1\",\n\t\t\"me-central-1\",\n\t\t\"me-south-1\",\n\t\t\"sa-east-1\",\n\t\t\"us-east-2\",\n\t\t\"us-gov-east-1\",\n\t\t\"us-gov-west-1\",\n\t\t\"us-west-1\",\n\t\t\"us-west-2\",\n\t}\n}\n\ntype BucketLogsPermission string\n\n// Enum values for BucketLogsPermission\nconst (\n\tBucketLogsPermissionFullControl BucketLogsPermission = \"FULL_CONTROL\"\n\tBucketLogsPermissionRead        BucketLogsPermission = \"READ\"\n\tBucketLogsPermissionWrite       BucketLogsPermission = \"WRITE\"\n)\n\n// Values returns all known values for BucketLogsPermission. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketLogsPermission) Values() []BucketLogsPermission {\n\treturn []BucketLogsPermission{\n\t\t\"FULL_CONTROL\",\n\t\t\"READ\",\n\t\t\"WRITE\",\n\t}\n}\n\ntype BucketType string\n\n// Enum values for BucketType\nconst (\n\tBucketTypeDirectory BucketType = \"Directory\"\n)\n\n// Values returns all known values for BucketType. Note that this can be expanded\n// in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketType) Values() []BucketType {\n\treturn []BucketType{\n\t\t\"Directory\",\n\t}\n}\n\ntype BucketVersioningStatus string\n\n// Enum values for BucketVersioningStatus\nconst (\n\tBucketVersioningStatusEnabled   BucketVersioningStatus = \"Enabled\"\n\tBucketVersioningStatusSuspended BucketVersioningStatus = \"Suspended\"\n)\n\n// Values returns all known values for BucketVersioningStatus. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (BucketVersioningStatus) Values() []BucketVersioningStatus {\n\treturn []BucketVersioningStatus{\n\t\t\"Enabled\",\n\t\t\"Suspended\",\n\t}\n}\n\ntype ChecksumAlgorithm string\n\n// Enum values for ChecksumAlgorithm\nconst (\n\tChecksumAlgorithmCrc32     ChecksumAlgorithm = \"CRC32\"\n\tChecksumAlgorithmCrc32c    ChecksumAlgorithm = \"CRC32C\"\n\tChecksumAlgorithmSha1      ChecksumAlgorithm = \"SHA1\"\n\tChecksumAlgorithmSha256    ChecksumAlgorithm = \"SHA256\"\n\tChecksumAlgorithmCrc64nvme ChecksumAlgorithm = \"CRC64NVME\"\n)\n\n// Values returns all known values for ChecksumAlgorithm. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ChecksumAlgorithm) Values() []ChecksumAlgorithm {\n\treturn []ChecksumAlgorithm{\n\t\t\"CRC32\",\n\t\t\"CRC32C\",\n\t\t\"SHA1\",\n\t\t\"SHA256\",\n\t\t\"CRC64NVME\",\n\t}\n}\n\ntype ChecksumMode string\n\n// Enum values for ChecksumMode\nconst (\n\tChecksumModeEnabled ChecksumMode = \"ENABLED\"\n)\n\n// Values returns all known values for ChecksumMode. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ChecksumMode) Values() []ChecksumMode {\n\treturn []ChecksumMode{\n\t\t\"ENABLED\",\n\t}\n}\n\ntype ChecksumType string\n\n// Enum values for ChecksumType\nconst (\n\tChecksumTypeComposite  ChecksumType = \"COMPOSITE\"\n\tChecksumTypeFullObject ChecksumType = \"FULL_OBJECT\"\n)\n\n// Values returns all known values for ChecksumType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ChecksumType) Values() []ChecksumType {\n\treturn []ChecksumType{\n\t\t\"COMPOSITE\",\n\t\t\"FULL_OBJECT\",\n\t}\n}\n\ntype CompressionType string\n\n// Enum values for CompressionType\nconst (\n\tCompressionTypeNone  CompressionType = \"NONE\"\n\tCompressionTypeGzip  CompressionType = \"GZIP\"\n\tCompressionTypeBzip2 CompressionType = \"BZIP2\"\n)\n\n// Values returns all known values for CompressionType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (CompressionType) Values() []CompressionType {\n\treturn []CompressionType{\n\t\t\"NONE\",\n\t\t\"GZIP\",\n\t\t\"BZIP2\",\n\t}\n}\n\ntype DataRedundancy string\n\n// Enum values for DataRedundancy\nconst (\n\tDataRedundancySingleAvailabilityZone DataRedundancy = \"SingleAvailabilityZone\"\n\tDataRedundancySingleLocalZone        DataRedundancy = \"SingleLocalZone\"\n)\n\n// Values returns all known values for DataRedundancy. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (DataRedundancy) Values() []DataRedundancy {\n\treturn []DataRedundancy{\n\t\t\"SingleAvailabilityZone\",\n\t\t\"SingleLocalZone\",\n\t}\n}\n\ntype DeleteMarkerReplicationStatus string\n\n// Enum values for DeleteMarkerReplicationStatus\nconst (\n\tDeleteMarkerReplicationStatusEnabled  DeleteMarkerReplicationStatus = \"Enabled\"\n\tDeleteMarkerReplicationStatusDisabled DeleteMarkerReplicationStatus = \"Disabled\"\n)\n\n// Values returns all known values for DeleteMarkerReplicationStatus. Note that\n// this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (DeleteMarkerReplicationStatus) Values() []DeleteMarkerReplicationStatus {\n\treturn []DeleteMarkerReplicationStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype EncodingType string\n\n// Enum values for EncodingType\nconst (\n\tEncodingTypeUrl EncodingType = \"url\"\n)\n\n// Values returns all known values for EncodingType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (EncodingType) Values() []EncodingType {\n\treturn []EncodingType{\n\t\t\"url\",\n\t}\n}\n\ntype EncryptionType string\n\n// Enum values for EncryptionType\nconst (\n\tEncryptionTypeNone EncryptionType = \"NONE\"\n\tEncryptionTypeSseC EncryptionType = \"SSE-C\"\n)\n\n// Values returns all known values for EncryptionType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (EncryptionType) Values() []EncryptionType {\n\treturn []EncryptionType{\n\t\t\"NONE\",\n\t\t\"SSE-C\",\n\t}\n}\n\ntype Event string\n\n// Enum values for Event\nconst (\n\tEventS3ReducedRedundancyLostObject                  Event = \"s3:ReducedRedundancyLostObject\"\n\tEventS3ObjectCreated                                Event = \"s3:ObjectCreated:*\"\n\tEventS3ObjectCreatedPut                             Event = \"s3:ObjectCreated:Put\"\n\tEventS3ObjectCreatedPost                            Event = \"s3:ObjectCreated:Post\"\n\tEventS3ObjectCreatedCopy                            Event = \"s3:ObjectCreated:Copy\"\n\tEventS3ObjectCreatedCompleteMultipartUpload         Event = \"s3:ObjectCreated:CompleteMultipartUpload\"\n\tEventS3ObjectRemoved                                Event = \"s3:ObjectRemoved:*\"\n\tEventS3ObjectRemovedDelete                          Event = \"s3:ObjectRemoved:Delete\"\n\tEventS3ObjectRemovedDeleteMarkerCreated             Event = \"s3:ObjectRemoved:DeleteMarkerCreated\"\n\tEventS3ObjectRestore                                Event = \"s3:ObjectRestore:*\"\n\tEventS3ObjectRestorePost                            Event = \"s3:ObjectRestore:Post\"\n\tEventS3ObjectRestoreCompleted                       Event = \"s3:ObjectRestore:Completed\"\n\tEventS3Replication                                  Event = \"s3:Replication:*\"\n\tEventS3ReplicationOperationFailedReplication        Event = \"s3:Replication:OperationFailedReplication\"\n\tEventS3ReplicationOperationNotTracked               Event = \"s3:Replication:OperationNotTracked\"\n\tEventS3ReplicationOperationMissedThreshold          Event = \"s3:Replication:OperationMissedThreshold\"\n\tEventS3ReplicationOperationReplicatedAfterThreshold Event = \"s3:Replication:OperationReplicatedAfterThreshold\"\n\tEventS3ObjectRestoreDelete                          Event = \"s3:ObjectRestore:Delete\"\n\tEventS3LifecycleTransition                          Event = \"s3:LifecycleTransition\"\n\tEventS3IntelligentTiering                           Event = \"s3:IntelligentTiering\"\n\tEventS3ObjectAclPut                                 Event = \"s3:ObjectAcl:Put\"\n\tEventS3LifecycleExpiration                          Event = \"s3:LifecycleExpiration:*\"\n\tEventS3LifecycleExpirationDelete                    Event = \"s3:LifecycleExpiration:Delete\"\n\tEventS3LifecycleExpirationDeleteMarkerCreated       Event = \"s3:LifecycleExpiration:DeleteMarkerCreated\"\n\tEventS3ObjectTagging                                Event = \"s3:ObjectTagging:*\"\n\tEventS3ObjectTaggingPut                             Event = \"s3:ObjectTagging:Put\"\n\tEventS3ObjectTaggingDelete                          Event = \"s3:ObjectTagging:Delete\"\n)\n\n// Values returns all known values for Event. Note that this can be expanded in\n// the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (Event) Values() []Event {\n\treturn []Event{\n\t\t\"s3:ReducedRedundancyLostObject\",\n\t\t\"s3:ObjectCreated:*\",\n\t\t\"s3:ObjectCreated:Put\",\n\t\t\"s3:ObjectCreated:Post\",\n\t\t\"s3:ObjectCreated:Copy\",\n\t\t\"s3:ObjectCreated:CompleteMultipartUpload\",\n\t\t\"s3:ObjectRemoved:*\",\n\t\t\"s3:ObjectRemoved:Delete\",\n\t\t\"s3:ObjectRemoved:DeleteMarkerCreated\",\n\t\t\"s3:ObjectRestore:*\",\n\t\t\"s3:ObjectRestore:Post\",\n\t\t\"s3:ObjectRestore:Completed\",\n\t\t\"s3:Replication:*\",\n\t\t\"s3:Replication:OperationFailedReplication\",\n\t\t\"s3:Replication:OperationNotTracked\",\n\t\t\"s3:Replication:OperationMissedThreshold\",\n\t\t\"s3:Replication:OperationReplicatedAfterThreshold\",\n\t\t\"s3:ObjectRestore:Delete\",\n\t\t\"s3:LifecycleTransition\",\n\t\t\"s3:IntelligentTiering\",\n\t\t\"s3:ObjectAcl:Put\",\n\t\t\"s3:LifecycleExpiration:*\",\n\t\t\"s3:LifecycleExpiration:Delete\",\n\t\t\"s3:LifecycleExpiration:DeleteMarkerCreated\",\n\t\t\"s3:ObjectTagging:*\",\n\t\t\"s3:ObjectTagging:Put\",\n\t\t\"s3:ObjectTagging:Delete\",\n\t}\n}\n\ntype ExistingObjectReplicationStatus string\n\n// Enum values for ExistingObjectReplicationStatus\nconst (\n\tExistingObjectReplicationStatusEnabled  ExistingObjectReplicationStatus = \"Enabled\"\n\tExistingObjectReplicationStatusDisabled ExistingObjectReplicationStatus = \"Disabled\"\n)\n\n// Values returns all known values for ExistingObjectReplicationStatus. Note that\n// this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ExistingObjectReplicationStatus) Values() []ExistingObjectReplicationStatus {\n\treturn []ExistingObjectReplicationStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype ExpirationState string\n\n// Enum values for ExpirationState\nconst (\n\tExpirationStateEnabled  ExpirationState = \"ENABLED\"\n\tExpirationStateDisabled ExpirationState = \"DISABLED\"\n)\n\n// Values returns all known values for ExpirationState. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ExpirationState) Values() []ExpirationState {\n\treturn []ExpirationState{\n\t\t\"ENABLED\",\n\t\t\"DISABLED\",\n\t}\n}\n\ntype ExpirationStatus string\n\n// Enum values for ExpirationStatus\nconst (\n\tExpirationStatusEnabled  ExpirationStatus = \"Enabled\"\n\tExpirationStatusDisabled ExpirationStatus = \"Disabled\"\n)\n\n// Values returns all known values for ExpirationStatus. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ExpirationStatus) Values() []ExpirationStatus {\n\treturn []ExpirationStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype ExpressionType string\n\n// Enum values for ExpressionType\nconst (\n\tExpressionTypeSql ExpressionType = \"SQL\"\n)\n\n// Values returns all known values for ExpressionType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ExpressionType) Values() []ExpressionType {\n\treturn []ExpressionType{\n\t\t\"SQL\",\n\t}\n}\n\ntype FileHeaderInfo string\n\n// Enum values for FileHeaderInfo\nconst (\n\tFileHeaderInfoUse    FileHeaderInfo = \"USE\"\n\tFileHeaderInfoIgnore FileHeaderInfo = \"IGNORE\"\n\tFileHeaderInfoNone   FileHeaderInfo = \"NONE\"\n)\n\n// Values returns all known values for FileHeaderInfo. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (FileHeaderInfo) Values() []FileHeaderInfo {\n\treturn []FileHeaderInfo{\n\t\t\"USE\",\n\t\t\"IGNORE\",\n\t\t\"NONE\",\n\t}\n}\n\ntype FilterRuleName string\n\n// Enum values for FilterRuleName\nconst (\n\tFilterRuleNamePrefix FilterRuleName = \"prefix\"\n\tFilterRuleNameSuffix FilterRuleName = \"suffix\"\n)\n\n// Values returns all known values for FilterRuleName. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (FilterRuleName) Values() []FilterRuleName {\n\treturn []FilterRuleName{\n\t\t\"prefix\",\n\t\t\"suffix\",\n\t}\n}\n\ntype IntelligentTieringAccessTier string\n\n// Enum values for IntelligentTieringAccessTier\nconst (\n\tIntelligentTieringAccessTierArchiveAccess     IntelligentTieringAccessTier = \"ARCHIVE_ACCESS\"\n\tIntelligentTieringAccessTierDeepArchiveAccess IntelligentTieringAccessTier = \"DEEP_ARCHIVE_ACCESS\"\n)\n\n// Values returns all known values for IntelligentTieringAccessTier. Note that\n// this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (IntelligentTieringAccessTier) Values() []IntelligentTieringAccessTier {\n\treturn []IntelligentTieringAccessTier{\n\t\t\"ARCHIVE_ACCESS\",\n\t\t\"DEEP_ARCHIVE_ACCESS\",\n\t}\n}\n\ntype IntelligentTieringStatus string\n\n// Enum values for IntelligentTieringStatus\nconst (\n\tIntelligentTieringStatusEnabled  IntelligentTieringStatus = \"Enabled\"\n\tIntelligentTieringStatusDisabled IntelligentTieringStatus = \"Disabled\"\n)\n\n// Values returns all known values for IntelligentTieringStatus. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (IntelligentTieringStatus) Values() []IntelligentTieringStatus {\n\treturn []IntelligentTieringStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype InventoryConfigurationState string\n\n// Enum values for InventoryConfigurationState\nconst (\n\tInventoryConfigurationStateEnabled  InventoryConfigurationState = \"ENABLED\"\n\tInventoryConfigurationStateDisabled InventoryConfigurationState = \"DISABLED\"\n)\n\n// Values returns all known values for InventoryConfigurationState. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (InventoryConfigurationState) Values() []InventoryConfigurationState {\n\treturn []InventoryConfigurationState{\n\t\t\"ENABLED\",\n\t\t\"DISABLED\",\n\t}\n}\n\ntype InventoryFormat string\n\n// Enum values for InventoryFormat\nconst (\n\tInventoryFormatCsv     InventoryFormat = \"CSV\"\n\tInventoryFormatOrc     InventoryFormat = \"ORC\"\n\tInventoryFormatParquet InventoryFormat = \"Parquet\"\n)\n\n// Values returns all known values for InventoryFormat. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (InventoryFormat) Values() []InventoryFormat {\n\treturn []InventoryFormat{\n\t\t\"CSV\",\n\t\t\"ORC\",\n\t\t\"Parquet\",\n\t}\n}\n\ntype InventoryFrequency string\n\n// Enum values for InventoryFrequency\nconst (\n\tInventoryFrequencyDaily  InventoryFrequency = \"Daily\"\n\tInventoryFrequencyWeekly InventoryFrequency = \"Weekly\"\n)\n\n// Values returns all known values for InventoryFrequency. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (InventoryFrequency) Values() []InventoryFrequency {\n\treturn []InventoryFrequency{\n\t\t\"Daily\",\n\t\t\"Weekly\",\n\t}\n}\n\ntype InventoryIncludedObjectVersions string\n\n// Enum values for InventoryIncludedObjectVersions\nconst (\n\tInventoryIncludedObjectVersionsAll     InventoryIncludedObjectVersions = \"All\"\n\tInventoryIncludedObjectVersionsCurrent InventoryIncludedObjectVersions = \"Current\"\n)\n\n// Values returns all known values for InventoryIncludedObjectVersions. Note that\n// this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (InventoryIncludedObjectVersions) Values() []InventoryIncludedObjectVersions {\n\treturn []InventoryIncludedObjectVersions{\n\t\t\"All\",\n\t\t\"Current\",\n\t}\n}\n\ntype InventoryOptionalField string\n\n// Enum values for InventoryOptionalField\nconst (\n\tInventoryOptionalFieldSize                         InventoryOptionalField = \"Size\"\n\tInventoryOptionalFieldLastModifiedDate             InventoryOptionalField = \"LastModifiedDate\"\n\tInventoryOptionalFieldStorageClass                 InventoryOptionalField = \"StorageClass\"\n\tInventoryOptionalFieldETag                         InventoryOptionalField = \"ETag\"\n\tInventoryOptionalFieldIsMultipartUploaded          InventoryOptionalField = \"IsMultipartUploaded\"\n\tInventoryOptionalFieldReplicationStatus            InventoryOptionalField = \"ReplicationStatus\"\n\tInventoryOptionalFieldEncryptionStatus             InventoryOptionalField = \"EncryptionStatus\"\n\tInventoryOptionalFieldObjectLockRetainUntilDate    InventoryOptionalField = \"ObjectLockRetainUntilDate\"\n\tInventoryOptionalFieldObjectLockMode               InventoryOptionalField = \"ObjectLockMode\"\n\tInventoryOptionalFieldObjectLockLegalHoldStatus    InventoryOptionalField = \"ObjectLockLegalHoldStatus\"\n\tInventoryOptionalFieldIntelligentTieringAccessTier InventoryOptionalField = \"IntelligentTieringAccessTier\"\n\tInventoryOptionalFieldBucketKeyStatus              InventoryOptionalField = \"BucketKeyStatus\"\n\tInventoryOptionalFieldChecksumAlgorithm            InventoryOptionalField = \"ChecksumAlgorithm\"\n\tInventoryOptionalFieldObjectAccessControlList      InventoryOptionalField = \"ObjectAccessControlList\"\n\tInventoryOptionalFieldObjectOwner                  InventoryOptionalField = \"ObjectOwner\"\n)\n\n// Values returns all known values for InventoryOptionalField. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (InventoryOptionalField) Values() []InventoryOptionalField {\n\treturn []InventoryOptionalField{\n\t\t\"Size\",\n\t\t\"LastModifiedDate\",\n\t\t\"StorageClass\",\n\t\t\"ETag\",\n\t\t\"IsMultipartUploaded\",\n\t\t\"ReplicationStatus\",\n\t\t\"EncryptionStatus\",\n\t\t\"ObjectLockRetainUntilDate\",\n\t\t\"ObjectLockMode\",\n\t\t\"ObjectLockLegalHoldStatus\",\n\t\t\"IntelligentTieringAccessTier\",\n\t\t\"BucketKeyStatus\",\n\t\t\"ChecksumAlgorithm\",\n\t\t\"ObjectAccessControlList\",\n\t\t\"ObjectOwner\",\n\t}\n}\n\ntype JSONType string\n\n// Enum values for JSONType\nconst (\n\tJSONTypeDocument JSONType = \"DOCUMENT\"\n\tJSONTypeLines    JSONType = \"LINES\"\n)\n\n// Values returns all known values for JSONType. Note that this can be expanded in\n// the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (JSONType) Values() []JSONType {\n\treturn []JSONType{\n\t\t\"DOCUMENT\",\n\t\t\"LINES\",\n\t}\n}\n\ntype LocationType string\n\n// Enum values for LocationType\nconst (\n\tLocationTypeAvailabilityZone LocationType = \"AvailabilityZone\"\n\tLocationTypeLocalZone        LocationType = \"LocalZone\"\n)\n\n// Values returns all known values for LocationType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (LocationType) Values() []LocationType {\n\treturn []LocationType{\n\t\t\"AvailabilityZone\",\n\t\t\"LocalZone\",\n\t}\n}\n\ntype MetadataDirective string\n\n// Enum values for MetadataDirective\nconst (\n\tMetadataDirectiveCopy    MetadataDirective = \"COPY\"\n\tMetadataDirectiveReplace MetadataDirective = \"REPLACE\"\n)\n\n// Values returns all known values for MetadataDirective. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (MetadataDirective) Values() []MetadataDirective {\n\treturn []MetadataDirective{\n\t\t\"COPY\",\n\t\t\"REPLACE\",\n\t}\n}\n\ntype MetricsStatus string\n\n// Enum values for MetricsStatus\nconst (\n\tMetricsStatusEnabled  MetricsStatus = \"Enabled\"\n\tMetricsStatusDisabled MetricsStatus = \"Disabled\"\n)\n\n// Values returns all known values for MetricsStatus. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (MetricsStatus) Values() []MetricsStatus {\n\treturn []MetricsStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype MFADelete string\n\n// Enum values for MFADelete\nconst (\n\tMFADeleteEnabled  MFADelete = \"Enabled\"\n\tMFADeleteDisabled MFADelete = \"Disabled\"\n)\n\n// Values returns all known values for MFADelete. Note that this can be expanded\n// in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (MFADelete) Values() []MFADelete {\n\treturn []MFADelete{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype MFADeleteStatus string\n\n// Enum values for MFADeleteStatus\nconst (\n\tMFADeleteStatusEnabled  MFADeleteStatus = \"Enabled\"\n\tMFADeleteStatusDisabled MFADeleteStatus = \"Disabled\"\n)\n\n// Values returns all known values for MFADeleteStatus. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (MFADeleteStatus) Values() []MFADeleteStatus {\n\treturn []MFADeleteStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype ObjectAttributes string\n\n// Enum values for ObjectAttributes\nconst (\n\tObjectAttributesEtag         ObjectAttributes = \"ETag\"\n\tObjectAttributesChecksum     ObjectAttributes = \"Checksum\"\n\tObjectAttributesObjectParts  ObjectAttributes = \"ObjectParts\"\n\tObjectAttributesStorageClass ObjectAttributes = \"StorageClass\"\n\tObjectAttributesObjectSize   ObjectAttributes = \"ObjectSize\"\n)\n\n// Values returns all known values for ObjectAttributes. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectAttributes) Values() []ObjectAttributes {\n\treturn []ObjectAttributes{\n\t\t\"ETag\",\n\t\t\"Checksum\",\n\t\t\"ObjectParts\",\n\t\t\"StorageClass\",\n\t\t\"ObjectSize\",\n\t}\n}\n\ntype ObjectCannedACL string\n\n// Enum values for ObjectCannedACL\nconst (\n\tObjectCannedACLPrivate                ObjectCannedACL = \"private\"\n\tObjectCannedACLPublicRead             ObjectCannedACL = \"public-read\"\n\tObjectCannedACLPublicReadWrite        ObjectCannedACL = \"public-read-write\"\n\tObjectCannedACLAuthenticatedRead      ObjectCannedACL = \"authenticated-read\"\n\tObjectCannedACLAwsExecRead            ObjectCannedACL = \"aws-exec-read\"\n\tObjectCannedACLBucketOwnerRead        ObjectCannedACL = \"bucket-owner-read\"\n\tObjectCannedACLBucketOwnerFullControl ObjectCannedACL = \"bucket-owner-full-control\"\n)\n\n// Values returns all known values for ObjectCannedACL. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectCannedACL) Values() []ObjectCannedACL {\n\treturn []ObjectCannedACL{\n\t\t\"private\",\n\t\t\"public-read\",\n\t\t\"public-read-write\",\n\t\t\"authenticated-read\",\n\t\t\"aws-exec-read\",\n\t\t\"bucket-owner-read\",\n\t\t\"bucket-owner-full-control\",\n\t}\n}\n\ntype ObjectLockEnabled string\n\n// Enum values for ObjectLockEnabled\nconst (\n\tObjectLockEnabledEnabled ObjectLockEnabled = \"Enabled\"\n)\n\n// Values returns all known values for ObjectLockEnabled. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectLockEnabled) Values() []ObjectLockEnabled {\n\treturn []ObjectLockEnabled{\n\t\t\"Enabled\",\n\t}\n}\n\ntype ObjectLockLegalHoldStatus string\n\n// Enum values for ObjectLockLegalHoldStatus\nconst (\n\tObjectLockLegalHoldStatusOn  ObjectLockLegalHoldStatus = \"ON\"\n\tObjectLockLegalHoldStatusOff ObjectLockLegalHoldStatus = \"OFF\"\n)\n\n// Values returns all known values for ObjectLockLegalHoldStatus. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectLockLegalHoldStatus) Values() []ObjectLockLegalHoldStatus {\n\treturn []ObjectLockLegalHoldStatus{\n\t\t\"ON\",\n\t\t\"OFF\",\n\t}\n}\n\ntype ObjectLockMode string\n\n// Enum values for ObjectLockMode\nconst (\n\tObjectLockModeGovernance ObjectLockMode = \"GOVERNANCE\"\n\tObjectLockModeCompliance ObjectLockMode = \"COMPLIANCE\"\n)\n\n// Values returns all known values for ObjectLockMode. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectLockMode) Values() []ObjectLockMode {\n\treturn []ObjectLockMode{\n\t\t\"GOVERNANCE\",\n\t\t\"COMPLIANCE\",\n\t}\n}\n\ntype ObjectLockRetentionMode string\n\n// Enum values for ObjectLockRetentionMode\nconst (\n\tObjectLockRetentionModeGovernance ObjectLockRetentionMode = \"GOVERNANCE\"\n\tObjectLockRetentionModeCompliance ObjectLockRetentionMode = \"COMPLIANCE\"\n)\n\n// Values returns all known values for ObjectLockRetentionMode. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectLockRetentionMode) Values() []ObjectLockRetentionMode {\n\treturn []ObjectLockRetentionMode{\n\t\t\"GOVERNANCE\",\n\t\t\"COMPLIANCE\",\n\t}\n}\n\ntype ObjectOwnership string\n\n// Enum values for ObjectOwnership\nconst (\n\tObjectOwnershipBucketOwnerPreferred ObjectOwnership = \"BucketOwnerPreferred\"\n\tObjectOwnershipObjectWriter         ObjectOwnership = \"ObjectWriter\"\n\tObjectOwnershipBucketOwnerEnforced  ObjectOwnership = \"BucketOwnerEnforced\"\n)\n\n// Values returns all known values for ObjectOwnership. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectOwnership) Values() []ObjectOwnership {\n\treturn []ObjectOwnership{\n\t\t\"BucketOwnerPreferred\",\n\t\t\"ObjectWriter\",\n\t\t\"BucketOwnerEnforced\",\n\t}\n}\n\ntype ObjectStorageClass string\n\n// Enum values for ObjectStorageClass\nconst (\n\tObjectStorageClassStandard           ObjectStorageClass = \"STANDARD\"\n\tObjectStorageClassReducedRedundancy  ObjectStorageClass = \"REDUCED_REDUNDANCY\"\n\tObjectStorageClassGlacier            ObjectStorageClass = \"GLACIER\"\n\tObjectStorageClassStandardIa         ObjectStorageClass = \"STANDARD_IA\"\n\tObjectStorageClassOnezoneIa          ObjectStorageClass = \"ONEZONE_IA\"\n\tObjectStorageClassIntelligentTiering ObjectStorageClass = \"INTELLIGENT_TIERING\"\n\tObjectStorageClassDeepArchive        ObjectStorageClass = \"DEEP_ARCHIVE\"\n\tObjectStorageClassOutposts           ObjectStorageClass = \"OUTPOSTS\"\n\tObjectStorageClassGlacierIr          ObjectStorageClass = \"GLACIER_IR\"\n\tObjectStorageClassSnow               ObjectStorageClass = \"SNOW\"\n\tObjectStorageClassExpressOnezone     ObjectStorageClass = \"EXPRESS_ONEZONE\"\n\tObjectStorageClassFsxOpenzfs         ObjectStorageClass = \"FSX_OPENZFS\"\n)\n\n// Values returns all known values for ObjectStorageClass. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectStorageClass) Values() []ObjectStorageClass {\n\treturn []ObjectStorageClass{\n\t\t\"STANDARD\",\n\t\t\"REDUCED_REDUNDANCY\",\n\t\t\"GLACIER\",\n\t\t\"STANDARD_IA\",\n\t\t\"ONEZONE_IA\",\n\t\t\"INTELLIGENT_TIERING\",\n\t\t\"DEEP_ARCHIVE\",\n\t\t\"OUTPOSTS\",\n\t\t\"GLACIER_IR\",\n\t\t\"SNOW\",\n\t\t\"EXPRESS_ONEZONE\",\n\t\t\"FSX_OPENZFS\",\n\t}\n}\n\ntype ObjectVersionStorageClass string\n\n// Enum values for ObjectVersionStorageClass\nconst (\n\tObjectVersionStorageClassStandard ObjectVersionStorageClass = \"STANDARD\"\n)\n\n// Values returns all known values for ObjectVersionStorageClass. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ObjectVersionStorageClass) Values() []ObjectVersionStorageClass {\n\treturn []ObjectVersionStorageClass{\n\t\t\"STANDARD\",\n\t}\n}\n\ntype OptionalObjectAttributes string\n\n// Enum values for OptionalObjectAttributes\nconst (\n\tOptionalObjectAttributesRestoreStatus OptionalObjectAttributes = \"RestoreStatus\"\n)\n\n// Values returns all known values for OptionalObjectAttributes. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (OptionalObjectAttributes) Values() []OptionalObjectAttributes {\n\treturn []OptionalObjectAttributes{\n\t\t\"RestoreStatus\",\n\t}\n}\n\ntype OwnerOverride string\n\n// Enum values for OwnerOverride\nconst (\n\tOwnerOverrideDestination OwnerOverride = \"Destination\"\n)\n\n// Values returns all known values for OwnerOverride. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (OwnerOverride) Values() []OwnerOverride {\n\treturn []OwnerOverride{\n\t\t\"Destination\",\n\t}\n}\n\ntype PartitionDateSource string\n\n// Enum values for PartitionDateSource\nconst (\n\tPartitionDateSourceEventTime    PartitionDateSource = \"EventTime\"\n\tPartitionDateSourceDeliveryTime PartitionDateSource = \"DeliveryTime\"\n)\n\n// Values returns all known values for PartitionDateSource. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (PartitionDateSource) Values() []PartitionDateSource {\n\treturn []PartitionDateSource{\n\t\t\"EventTime\",\n\t\t\"DeliveryTime\",\n\t}\n}\n\ntype Payer string\n\n// Enum values for Payer\nconst (\n\tPayerRequester   Payer = \"Requester\"\n\tPayerBucketOwner Payer = \"BucketOwner\"\n)\n\n// Values returns all known values for Payer. Note that this can be expanded in\n// the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (Payer) Values() []Payer {\n\treturn []Payer{\n\t\t\"Requester\",\n\t\t\"BucketOwner\",\n\t}\n}\n\ntype Permission string\n\n// Enum values for Permission\nconst (\n\tPermissionFullControl Permission = \"FULL_CONTROL\"\n\tPermissionWrite       Permission = \"WRITE\"\n\tPermissionWriteAcp    Permission = \"WRITE_ACP\"\n\tPermissionRead        Permission = \"READ\"\n\tPermissionReadAcp     Permission = \"READ_ACP\"\n)\n\n// Values returns all known values for Permission. Note that this can be expanded\n// in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (Permission) Values() []Permission {\n\treturn []Permission{\n\t\t\"FULL_CONTROL\",\n\t\t\"WRITE\",\n\t\t\"WRITE_ACP\",\n\t\t\"READ\",\n\t\t\"READ_ACP\",\n\t}\n}\n\ntype Protocol string\n\n// Enum values for Protocol\nconst (\n\tProtocolHttp  Protocol = \"http\"\n\tProtocolHttps Protocol = \"https\"\n)\n\n// Values returns all known values for Protocol. Note that this can be expanded in\n// the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (Protocol) Values() []Protocol {\n\treturn []Protocol{\n\t\t\"http\",\n\t\t\"https\",\n\t}\n}\n\ntype QuoteFields string\n\n// Enum values for QuoteFields\nconst (\n\tQuoteFieldsAlways   QuoteFields = \"ALWAYS\"\n\tQuoteFieldsAsneeded QuoteFields = \"ASNEEDED\"\n)\n\n// Values returns all known values for QuoteFields. Note that this can be expanded\n// in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (QuoteFields) Values() []QuoteFields {\n\treturn []QuoteFields{\n\t\t\"ALWAYS\",\n\t\t\"ASNEEDED\",\n\t}\n}\n\ntype ReplicaModificationsStatus string\n\n// Enum values for ReplicaModificationsStatus\nconst (\n\tReplicaModificationsStatusEnabled  ReplicaModificationsStatus = \"Enabled\"\n\tReplicaModificationsStatusDisabled ReplicaModificationsStatus = \"Disabled\"\n)\n\n// Values returns all known values for ReplicaModificationsStatus. Note that this\n// can be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ReplicaModificationsStatus) Values() []ReplicaModificationsStatus {\n\treturn []ReplicaModificationsStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype ReplicationRuleStatus string\n\n// Enum values for ReplicationRuleStatus\nconst (\n\tReplicationRuleStatusEnabled  ReplicationRuleStatus = \"Enabled\"\n\tReplicationRuleStatusDisabled ReplicationRuleStatus = \"Disabled\"\n)\n\n// Values returns all known values for ReplicationRuleStatus. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ReplicationRuleStatus) Values() []ReplicationRuleStatus {\n\treturn []ReplicationRuleStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype ReplicationStatus string\n\n// Enum values for ReplicationStatus\nconst (\n\tReplicationStatusComplete  ReplicationStatus = \"COMPLETE\"\n\tReplicationStatusPending   ReplicationStatus = \"PENDING\"\n\tReplicationStatusFailed    ReplicationStatus = \"FAILED\"\n\tReplicationStatusReplica   ReplicationStatus = \"REPLICA\"\n\tReplicationStatusCompleted ReplicationStatus = \"COMPLETED\"\n)\n\n// Values returns all known values for ReplicationStatus. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ReplicationStatus) Values() []ReplicationStatus {\n\treturn []ReplicationStatus{\n\t\t\"COMPLETE\",\n\t\t\"PENDING\",\n\t\t\"FAILED\",\n\t\t\"REPLICA\",\n\t\t\"COMPLETED\",\n\t}\n}\n\ntype ReplicationTimeStatus string\n\n// Enum values for ReplicationTimeStatus\nconst (\n\tReplicationTimeStatusEnabled  ReplicationTimeStatus = \"Enabled\"\n\tReplicationTimeStatusDisabled ReplicationTimeStatus = \"Disabled\"\n)\n\n// Values returns all known values for ReplicationTimeStatus. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ReplicationTimeStatus) Values() []ReplicationTimeStatus {\n\treturn []ReplicationTimeStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype RequestCharged string\n\n// Enum values for RequestCharged\nconst (\n\tRequestChargedRequester RequestCharged = \"requester\"\n)\n\n// Values returns all known values for RequestCharged. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (RequestCharged) Values() []RequestCharged {\n\treturn []RequestCharged{\n\t\t\"requester\",\n\t}\n}\n\ntype RequestPayer string\n\n// Enum values for RequestPayer\nconst (\n\tRequestPayerRequester RequestPayer = \"requester\"\n)\n\n// Values returns all known values for RequestPayer. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (RequestPayer) Values() []RequestPayer {\n\treturn []RequestPayer{\n\t\t\"requester\",\n\t}\n}\n\ntype RestoreRequestType string\n\n// Enum values for RestoreRequestType\nconst (\n\tRestoreRequestTypeSelect RestoreRequestType = \"SELECT\"\n)\n\n// Values returns all known values for RestoreRequestType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (RestoreRequestType) Values() []RestoreRequestType {\n\treturn []RestoreRequestType{\n\t\t\"SELECT\",\n\t}\n}\n\ntype S3TablesBucketType string\n\n// Enum values for S3TablesBucketType\nconst (\n\tS3TablesBucketTypeAws      S3TablesBucketType = \"aws\"\n\tS3TablesBucketTypeCustomer S3TablesBucketType = \"customer\"\n)\n\n// Values returns all known values for S3TablesBucketType. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (S3TablesBucketType) Values() []S3TablesBucketType {\n\treturn []S3TablesBucketType{\n\t\t\"aws\",\n\t\t\"customer\",\n\t}\n}\n\ntype ServerSideEncryption string\n\n// Enum values for ServerSideEncryption\nconst (\n\tServerSideEncryptionAes256     ServerSideEncryption = \"AES256\"\n\tServerSideEncryptionAwsFsx     ServerSideEncryption = \"aws:fsx\"\n\tServerSideEncryptionAwsKms     ServerSideEncryption = \"aws:kms\"\n\tServerSideEncryptionAwsKmsDsse ServerSideEncryption = \"aws:kms:dsse\"\n)\n\n// Values returns all known values for ServerSideEncryption. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (ServerSideEncryption) Values() []ServerSideEncryption {\n\treturn []ServerSideEncryption{\n\t\t\"AES256\",\n\t\t\"aws:fsx\",\n\t\t\"aws:kms\",\n\t\t\"aws:kms:dsse\",\n\t}\n}\n\ntype SessionMode string\n\n// Enum values for SessionMode\nconst (\n\tSessionModeReadOnly  SessionMode = \"ReadOnly\"\n\tSessionModeReadWrite SessionMode = \"ReadWrite\"\n)\n\n// Values returns all known values for SessionMode. Note that this can be expanded\n// in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (SessionMode) Values() []SessionMode {\n\treturn []SessionMode{\n\t\t\"ReadOnly\",\n\t\t\"ReadWrite\",\n\t}\n}\n\ntype SseKmsEncryptedObjectsStatus string\n\n// Enum values for SseKmsEncryptedObjectsStatus\nconst (\n\tSseKmsEncryptedObjectsStatusEnabled  SseKmsEncryptedObjectsStatus = \"Enabled\"\n\tSseKmsEncryptedObjectsStatusDisabled SseKmsEncryptedObjectsStatus = \"Disabled\"\n)\n\n// Values returns all known values for SseKmsEncryptedObjectsStatus. Note that\n// this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (SseKmsEncryptedObjectsStatus) Values() []SseKmsEncryptedObjectsStatus {\n\treturn []SseKmsEncryptedObjectsStatus{\n\t\t\"Enabled\",\n\t\t\"Disabled\",\n\t}\n}\n\ntype StorageClass string\n\n// Enum values for StorageClass\nconst (\n\tStorageClassStandard           StorageClass = \"STANDARD\"\n\tStorageClassReducedRedundancy  StorageClass = \"REDUCED_REDUNDANCY\"\n\tStorageClassStandardIa         StorageClass = \"STANDARD_IA\"\n\tStorageClassOnezoneIa          StorageClass = \"ONEZONE_IA\"\n\tStorageClassIntelligentTiering StorageClass = \"INTELLIGENT_TIERING\"\n\tStorageClassGlacier            StorageClass = \"GLACIER\"\n\tStorageClassDeepArchive        StorageClass = \"DEEP_ARCHIVE\"\n\tStorageClassOutposts           StorageClass = \"OUTPOSTS\"\n\tStorageClassGlacierIr          StorageClass = \"GLACIER_IR\"\n\tStorageClassSnow               StorageClass = \"SNOW\"\n\tStorageClassExpressOnezone     StorageClass = \"EXPRESS_ONEZONE\"\n\tStorageClassFsxOpenzfs         StorageClass = \"FSX_OPENZFS\"\n)\n\n// Values returns all known values for StorageClass. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (StorageClass) Values() []StorageClass {\n\treturn []StorageClass{\n\t\t\"STANDARD\",\n\t\t\"REDUCED_REDUNDANCY\",\n\t\t\"STANDARD_IA\",\n\t\t\"ONEZONE_IA\",\n\t\t\"INTELLIGENT_TIERING\",\n\t\t\"GLACIER\",\n\t\t\"DEEP_ARCHIVE\",\n\t\t\"OUTPOSTS\",\n\t\t\"GLACIER_IR\",\n\t\t\"SNOW\",\n\t\t\"EXPRESS_ONEZONE\",\n\t\t\"FSX_OPENZFS\",\n\t}\n}\n\ntype StorageClassAnalysisSchemaVersion string\n\n// Enum values for StorageClassAnalysisSchemaVersion\nconst (\n\tStorageClassAnalysisSchemaVersionV1 StorageClassAnalysisSchemaVersion = \"V_1\"\n)\n\n// Values returns all known values for StorageClassAnalysisSchemaVersion. Note\n// that this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (StorageClassAnalysisSchemaVersion) Values() []StorageClassAnalysisSchemaVersion {\n\treturn []StorageClassAnalysisSchemaVersion{\n\t\t\"V_1\",\n\t}\n}\n\ntype TableSseAlgorithm string\n\n// Enum values for TableSseAlgorithm\nconst (\n\tTableSseAlgorithmAwsKms TableSseAlgorithm = \"aws:kms\"\n\tTableSseAlgorithmAes256 TableSseAlgorithm = \"AES256\"\n)\n\n// Values returns all known values for TableSseAlgorithm. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (TableSseAlgorithm) Values() []TableSseAlgorithm {\n\treturn []TableSseAlgorithm{\n\t\t\"aws:kms\",\n\t\t\"AES256\",\n\t}\n}\n\ntype TaggingDirective string\n\n// Enum values for TaggingDirective\nconst (\n\tTaggingDirectiveCopy    TaggingDirective = \"COPY\"\n\tTaggingDirectiveReplace TaggingDirective = \"REPLACE\"\n)\n\n// Values returns all known values for TaggingDirective. Note that this can be\n// expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (TaggingDirective) Values() []TaggingDirective {\n\treturn []TaggingDirective{\n\t\t\"COPY\",\n\t\t\"REPLACE\",\n\t}\n}\n\ntype Tier string\n\n// Enum values for Tier\nconst (\n\tTierStandard  Tier = \"Standard\"\n\tTierBulk      Tier = \"Bulk\"\n\tTierExpedited Tier = \"Expedited\"\n)\n\n// Values returns all known values for Tier. Note that this can be expanded in the\n// future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (Tier) Values() []Tier {\n\treturn []Tier{\n\t\t\"Standard\",\n\t\t\"Bulk\",\n\t\t\"Expedited\",\n\t}\n}\n\ntype TransitionDefaultMinimumObjectSize string\n\n// Enum values for TransitionDefaultMinimumObjectSize\nconst (\n\tTransitionDefaultMinimumObjectSizeVariesByStorageClass  TransitionDefaultMinimumObjectSize = \"varies_by_storage_class\"\n\tTransitionDefaultMinimumObjectSizeAllStorageClasses128k TransitionDefaultMinimumObjectSize = \"all_storage_classes_128K\"\n)\n\n// Values returns all known values for TransitionDefaultMinimumObjectSize. Note\n// that this can be expanded in the future, and so it is only as up to date as the\n// client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (TransitionDefaultMinimumObjectSize) Values() []TransitionDefaultMinimumObjectSize {\n\treturn []TransitionDefaultMinimumObjectSize{\n\t\t\"varies_by_storage_class\",\n\t\t\"all_storage_classes_128K\",\n\t}\n}\n\ntype TransitionStorageClass string\n\n// Enum values for TransitionStorageClass\nconst (\n\tTransitionStorageClassGlacier            TransitionStorageClass = \"GLACIER\"\n\tTransitionStorageClassStandardIa         TransitionStorageClass = \"STANDARD_IA\"\n\tTransitionStorageClassOnezoneIa          TransitionStorageClass = \"ONEZONE_IA\"\n\tTransitionStorageClassIntelligentTiering TransitionStorageClass = \"INTELLIGENT_TIERING\"\n\tTransitionStorageClassDeepArchive        TransitionStorageClass = \"DEEP_ARCHIVE\"\n\tTransitionStorageClassGlacierIr          TransitionStorageClass = \"GLACIER_IR\"\n)\n\n// Values returns all known values for TransitionStorageClass. Note that this can\n// be expanded in the future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (TransitionStorageClass) Values() []TransitionStorageClass {\n\treturn []TransitionStorageClass{\n\t\t\"GLACIER\",\n\t\t\"STANDARD_IA\",\n\t\t\"ONEZONE_IA\",\n\t\t\"INTELLIGENT_TIERING\",\n\t\t\"DEEP_ARCHIVE\",\n\t\t\"GLACIER_IR\",\n\t}\n}\n\ntype Type string\n\n// Enum values for Type\nconst (\n\tTypeCanonicalUser         Type = \"CanonicalUser\"\n\tTypeAmazonCustomerByEmail Type = \"AmazonCustomerByEmail\"\n\tTypeGroup                 Type = \"Group\"\n)\n\n// Values returns all known values for Type. Note that this can be expanded in the\n// future, and so it is only as up to date as the client.\n//\n// The ordering of this slice is not guaranteed to be stable across updates.\nfunc (Type) Values() []Type {\n\treturn []Type{\n\t\t\"CanonicalUser\",\n\t\t\"AmazonCustomerByEmail\",\n\t\t\"Group\",\n\t}\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/types/types.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage types\n\nimport (\n\tsmithydocument \"github.com/aws/smithy-go/document\"\n\t\"time\"\n)\n\n// The ABAC status of the general purpose bucket. When ABAC is enabled for the\n// general purpose bucket, you can use tags to manage access to the general purpose\n// buckets as well as for cost tracking purposes. When ABAC is disabled for the\n// general purpose buckets, you can only use tags for cost tracking purposes. For\n// more information, see [Using tags with S3 general purpose buckets].\n//\n// [Using tags with S3 general purpose buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging.html\ntype AbacStatus struct {\n\n\t// The ABAC status of the general purpose bucket.\n\tStatus BucketAbacStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the days since the initiation of an incomplete multipart upload that\n// Amazon S3 will wait before permanently removing all parts of the upload. For\n// more information, see [Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration]in the Amazon S3 User Guide.\n//\n// [Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration]: https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config\ntype AbortIncompleteMultipartUpload struct {\n\n\t// Specifies the number of days after which Amazon S3 aborts an incomplete\n\t// multipart upload.\n\tDaysAfterInitiation *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// Configures the transfer acceleration state for an Amazon S3 bucket. For more\n// information, see [Amazon S3 Transfer Acceleration]in the Amazon S3 User Guide.\n//\n// [Amazon S3 Transfer Acceleration]: https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html\ntype AccelerateConfiguration struct {\n\n\t// Specifies the transfer acceleration status of the bucket.\n\tStatus BucketAccelerateStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// Contains the elements that set the ACL permissions for an object per grantee.\ntype AccessControlPolicy struct {\n\n\t// A list of grants.\n\tGrants []Grant\n\n\t// Container for the bucket owner's display name and ID.\n\tOwner *Owner\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for information about access control for replicas.\ntype AccessControlTranslation struct {\n\n\t// Specifies the replica ownership. For default and valid values, see [PUT bucket replication] in the\n\t// Amazon S3 API Reference.\n\t//\n\t// [PUT bucket replication]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html\n\t//\n\t// This member is required.\n\tOwner OwnerOverride\n\n\tnoSmithyDocumentSerde\n}\n\n// A conjunction (logical AND) of predicates, which is used in evaluating a\n// metrics filter. The operator must have at least two predicates in any\n// combination, and an object must match all of the predicates for the filter to\n// apply.\ntype AnalyticsAndOperator struct {\n\n\t// The prefix to use when evaluating an AND predicate: The prefix that an object\n\t// must have to be included in the metrics results.\n\tPrefix *string\n\n\t// The list of tags to use when evaluating an AND predicate.\n\tTags []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the configuration and any analyses for the analytics filter of an\n// Amazon S3 bucket.\ntype AnalyticsConfiguration struct {\n\n\t// The ID that identifies the analytics configuration.\n\t//\n\t// This member is required.\n\tId *string\n\n\t//  Contains data related to access patterns to be collected and made available to\n\t// analyze the tradeoffs between different storage classes.\n\t//\n\t// This member is required.\n\tStorageClassAnalysis *StorageClassAnalysis\n\n\t// The filter used to describe a set of objects for analyses. A filter must have\n\t// exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no\n\t// filter is provided, all objects will be considered in any analysis.\n\tFilter AnalyticsFilter\n\n\tnoSmithyDocumentSerde\n}\n\n// Where to publish the analytics results.\ntype AnalyticsExportDestination struct {\n\n\t// A destination signifying output to an S3 bucket.\n\t//\n\t// This member is required.\n\tS3BucketDestination *AnalyticsS3BucketDestination\n\n\tnoSmithyDocumentSerde\n}\n\n// The filter used to describe a set of objects for analyses. A filter must have\n// exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no\n// filter is provided, all objects will be considered in any analysis.\n//\n// The following types satisfy this interface:\n//\n//\tAnalyticsFilterMemberAnd\n//\tAnalyticsFilterMemberPrefix\n//\tAnalyticsFilterMemberTag\ntype AnalyticsFilter interface {\n\tisAnalyticsFilter()\n}\n\n// A conjunction (logical AND) of predicates, which is used in evaluating an\n// analytics filter. The operator must have at least two predicates.\ntype AnalyticsFilterMemberAnd struct {\n\tValue AnalyticsAndOperator\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*AnalyticsFilterMemberAnd) isAnalyticsFilter() {}\n\n// The prefix to use when evaluating an analytics filter.\ntype AnalyticsFilterMemberPrefix struct {\n\tValue string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*AnalyticsFilterMemberPrefix) isAnalyticsFilter() {}\n\n// The tag to use when evaluating an analytics filter.\ntype AnalyticsFilterMemberTag struct {\n\tValue Tag\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*AnalyticsFilterMemberTag) isAnalyticsFilter() {}\n\n// Contains information about where to publish the analytics results.\ntype AnalyticsS3BucketDestination struct {\n\n\t// The Amazon Resource Name (ARN) of the bucket to which data is exported.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Specifies the file format used when exporting data to Amazon S3.\n\t//\n\t// This member is required.\n\tFormat AnalyticsS3ExportFileFormat\n\n\t// The account ID that owns the destination S3 bucket. If no account ID is\n\t// provided, the owner is not validated before exporting data.\n\t//\n\t// Although this value is optional, we strongly recommend that you set it to help\n\t// prevent problems if the destination bucket ownership changes.\n\tBucketAccountId *string\n\n\t// The prefix to use when exporting data. The prefix is prepended to all results.\n\tPrefix *string\n\n\tnoSmithyDocumentSerde\n}\n\n// A bucket-level setting for Amazon S3 general purpose buckets used to prevent\n// the upload of new objects encrypted with the specified server-side encryption\n// type. For example, blocking an encryption type will block PutObject , CopyObject\n// , PostObject , multipart upload, and replication requests to the bucket for\n// objects with the specified encryption type. However, you can continue to read\n// and list any pre-existing objects already encrypted with the specified\n// encryption type. For more information, see [Blocking an encryption type for a general purpose bucket].\n//\n// This data type is used with the following actions:\n//\n// [PutBucketEncryption]\n//\n// [GetBucketEncryption]\n//\n// [DeleteBucketEncryption]\n//\n// Permissions You must have the s3:PutEncryptionConfiguration permission to block\n// or unblock an encryption type for a bucket.\n//\n// You must have the s3:GetEncryptionConfiguration permission to view a bucket's\n// encryption type.\n//\n// [Blocking an encryption type for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/userguide/block-encryption-type.html\n// [GetBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketEncryption.html\n// [DeleteBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketEncryption.html\n// [PutBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketEncryption.html\ntype BlockedEncryptionTypes struct {\n\n\t// The object encryption type that you want to block or unblock for an Amazon S3\n\t// general purpose bucket.\n\t//\n\t// Currently, this parameter only supports blocking or unblocking server side\n\t// encryption with customer-provided keys (SSE-C). For more information about\n\t// SSE-C, see [Using server-side encryption with customer-provided keys (SSE-C)].\n\t//\n\t// [Using server-side encryption with customer-provided keys (SSE-C)]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html\n\tEncryptionType []EncryptionType\n\n\tnoSmithyDocumentSerde\n}\n\n// In terms of implementation, a Bucket is a resource.\ntype Bucket struct {\n\n\t// The Amazon Resource Name (ARN) of the S3 bucket. ARNs uniquely identify Amazon\n\t// Web Services resources across all of Amazon Web Services.\n\t//\n\t// This parameter is only supported for S3 directory buckets. For more\n\t// information, see [Using tags with directory buckets].\n\t//\n\t// [Using tags with directory buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-tagging.html\n\tBucketArn *string\n\n\t// BucketRegion indicates the Amazon Web Services region where the bucket is\n\t// located. If the request contains at least one valid parameter, it is included in\n\t// the response.\n\tBucketRegion *string\n\n\t// Date the bucket was created. This date can change when making changes to your\n\t// bucket, such as editing its bucket policy.\n\tCreationDate *time.Time\n\n\t// The name of the bucket.\n\tName *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the information about the bucket that will be created. For more\n// information about directory buckets, see [Directory buckets]in the Amazon S3 User Guide.\n//\n// This functionality is only supported by directory buckets.\n//\n// [Directory buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html\ntype BucketInfo struct {\n\n\t// The number of Zone (Availability Zone or Local Zone) that's used for redundancy\n\t// for the bucket.\n\tDataRedundancy DataRedundancy\n\n\t// The type of bucket.\n\tType BucketType\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For\n// more information, see [Object Lifecycle Management]in the Amazon S3 User Guide.\n//\n// [Object Lifecycle Management]: https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html\ntype BucketLifecycleConfiguration struct {\n\n\t// A lifecycle rule for individual objects in an Amazon S3 bucket.\n\t//\n\t// This member is required.\n\tRules []LifecycleRule\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for logging status information.\ntype BucketLoggingStatus struct {\n\n\t// Describes where logs are stored and the prefix that Amazon S3 assigns to all\n\t// log object keys for a bucket. For more information, see [PUT Bucket logging]in the Amazon S3 API\n\t// Reference.\n\t//\n\t// [PUT Bucket logging]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html\n\tLoggingEnabled *LoggingEnabled\n\n\tnoSmithyDocumentSerde\n}\n\n// Contains all the possible checksum or digest values for an object.\ntype Checksum struct {\n\n\t// The Base64 encoded, 32-bit CRC32 checksum of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use an API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumCRC32 *string\n\n\t// The Base64 encoded, 32-bit CRC32C checksum of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use an API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumCRC32C *string\n\n\t// The Base64 encoded, 64-bit CRC64NVME checksum of the object. This checksum is\n\t// present if the object was uploaded with the CRC64NVME checksum algorithm, or if\n\t// the object was uploaded without a checksum (and Amazon S3 added the default\n\t// checksum, CRC64NVME , to the uploaded object). For more information, see [Checking object integrity] in\n\t// the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// The Base64 encoded, 160-bit SHA1 digest of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use the API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumSHA1 *string\n\n\t// The Base64 encoded, 256-bit SHA256 digest of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. When you use an API\n\t// operation on an object that was uploaded using multipart uploads, this value may\n\t// not be a direct checksum value of the full object. Instead, it's a calculation\n\t// based on the checksum values of each individual part. For more information about\n\t// how checksums are calculated with multipart uploads, see [Checking object integrity]in the Amazon S3 User\n\t// Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html#large-object-checksums\n\tChecksumSHA256 *string\n\n\t// The checksum type that is used to calculate the objects checksum value. For\n\t// more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumType ChecksumType\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for all (if there are any) keys between Prefix and the next\n// occurrence of the string specified by a delimiter. CommonPrefixes lists keys\n// that act like subdirectories in the directory specified by Prefix. For example,\n// if the prefix is notes/ and the delimiter is a slash (/) as in\n// notes/summer/july, the common prefix is notes/summer/.\ntype CommonPrefix struct {\n\n\t// Container for the specified common prefix.\n\tPrefix *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The container for the completed multipart upload details.\ntype CompletedMultipartUpload struct {\n\n\t// Array of CompletedPart data types.\n\t//\n\t// If you do not supply a valid Part with your request, the service sends back an\n\t// HTTP 400 response.\n\tParts []CompletedPart\n\n\tnoSmithyDocumentSerde\n}\n\n// Details of the parts that were uploaded.\ntype CompletedPart struct {\n\n\t// The Base64 encoded, 32-bit CRC32 checksum of the part. This checksum is present\n\t// if the multipart upload request was created with the CRC32 checksum algorithm.\n\t// For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32 *string\n\n\t// The Base64 encoded, 32-bit CRC32C checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the CRC32C checksum\n\t// algorithm. For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32C *string\n\n\t// The Base64 encoded, 64-bit CRC64NVME checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the CRC64NVME checksum\n\t// algorithm to the uploaded object). For more information, see [Checking object integrity]in the Amazon S3\n\t// User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// The Base64 encoded, 160-bit SHA1 checksum of the part. This checksum is present\n\t// if the multipart upload request was created with the SHA1 checksum algorithm.\n\t// For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA1 *string\n\n\t// The Base64 encoded, 256-bit SHA256 checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the SHA256 checksum\n\t// algorithm. For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA256 *string\n\n\t// Entity tag returned when the part was uploaded.\n\tETag *string\n\n\t// Part number that identifies the part. This is a positive integer between 1 and\n\t// 10,000.\n\t//\n\t//   - General purpose buckets - In CompleteMultipartUpload , when a additional\n\t//   checksum (including x-amz-checksum-crc32 , x-amz-checksum-crc32c ,\n\t//   x-amz-checksum-sha1 , or x-amz-checksum-sha256 ) is applied to each part, the\n\t//   PartNumber must start at 1 and the part numbers must be consecutive.\n\t//   Otherwise, Amazon S3 generates an HTTP 400 Bad Request status code and an\n\t//   InvalidPartOrder error code.\n\t//\n\t//   - Directory buckets - In CompleteMultipartUpload , the PartNumber must start\n\t//   at 1 and the part numbers must be consecutive.\n\tPartNumber *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for describing a condition that must be met for the specified\n// redirect to apply. For example, 1. If request is for pages in the /docs folder,\n// redirect to the /documents folder. 2. If request results in HTTP error 4xx,\n// redirect request to another host where you might process the error.\ntype Condition struct {\n\n\t// The HTTP error code when the redirect is applied. In the event of an error, if\n\t// the error code equals this value, then the specified redirect is applied.\n\t// Required when parent element Condition is specified and sibling KeyPrefixEquals\n\t// is not specified. If both are specified, then both must be true for the redirect\n\t// to be applied.\n\tHttpErrorCodeReturnedEquals *string\n\n\t// The object key name prefix when the redirect is applied. For example, to\n\t// redirect requests for ExamplePage.html , the key prefix will be ExamplePage.html\n\t// . To redirect request for all pages with the prefix docs/ , the key prefix will\n\t// be /docs , which identifies all objects in the docs/ folder. Required when the\n\t// parent element Condition is specified and sibling HttpErrorCodeReturnedEquals\n\t// is not specified. If both conditions are specified, both must be true for the\n\t// redirect to be applied.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\tKeyPrefixEquals *string\n\n\tnoSmithyDocumentSerde\n}\n\ntype ContinuationEvent struct {\n\tnoSmithyDocumentSerde\n}\n\n// Container for all response elements.\ntype CopyObjectResult struct {\n\n\t// The Base64 encoded, 32-bit CRC32 checksum of the object. This checksum is only\n\t// present if the object was uploaded with the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32 *string\n\n\t// The Base64 encoded, 32-bit CRC32C checksum of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32C *string\n\n\t// The Base64 encoded, 64-bit CRC64NVME checksum of the object. This checksum is\n\t// present if the object being copied was uploaded with the CRC64NVME checksum\n\t// algorithm, or if the object was uploaded without a checksum (and Amazon S3 added\n\t// the default checksum, CRC64NVME , to the uploaded object). For more information,\n\t// see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// The Base64 encoded, 160-bit SHA1 digest of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA1 *string\n\n\t// The Base64 encoded, 256-bit SHA256 digest of the object. This checksum is only\n\t// present if the checksum was uploaded with the object. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA256 *string\n\n\t// The checksum type that is used to calculate the objects checksum value. For\n\t// more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumType ChecksumType\n\n\t// Returns the ETag of the new object. The ETag reflects only changes to the\n\t// contents of an object, not its metadata.\n\tETag *string\n\n\t// Creation date of the object.\n\tLastModified *time.Time\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for all response elements.\ntype CopyPartResult struct {\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 32-bit CRC32 checksum of the part. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32 *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 32-bit CRC32C checksum of the part. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32C *string\n\n\t// The Base64 encoded, 64-bit CRC64NVME checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the CRC64NVME checksum\n\t// algorithm to the uploaded object). For more information, see [Checking object integrity]in the Amazon S3\n\t// User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 160-bit SHA1 checksum of the part. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA1 *string\n\n\t// This header can be used as a data integrity check to verify that the data\n\t// received is the same data that was originally sent. This header specifies the\n\t// Base64 encoded, 256-bit SHA256 checksum of the part. For more information, see [Checking object integrity]\n\t// in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA256 *string\n\n\t// Entity tag of the object.\n\tETag *string\n\n\t// Date and time at which the object was uploaded.\n\tLastModified *time.Time\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes the cross-origin access configuration for objects in an Amazon S3\n// bucket. For more information, see [Enabling Cross-Origin Resource Sharing]in the Amazon S3 User Guide.\n//\n// [Enabling Cross-Origin Resource Sharing]: https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html\ntype CORSConfiguration struct {\n\n\t// A set of origins and methods (cross-origin access that you want to allow). You\n\t// can add up to 100 rules to the configuration.\n\t//\n\t// This member is required.\n\tCORSRules []CORSRule\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies a cross-origin access rule for an Amazon S3 bucket.\ntype CORSRule struct {\n\n\t// An HTTP method that you allow the origin to execute. Valid values are GET , PUT\n\t// , HEAD , POST , and DELETE .\n\t//\n\t// This member is required.\n\tAllowedMethods []string\n\n\t// One or more origins you want customers to be able to access the bucket from.\n\t//\n\t// This member is required.\n\tAllowedOrigins []string\n\n\t// Headers that are specified in the Access-Control-Request-Headers header. These\n\t// headers are allowed in a preflight OPTIONS request. In response to any preflight\n\t// OPTIONS request, Amazon S3 returns any requested headers that are allowed.\n\tAllowedHeaders []string\n\n\t// One or more headers in the response that you want customers to be able to\n\t// access from their applications (for example, from a JavaScript XMLHttpRequest\n\t// object).\n\tExposeHeaders []string\n\n\t// Unique identifier for the rule. The value cannot be longer than 255 characters.\n\tID *string\n\n\t// The time in seconds that your browser is to cache the preflight response for\n\t// the specified resource.\n\tMaxAgeSeconds *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// The configuration information for the bucket.\ntype CreateBucketConfiguration struct {\n\n\t// Specifies the information about the bucket that will be created.\n\t//\n\t// This functionality is only supported by directory buckets.\n\tBucket *BucketInfo\n\n\t// Specifies the location where the bucket will be created.\n\t//\n\t// Directory buckets - The location type is Availability Zone or Local Zone. To\n\t// use the Local Zone location type, your account must be enabled for Local Zones.\n\t// Otherwise, you get an HTTP 403 Forbidden error with the error code AccessDenied\n\t// . To learn more, see [Enable accounts for Local Zones]in the Amazon S3 User Guide.\n\t//\n\t// This functionality is only supported by directory buckets.\n\t//\n\t// [Enable accounts for Local Zones]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/opt-in-directory-bucket-lz.html\n\tLocation *LocationInfo\n\n\t// Specifies the Region where the bucket will be created. You might choose a\n\t// Region to optimize latency, minimize costs, or address regulatory requirements.\n\t// For example, if you reside in Europe, you will probably find it advantageous to\n\t// create buckets in the Europe (Ireland) Region.\n\t//\n\t// If you don't specify a Region, the bucket is created in the US East (N.\n\t// Virginia) Region (us-east-1) by default. Configurations using the value EU will\n\t// create a bucket in eu-west-1 .\n\t//\n\t// For a list of the valid values for all of the Amazon Web Services Regions, see [Regions and Endpoints].\n\t//\n\t// This functionality is not supported for directory buckets.\n\t//\n\t// [Regions and Endpoints]: https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region\n\tLocationConstraint BucketLocationConstraint\n\n\t// An array of tags that you can apply to the bucket that you're creating. Tags\n\t// are key-value pairs of metadata used to categorize and organize your buckets,\n\t// track costs, and control access.\n\t//\n\t// This parameter is only supported for S3 directory buckets. For more\n\t// information, see [Using tags with directory buckets].\n\t//\n\t// You must have the s3express:TagResource permission to create a directory bucket\n\t// with tags.\n\t//\n\t// [Using tags with directory buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-tagging.html\n\tTags []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes how an uncompressed comma-separated values (CSV)-formatted input\n// object is formatted.\ntype CSVInput struct {\n\n\t// Specifies that CSV field values may contain quoted record delimiters and such\n\t// records should be allowed. Default value is FALSE. Setting this value to TRUE\n\t// may lower performance.\n\tAllowQuotedRecordDelimiter *bool\n\n\t// A single character used to indicate that a row should be ignored when the\n\t// character is present at the start of that row. You can specify any character to\n\t// indicate a comment line. The default character is # .\n\t//\n\t// Default: #\n\tComments *string\n\n\t// A single character used to separate individual fields in a record. You can\n\t// specify an arbitrary delimiter.\n\tFieldDelimiter *string\n\n\t// Describes the first line of input. Valid values are:\n\t//\n\t//   - NONE : First line is not a header.\n\t//\n\t//   - IGNORE : First line is a header, but you can't use the header values to\n\t//   indicate the column in an expression. You can use column position (such as _1,\n\t//   _2, ) to indicate the column ( SELECT s._1 FROM OBJECT s ).\n\t//\n\t//   - Use : First line is a header, and you can use the header value to identify a\n\t//   column in an expression ( SELECT \"name\" FROM OBJECT ).\n\tFileHeaderInfo FileHeaderInfo\n\n\t// A single character used for escaping when the field delimiter is part of the\n\t// value. For example, if the value is a, b , Amazon S3 wraps this field value in\n\t// quotation marks, as follows: \" a , b \" .\n\t//\n\t// Type: String\n\t//\n\t// Default: \"\n\t//\n\t// Ancestors: CSV\n\tQuoteCharacter *string\n\n\t// A single character used for escaping the quotation mark character inside an\n\t// already escaped value. For example, the value \"\"\" a , b \"\"\" is parsed as \" a ,\n\t// b \" .\n\tQuoteEscapeCharacter *string\n\n\t// A single character used to separate individual records in the input. Instead of\n\t// the default value, you can specify an arbitrary delimiter.\n\tRecordDelimiter *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes how uncompressed comma-separated values (CSV)-formatted results are\n// formatted.\ntype CSVOutput struct {\n\n\t// The value used to separate individual fields in a record. You can specify an\n\t// arbitrary delimiter.\n\tFieldDelimiter *string\n\n\t// A single character used for escaping when the field delimiter is part of the\n\t// value. For example, if the value is a, b , Amazon S3 wraps this field value in\n\t// quotation marks, as follows: \" a , b \" .\n\tQuoteCharacter *string\n\n\t// The single character used for escaping the quote character inside an already\n\t// escaped value.\n\tQuoteEscapeCharacter *string\n\n\t// Indicates whether to use quotation marks around output fields.\n\t//\n\t//   - ALWAYS : Always use quotation marks for output fields.\n\t//\n\t//   - ASNEEDED : Use quotation marks for output fields when needed.\n\tQuoteFields QuoteFields\n\n\t// A single character used to separate individual records in the output. Instead\n\t// of the default value, you can specify an arbitrary delimiter.\n\tRecordDelimiter *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The container element for optionally specifying the default Object Lock\n// retention settings for new objects placed in the specified bucket.\n//\n//   - The DefaultRetention settings require both a mode and a period.\n//\n//   - The DefaultRetention period can be either Days or Years but you must select\n//     one. You cannot specify Days and Years at the same time.\ntype DefaultRetention struct {\n\n\t// The number of days that you want to specify for the default retention period.\n\t// Must be used with Mode .\n\tDays *int32\n\n\t// The default Object Lock retention mode you want to apply to new objects placed\n\t// in the specified bucket. Must be used with either Days or Years .\n\tMode ObjectLockRetentionMode\n\n\t// The number of years that you want to specify for the default retention period.\n\t// Must be used with Mode .\n\tYears *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for the objects to delete.\ntype Delete struct {\n\n\t// The object to delete.\n\t//\n\t// Directory buckets - For directory buckets, an object that's composed entirely\n\t// of whitespace characters is not supported by the DeleteObjects API operation.\n\t// The request will receive a 400 Bad Request error and none of the objects in the\n\t// request will be deleted.\n\t//\n\t// This member is required.\n\tObjects []ObjectIdentifier\n\n\t// Element to enable quiet mode for the request. When you add this element, you\n\t// must set its value to true .\n\tQuiet *bool\n\n\tnoSmithyDocumentSerde\n}\n\n// Information about the deleted object.\ntype DeletedObject struct {\n\n\t// Indicates whether the specified object version that was permanently deleted was\n\t// (true) or was not (false) a delete marker before deletion. In a simple DELETE,\n\t// this header indicates whether (true) or not (false) the current version of the\n\t// object is a delete marker. To learn more about delete markers, see [Working with delete markers].\n\t//\n\t// This functionality is not supported for directory buckets.\n\t//\n\t// [Working with delete markers]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/DeleteMarker.html\n\tDeleteMarker *bool\n\n\t// The version ID of the delete marker created as a result of the DELETE\n\t// operation. If you delete a specific object version, the value returned by this\n\t// header is the version ID of the object version deleted.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tDeleteMarkerVersionId *string\n\n\t// The name of the deleted object.\n\tKey *string\n\n\t// The version ID of the deleted object.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tVersionId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Information about the delete marker.\ntype DeleteMarkerEntry struct {\n\n\t// Specifies whether the object is (true) or is not (false) the latest version of\n\t// an object.\n\tIsLatest *bool\n\n\t// The object key.\n\tKey *string\n\n\t// Date and time when the object was last modified.\n\tLastModified *time.Time\n\n\t// The account that created the delete marker.\n\tOwner *Owner\n\n\t// Version ID of an object.\n\tVersionId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies whether Amazon S3 replicates delete markers. If you specify a Filter\n// in your replication configuration, you must also include a\n// DeleteMarkerReplication element. If your Filter includes a Tag element, the\n// DeleteMarkerReplication Status must be set to Disabled, because Amazon S3 does\n// not support replicating delete markers for tag-based rules. For an example\n// configuration, see [Basic Rule Configuration].\n//\n// For more information about delete marker replication, see [Basic Rule Configuration].\n//\n// If you are using an earlier version of the replication configuration, Amazon S3\n// handles replication of delete markers differently. For more information, see [Backward Compatibility].\n//\n// [Basic Rule Configuration]: https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html\n// [Backward Compatibility]: https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations\ntype DeleteMarkerReplication struct {\n\n\t// Indicates whether to replicate delete markers.\n\t//\n\t// Indicates whether to replicate delete markers.\n\tStatus DeleteMarkerReplicationStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies information about where to publish analysis or configuration results\n// for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).\ntype Destination struct {\n\n\t//  The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store\n\t// the results.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Specify this only in a cross-account scenario (where source and destination\n\t// bucket owners are not the same), and you want to change replica ownership to the\n\t// Amazon Web Services account that owns the destination bucket. If this is not\n\t// specified in the replication configuration, the replicas are owned by same\n\t// Amazon Web Services account that owns the source object.\n\tAccessControlTranslation *AccessControlTranslation\n\n\t// Destination bucket owner account ID. In a cross-account scenario, if you direct\n\t// Amazon S3 to change replica ownership to the Amazon Web Services account that\n\t// owns the destination bucket by specifying the AccessControlTranslation\n\t// property, this is the account ID of the destination bucket owner. For more\n\t// information, see [Replication Additional Configuration: Changing the Replica Owner]in the Amazon S3 User Guide.\n\t//\n\t// [Replication Additional Configuration: Changing the Replica Owner]: https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-change-owner.html\n\tAccount *string\n\n\t// A container that provides information about encryption. If\n\t// SourceSelectionCriteria is specified, you must specify this element.\n\tEncryptionConfiguration *EncryptionConfiguration\n\n\t//  A container specifying replication metrics-related settings enabling\n\t// replication metrics and events.\n\tMetrics *Metrics\n\n\t//  A container specifying S3 Replication Time Control (S3 RTC), including whether\n\t// S3 RTC is enabled and the time when all objects and operations on objects must\n\t// be replicated. Must be specified together with a Metrics block.\n\tReplicationTime *ReplicationTime\n\n\t//  The storage class to use when replicating objects, such as S3 Standard or\n\t// reduced redundancy. By default, Amazon S3 uses the storage class of the source\n\t// object to create the object replica.\n\t//\n\t// For valid values, see the StorageClass element of the [PUT Bucket replication] action in the Amazon S3\n\t// API Reference.\n\t//\n\t// FSX_OPENZFS is not an accepted value when replicating objects.\n\t//\n\t// [PUT Bucket replication]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html\n\tStorageClass StorageClass\n\n\tnoSmithyDocumentSerde\n}\n\n// The destination information for the S3 Metadata configuration.\ntype DestinationResult struct {\n\n\t//  The Amazon Resource Name (ARN) of the table bucket where the metadata\n\t// configuration is stored.\n\tTableBucketArn *string\n\n\t//  The type of the table bucket where the metadata configuration is stored. The\n\t// aws value indicates an Amazon Web Services managed table bucket, and the\n\t// customer value indicates a customer-managed table bucket. V2 metadata\n\t// configurations are stored in Amazon Web Services managed table buckets, and V1\n\t// metadata configurations are stored in customer-managed table buckets.\n\tTableBucketType S3TablesBucketType\n\n\t//  The namespace in the table bucket where the metadata tables for a metadata\n\t// configuration are stored.\n\tTableNamespace *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Contains the type of server-side encryption used.\ntype Encryption struct {\n\n\t// The server-side encryption algorithm used when storing job results in Amazon S3\n\t// (for example, AES256, aws:kms ).\n\t//\n\t// This member is required.\n\tEncryptionType ServerSideEncryption\n\n\t// If the encryption type is aws:kms , this optional value can be used to specify\n\t// the encryption context for the restore results.\n\tKMSContext *string\n\n\t// If the encryption type is aws:kms , this optional value specifies the ID of the\n\t// symmetric encryption customer managed key to use for encryption of job results.\n\t// Amazon S3 only supports symmetric encryption KMS keys. For more information, see\n\t// [Asymmetric keys in KMS]in the Amazon Web Services Key Management Service Developer Guide.\n\t//\n\t// [Asymmetric keys in KMS]: https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html\n\tKMSKeyId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies encryption-related information for an Amazon S3 bucket that is a\n// destination for replicated objects.\n//\n// If you're specifying a customer managed KMS key, we recommend using a fully\n// qualified KMS key ARN. If you use a KMS key alias instead, then KMS resolves the\n// key within the requesters account. This behavior can result in data that's\n// encrypted with a KMS key that belongs to the requester, and not the bucket\n// owner.\ntype EncryptionConfiguration struct {\n\n\t// Specifies the ID (Key ARN or Alias ARN) of the customer managed Amazon Web\n\t// Services KMS key stored in Amazon Web Services Key Management Service (KMS) for\n\t// the destination bucket. Amazon S3 uses this key to encrypt replica objects.\n\t// Amazon S3 only supports symmetric encryption KMS keys. For more information, see\n\t// [Asymmetric keys in Amazon Web Services KMS]in the Amazon Web Services Key Management Service Developer Guide.\n\t//\n\t// [Asymmetric keys in Amazon Web Services KMS]: https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html\n\tReplicaKmsKeyID *string\n\n\tnoSmithyDocumentSerde\n}\n\n// A message that indicates the request is complete and no more messages will be\n// sent. You should not assume that the request is complete until the client\n// receives an EndEvent .\ntype EndEvent struct {\n\tnoSmithyDocumentSerde\n}\n\n// Container for all error elements.\ntype Error struct {\n\n\t// The error code is a string that uniquely identifies an error condition. It is\n\t// meant to be read and understood by programs that detect and handle errors by\n\t// type. The following is a list of Amazon S3 error codes. For more information,\n\t// see [Error responses].\n\t//\n\t//   - Code: AccessDenied\n\t//\n\t//   - Description: Access Denied\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: AccountProblem\n\t//\n\t//   - Description: There is a problem with your Amazon Web Services account that\n\t//   prevents the action from completing successfully. Contact Amazon Web Services\n\t//   Support for further assistance.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: AllAccessDisabled\n\t//\n\t//   - Description: All access to this Amazon S3 resource has been disabled.\n\t//   Contact Amazon Web Services Support for further assistance.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: AmbiguousGrantByEmailAddress\n\t//\n\t//   - Description: The email address you provided is associated with more than\n\t//   one account.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: AuthorizationHeaderMalformed\n\t//\n\t//   - Description: The authorization header you provided is invalid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - HTTP Status Code: N/A\n\t//\n\t//   - Code: BadDigest\n\t//\n\t//   - Description: The Content-MD5 you specified did not match what we received.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: BucketAlreadyExists\n\t//\n\t//   - Description: The requested bucket name is not available. The bucket\n\t//   namespace is shared by all users of the system. Please select a different name\n\t//   and try again.\n\t//\n\t//   - HTTP Status Code: 409 Conflict\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: BucketAlreadyOwnedByYou\n\t//\n\t//   - Description: The bucket you tried to create already exists, and you own it.\n\t//   Amazon S3 returns this error in all Amazon Web Services Regions except in the\n\t//   North Virginia Region. For legacy compatibility, if you re-create an existing\n\t//   bucket that you already own in the North Virginia Region, Amazon S3 returns 200\n\t//   OK and resets the bucket access control lists (ACLs).\n\t//\n\t//   - Code: 409 Conflict (in all Regions except the North Virginia Region)\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: BucketNotEmpty\n\t//\n\t//   - Description: The bucket you tried to delete is not empty.\n\t//\n\t//   - HTTP Status Code: 409 Conflict\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: CredentialsNotSupported\n\t//\n\t//   - Description: This request does not support credentials.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: CrossLocationLoggingProhibited\n\t//\n\t//   - Description: Cross-location logging not allowed. Buckets in one geographic\n\t//   location cannot log information to a bucket in another location.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: EntityTooSmall\n\t//\n\t//   - Description: Your proposed upload is smaller than the minimum allowed\n\t//   object size.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: EntityTooLarge\n\t//\n\t//   - Description: Your proposed upload exceeds the maximum allowed object size.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: ExpiredToken\n\t//\n\t//   - Description: The provided token has expired.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: IllegalVersioningConfigurationException\n\t//\n\t//   - Description: Indicates that the versioning configuration specified in the\n\t//   request is invalid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: IncompleteBody\n\t//\n\t//   - Description: You did not provide the number of bytes specified by the\n\t//   Content-Length HTTP header\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: IncorrectNumberOfFilesInPostRequest\n\t//\n\t//   - Description: POST requires exactly one file upload per request.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InlineDataTooLarge\n\t//\n\t//   - Description: Inline data exceeds the maximum allowed size.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InternalError\n\t//\n\t//   - Description: We encountered an internal error. Please try again.\n\t//\n\t//   - HTTP Status Code: 500 Internal Server Error\n\t//\n\t//   - SOAP Fault Code Prefix: Server\n\t//\n\t//   - Code: InvalidAccessKeyId\n\t//\n\t//   - Description: The Amazon Web Services access key ID you provided does not\n\t//   exist in our records.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidAddressingHeader\n\t//\n\t//   - Description: You must specify the Anonymous role.\n\t//\n\t//   - HTTP Status Code: N/A\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidArgument\n\t//\n\t//   - Description: Invalid Argument\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidBucketName\n\t//\n\t//   - Description: The specified bucket is not valid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidBucketState\n\t//\n\t//   - Description: The request is not valid with the current state of the bucket.\n\t//\n\t//   - HTTP Status Code: 409 Conflict\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidDigest\n\t//\n\t//   - Description: The Content-MD5 you specified is not valid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidEncryptionAlgorithmError\n\t//\n\t//   - Description: The encryption request you specified is not valid. The valid\n\t//   value is AES256.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidLocationConstraint\n\t//\n\t//   - Description: The specified location constraint is not valid. For more\n\t//   information about Regions, see [How to Select a Region for Your Buckets].\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidObjectState\n\t//\n\t//   - Description: The action is not valid for the current state of the object.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidPart\n\t//\n\t//   - Description: One or more of the specified parts could not be found. The\n\t//   part might not have been uploaded, or the specified entity tag might not have\n\t//   matched the part's entity tag.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidPartOrder\n\t//\n\t//   - Description: The list of parts was not in ascending order. Parts list must\n\t//   be specified in order by part number.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidPayer\n\t//\n\t//   - Description: All access to this object has been disabled. Please contact\n\t//   Amazon Web Services Support for further assistance.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidPolicyDocument\n\t//\n\t//   - Description: The content of the form does not meet the conditions specified\n\t//   in the policy document.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidRange\n\t//\n\t//   - Description: The requested range cannot be satisfied.\n\t//\n\t//   - HTTP Status Code: 416 Requested Range Not Satisfiable\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Please use AWS4-HMAC-SHA256 .\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: SOAP requests must be made over an HTTPS connection.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Acceleration is not supported for buckets\n\t//   with non-DNS compliant names.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Acceleration is not supported for buckets\n\t//   with periods (.) in their names.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Accelerate endpoint only supports virtual\n\t//   style requests.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Accelerate is not configured on this bucket.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Accelerate is disabled on this bucket.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Acceleration is not supported on this\n\t//   bucket. Contact Amazon Web Services Support for more information.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidRequest\n\t//\n\t//   - Description: Amazon S3 Transfer Acceleration cannot be enabled on this\n\t//   bucket. Contact Amazon Web Services Support for more information.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - Code: N/A\n\t//\n\t//   - Code: InvalidSecurity\n\t//\n\t//   - Description: The provided security credentials are not valid.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidSOAPRequest\n\t//\n\t//   - Description: The SOAP request body is invalid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidStorageClass\n\t//\n\t//   - Description: The storage class you specified is not valid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidTargetBucketForLogging\n\t//\n\t//   - Description: The target bucket for logging does not exist, is not owned by\n\t//   you, or does not have the appropriate grants for the log-delivery group.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidToken\n\t//\n\t//   - Description: The provided token is malformed or otherwise invalid.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: InvalidURI\n\t//\n\t//   - Description: Couldn't parse the specified URI.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: KeyTooLongError\n\t//\n\t//   - Description: Your key is too long.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MalformedACLError\n\t//\n\t//   - Description: The XML you provided was not well-formed or did not validate\n\t//   against our published schema.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MalformedPOSTRequest\n\t//\n\t//   - Description: The body of your POST request is not well-formed\n\t//   multipart/form-data.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MalformedXML\n\t//\n\t//   - Description: This happens when the user sends malformed XML (XML that\n\t//   doesn't conform to the published XSD) for the configuration. The error message\n\t//   is, \"The XML you provided was not well-formed or did not validate against our\n\t//   published schema.\"\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MaxMessageLengthExceeded\n\t//\n\t//   - Description: Your request was too big.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MaxPostPreDataLengthExceededError\n\t//\n\t//   - Description: Your POST request fields preceding the upload file were too\n\t//   large.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MetadataTooLarge\n\t//\n\t//   - Description: Your metadata headers exceed the maximum allowed metadata size.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MethodNotAllowed\n\t//\n\t//   - Description: The specified method is not allowed against this resource.\n\t//\n\t//   - HTTP Status Code: 405 Method Not Allowed\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MissingAttachment\n\t//\n\t//   - Description: A SOAP attachment was expected, but none were found.\n\t//\n\t//   - HTTP Status Code: N/A\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MissingContentLength\n\t//\n\t//   - Description: You must provide the Content-Length HTTP header.\n\t//\n\t//   - HTTP Status Code: 411 Length Required\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MissingRequestBodyError\n\t//\n\t//   - Description: This happens when the user sends an empty XML document as a\n\t//   request. The error message is, \"Request body is empty.\"\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MissingSecurityElement\n\t//\n\t//   - Description: The SOAP 1.1 request is missing a security element.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: MissingSecurityHeader\n\t//\n\t//   - Description: Your request is missing a required header.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoLoggingStatusForKey\n\t//\n\t//   - Description: There is no such thing as a logging status subresource for a\n\t//   key.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoSuchBucket\n\t//\n\t//   - Description: The specified bucket does not exist.\n\t//\n\t//   - HTTP Status Code: 404 Not Found\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoSuchBucketPolicy\n\t//\n\t//   - Description: The specified bucket does not have a bucket policy.\n\t//\n\t//   - HTTP Status Code: 404 Not Found\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoSuchKey\n\t//\n\t//   - Description: The specified key does not exist.\n\t//\n\t//   - HTTP Status Code: 404 Not Found\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoSuchLifecycleConfiguration\n\t//\n\t//   - Description: The lifecycle configuration does not exist.\n\t//\n\t//   - HTTP Status Code: 404 Not Found\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoSuchUpload\n\t//\n\t//   - Description: The specified multipart upload does not exist. The upload ID\n\t//   might be invalid, or the multipart upload might have been aborted or completed.\n\t//\n\t//   - HTTP Status Code: 404 Not Found\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NoSuchVersion\n\t//\n\t//   - Description: Indicates that the version ID specified in the request does\n\t//   not match an existing version.\n\t//\n\t//   - HTTP Status Code: 404 Not Found\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: NotImplemented\n\t//\n\t//   - Description: A header you provided implies functionality that is not\n\t//   implemented.\n\t//\n\t//   - HTTP Status Code: 501 Not Implemented\n\t//\n\t//   - SOAP Fault Code Prefix: Server\n\t//\n\t//   - Code: NotSignedUp\n\t//\n\t//   - Description: Your account is not signed up for the Amazon S3 service. You\n\t//   must sign up before you can use Amazon S3. You can sign up at the following URL:\n\t//   [Amazon S3]\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: OperationAborted\n\t//\n\t//   - Description: A conflicting conditional action is currently in progress\n\t//   against this resource. Try again.\n\t//\n\t//   - HTTP Status Code: 409 Conflict\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: PermanentRedirect\n\t//\n\t//   - Description: The bucket you are attempting to access must be addressed\n\t//   using the specified endpoint. Send all future requests to this endpoint.\n\t//\n\t//   - HTTP Status Code: 301 Moved Permanently\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: PreconditionFailed\n\t//\n\t//   - Description: At least one of the preconditions you specified did not hold.\n\t//\n\t//   - HTTP Status Code: 412 Precondition Failed\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: Redirect\n\t//\n\t//   - Description: Temporary redirect.\n\t//\n\t//   - HTTP Status Code: 307 Moved Temporarily\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: RestoreAlreadyInProgress\n\t//\n\t//   - Description: Object restore is already in progress.\n\t//\n\t//   - HTTP Status Code: 409 Conflict\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: RequestIsNotMultiPartContent\n\t//\n\t//   - Description: Bucket POST must be of the enclosure-type multipart/form-data.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: RequestTimeout\n\t//\n\t//   - Description: Your socket connection to the server was not read from or\n\t//   written to within the timeout period.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: RequestTimeTooSkewed\n\t//\n\t//   - Description: The difference between the request time and the server's time\n\t//   is too large.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: RequestTorrentOfBucketError\n\t//\n\t//   - Description: Requesting the torrent file of a bucket is not permitted.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: SignatureDoesNotMatch\n\t//\n\t//   - Description: The request signature we calculated does not match the\n\t//   signature you provided. Check your Amazon Web Services secret access key and\n\t//   signing method. For more information, see [REST Authentication]and [SOAP Authentication]for details.\n\t//\n\t//   - HTTP Status Code: 403 Forbidden\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: ServiceUnavailable\n\t//\n\t//   - Description: Service is unable to handle request.\n\t//\n\t//   - HTTP Status Code: 503 Service Unavailable\n\t//\n\t//   - SOAP Fault Code Prefix: Server\n\t//\n\t//   - Code: SlowDown\n\t//\n\t//   - Description: Reduce your request rate.\n\t//\n\t//   - HTTP Status Code: 503 Slow Down\n\t//\n\t//   - SOAP Fault Code Prefix: Server\n\t//\n\t//   - Code: TemporaryRedirect\n\t//\n\t//   - Description: You are being redirected to the bucket while DNS updates.\n\t//\n\t//   - HTTP Status Code: 307 Moved Temporarily\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: TokenRefreshRequired\n\t//\n\t//   - Description: The provided token must be refreshed.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: TooManyBuckets\n\t//\n\t//   - Description: You have attempted to create more buckets than allowed.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: UnexpectedContent\n\t//\n\t//   - Description: This request does not support content.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: UnresolvableGrantByEmailAddress\n\t//\n\t//   - Description: The email address you provided does not match any account on\n\t//   record.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t//   - Code: UserKeyMustBeSpecified\n\t//\n\t//   - Description: The bucket POST must contain the specified field name. If it\n\t//   is specified, check the order of the fields.\n\t//\n\t//   - HTTP Status Code: 400 Bad Request\n\t//\n\t//   - SOAP Fault Code Prefix: Client\n\t//\n\t// [How to Select a Region for Your Buckets]: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro\n\t// [Error responses]: https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n\t// [REST Authentication]: https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html\n\t// [Amazon S3]: http://aws.amazon.com/s3\n\t// [SOAP Authentication]: https://docs.aws.amazon.com/AmazonS3/latest/dev/SOAPAuthentication.html\n\tCode *string\n\n\t// The error key.\n\tKey *string\n\n\t// The error message contains a generic description of the error condition in\n\t// English. It is intended for a human audience. Simple programs display the\n\t// message directly to the end user if they encounter an error condition they don't\n\t// know how or don't care to handle. Sophisticated programs with more exhaustive\n\t// error handling and proper internationalization are more likely to ignore the\n\t// error message.\n\tMessage *string\n\n\t// The version ID of the error.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tVersionId *string\n\n\tnoSmithyDocumentSerde\n}\n\n//\tIf an S3 Metadata V1 CreateBucketMetadataTableConfiguration or V2\n//\n// CreateBucketMetadataConfiguration request succeeds, but S3 Metadata was unable\n// to create the table, this structure contains the error code and error message.\n//\n// If you created your S3 Metadata configuration before July 15, 2025, we\n// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n// can expire journal table records and create a live inventory table.\n//\n// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\ntype ErrorDetails struct {\n\n\t//  If the V1 CreateBucketMetadataTableConfiguration request succeeds, but S3\n\t// Metadata was unable to create the table, this structure contains the error code.\n\t// The possible error codes and error messages are as follows:\n\t//\n\t//   - AccessDeniedCreatingResources - You don't have sufficient permissions to\n\t//   create the required resources. Make sure that you have\n\t//   s3tables:CreateNamespace , s3tables:CreateTable , s3tables:GetTable and\n\t//   s3tables:PutTablePolicy permissions, and then try again. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - AccessDeniedWritingToTable - Unable to write to the metadata table because\n\t//   of missing resource permissions. To fix the resource policy, Amazon S3 needs to\n\t//   create a new metadata table. To create a new metadata table, you must delete the\n\t//   metadata configuration for this bucket, and then create a new metadata\n\t//   configuration.\n\t//\n\t//   - DestinationTableNotFound - The destination table doesn't exist. To create a\n\t//   new metadata table, you must delete the metadata configuration for this bucket,\n\t//   and then create a new metadata configuration.\n\t//\n\t//   - ServerInternalError - An internal error has occurred. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - TableAlreadyExists - The table that you specified already exists in the\n\t//   table bucket's namespace. Specify a different table name. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - TableBucketNotFound - The table bucket that you specified doesn't exist in\n\t//   this Amazon Web Services Region and account. Create or choose a different table\n\t//   bucket. To create a new metadata table, you must delete the metadata\n\t//   configuration for this bucket, and then create a new metadata configuration.\n\t//\n\t// If the V2 CreateBucketMetadataConfiguration request succeeds, but S3 Metadata\n\t// was unable to create the table, this structure contains the error code. The\n\t// possible error codes and error messages are as follows:\n\t//\n\t//   - AccessDeniedCreatingResources - You don't have sufficient permissions to\n\t//   create the required resources. Make sure that you have\n\t//   s3tables:CreateTableBucket , s3tables:CreateNamespace , s3tables:CreateTable ,\n\t//   s3tables:GetTable , s3tables:PutTablePolicy , kms:DescribeKey , and\n\t//   s3tables:PutTableEncryption permissions. Additionally, ensure that the KMS key\n\t//   used to encrypt the table still exists, is active and has a resource policy\n\t//   granting access to the S3 service principals '\n\t//   maintenance.s3tables.amazonaws.com ' and ' metadata.s3.amazonaws.com '. To\n\t//   create a new metadata table, you must delete the metadata configuration for this\n\t//   bucket, and then create a new metadata configuration.\n\t//\n\t//   - AccessDeniedWritingToTable - Unable to write to the metadata table because\n\t//   of missing resource permissions. To fix the resource policy, Amazon S3 needs to\n\t//   create a new metadata table. To create a new metadata table, you must delete the\n\t//   metadata configuration for this bucket, and then create a new metadata\n\t//   configuration.\n\t//\n\t//   - DestinationTableNotFound - The destination table doesn't exist. To create a\n\t//   new metadata table, you must delete the metadata configuration for this bucket,\n\t//   and then create a new metadata configuration.\n\t//\n\t//   - ServerInternalError - An internal error has occurred. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - JournalTableAlreadyExists - A journal table already exists in the Amazon Web\n\t//   Services managed table bucket's namespace. Delete the journal table, and then\n\t//   try again. To create a new metadata table, you must delete the metadata\n\t//   configuration for this bucket, and then create a new metadata configuration.\n\t//\n\t//   - InventoryTableAlreadyExists - An inventory table already exists in the\n\t//   Amazon Web Services managed table bucket's namespace. Delete the inventory\n\t//   table, and then try again. To create a new metadata table, you must delete the\n\t//   metadata configuration for this bucket, and then create a new metadata\n\t//   configuration.\n\t//\n\t//   - JournalTableNotAvailable - The journal table that the inventory table relies\n\t//   on has a FAILED status. An inventory table requires a journal table with an\n\t//   ACTIVE status. To create a new journal or inventory table, you must delete the\n\t//   metadata configuration for this bucket, along with any journal or inventory\n\t//   tables, and then create a new metadata configuration.\n\t//\n\t//   - NoSuchBucket - The specified general purpose bucket does not exist.\n\tErrorCode *string\n\n\t//  If the V1 CreateBucketMetadataTableConfiguration request succeeds, but S3\n\t// Metadata was unable to create the table, this structure contains the error\n\t// message. The possible error codes and error messages are as follows:\n\t//\n\t//   - AccessDeniedCreatingResources - You don't have sufficient permissions to\n\t//   create the required resources. Make sure that you have\n\t//   s3tables:CreateNamespace , s3tables:CreateTable , s3tables:GetTable and\n\t//   s3tables:PutTablePolicy permissions, and then try again. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - AccessDeniedWritingToTable - Unable to write to the metadata table because\n\t//   of missing resource permissions. To fix the resource policy, Amazon S3 needs to\n\t//   create a new metadata table. To create a new metadata table, you must delete the\n\t//   metadata configuration for this bucket, and then create a new metadata\n\t//   configuration.\n\t//\n\t//   - DestinationTableNotFound - The destination table doesn't exist. To create a\n\t//   new metadata table, you must delete the metadata configuration for this bucket,\n\t//   and then create a new metadata configuration.\n\t//\n\t//   - ServerInternalError - An internal error has occurred. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - TableAlreadyExists - The table that you specified already exists in the\n\t//   table bucket's namespace. Specify a different table name. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - TableBucketNotFound - The table bucket that you specified doesn't exist in\n\t//   this Amazon Web Services Region and account. Create or choose a different table\n\t//   bucket. To create a new metadata table, you must delete the metadata\n\t//   configuration for this bucket, and then create a new metadata configuration.\n\t//\n\t// If the V2 CreateBucketMetadataConfiguration request succeeds, but S3 Metadata\n\t// was unable to create the table, this structure contains the error code. The\n\t// possible error codes and error messages are as follows:\n\t//\n\t//   - AccessDeniedCreatingResources - You don't have sufficient permissions to\n\t//   create the required resources. Make sure that you have\n\t//   s3tables:CreateTableBucket , s3tables:CreateNamespace , s3tables:CreateTable ,\n\t//   s3tables:GetTable , s3tables:PutTablePolicy , kms:DescribeKey , and\n\t//   s3tables:PutTableEncryption permissions. Additionally, ensure that the KMS key\n\t//   used to encrypt the table still exists, is active and has a resource policy\n\t//   granting access to the S3 service principals '\n\t//   maintenance.s3tables.amazonaws.com ' and ' metadata.s3.amazonaws.com '. To\n\t//   create a new metadata table, you must delete the metadata configuration for this\n\t//   bucket, and then create a new metadata configuration.\n\t//\n\t//   - AccessDeniedWritingToTable - Unable to write to the metadata table because\n\t//   of missing resource permissions. To fix the resource policy, Amazon S3 needs to\n\t//   create a new metadata table. To create a new metadata table, you must delete the\n\t//   metadata configuration for this bucket, and then create a new metadata\n\t//   configuration.\n\t//\n\t//   - DestinationTableNotFound - The destination table doesn't exist. To create a\n\t//   new metadata table, you must delete the metadata configuration for this bucket,\n\t//   and then create a new metadata configuration.\n\t//\n\t//   - ServerInternalError - An internal error has occurred. To create a new\n\t//   metadata table, you must delete the metadata configuration for this bucket, and\n\t//   then create a new metadata configuration.\n\t//\n\t//   - JournalTableAlreadyExists - A journal table already exists in the Amazon Web\n\t//   Services managed table bucket's namespace. Delete the journal table, and then\n\t//   try again. To create a new metadata table, you must delete the metadata\n\t//   configuration for this bucket, and then create a new metadata configuration.\n\t//\n\t//   - InventoryTableAlreadyExists - An inventory table already exists in the\n\t//   Amazon Web Services managed table bucket's namespace. Delete the inventory\n\t//   table, and then try again. To create a new metadata table, you must delete the\n\t//   metadata configuration for this bucket, and then create a new metadata\n\t//   configuration.\n\t//\n\t//   - JournalTableNotAvailable - The journal table that the inventory table relies\n\t//   on has a FAILED status. An inventory table requires a journal table with an\n\t//   ACTIVE status. To create a new journal or inventory table, you must delete the\n\t//   metadata configuration for this bucket, along with any journal or inventory\n\t//   tables, and then create a new metadata configuration.\n\t//\n\t//   - NoSuchBucket - The specified general purpose bucket does not exist.\n\tErrorMessage *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The error information.\ntype ErrorDocument struct {\n\n\t// The object key name to use when a 4XX class error occurs.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\t//\n\t// This member is required.\n\tKey *string\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for specifying the configuration for Amazon EventBridge.\ntype EventBridgeConfiguration struct {\n\tnoSmithyDocumentSerde\n}\n\n// Optional configuration to replicate existing source bucket objects.\n//\n// This parameter is no longer supported. To replicate existing objects, see [Replicating existing objects with S3 Batch Replication] in\n// the Amazon S3 User Guide.\n//\n// [Replicating existing objects with S3 Batch Replication]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-batch-replication-batch.html\ntype ExistingObjectReplication struct {\n\n\t// Specifies whether Amazon S3 replicates existing source bucket objects.\n\t//\n\t// This member is required.\n\tStatus ExistingObjectReplicationStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the Amazon S3 object key name to filter on. An object key name is the\n// name assigned to an object in your Amazon S3 bucket. You specify whether to\n// filter on the suffix or prefix of the object key name. A prefix is a specific\n// string of characters at the beginning of an object key name, which you can use\n// to organize objects. For example, you can start the key names of related objects\n// with a prefix, such as 2023- or engineering/ . Then, you can use FilterRule to\n// find objects in a bucket with key names that have the same prefix. A suffix is\n// similar to a prefix, but it is at the end of the object key name instead of at\n// the beginning.\ntype FilterRule struct {\n\n\t// The object key name prefix or suffix identifying one or more objects to which\n\t// the filtering rule applies. The maximum length is 1,024 characters. Overlapping\n\t// prefixes and suffixes are not supported. For more information, see [Configuring Event Notifications]in the\n\t// Amazon S3 User Guide.\n\t//\n\t// [Configuring Event Notifications]: https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html\n\tName FilterRuleName\n\n\t// The value that the filter searches for in object key names.\n\tValue *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The S3 Metadata configuration for a general purpose bucket.\ntype GetBucketMetadataConfigurationResult struct {\n\n\t//  The metadata configuration for a general purpose bucket.\n\t//\n\t// This member is required.\n\tMetadataConfigurationResult *MetadataConfigurationResult\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe V1 S3 Metadata configuration for a general purpose bucket.\n//\n// If you created your S3 Metadata configuration before July 15, 2025, we\n// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n// can expire journal table records and create a live inventory table.\n//\n// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\ntype GetBucketMetadataTableConfigurationResult struct {\n\n\t//  The V1 S3 Metadata configuration for a general purpose bucket.\n\t//\n\t// This member is required.\n\tMetadataTableConfigurationResult *MetadataTableConfigurationResult\n\n\t//  The status of the metadata table. The status values are:\n\t//\n\t//   - CREATING - The metadata table is in the process of being created in the\n\t//   specified table bucket.\n\t//\n\t//   - ACTIVE - The metadata table has been created successfully, and records are\n\t//   being delivered to the table.\n\t//\n\t//   - FAILED - Amazon S3 is unable to create the metadata table, or Amazon S3 is\n\t//   unable to deliver records. See ErrorDetails for details.\n\t//\n\t// This member is required.\n\tStatus *string\n\n\t//  If the CreateBucketMetadataTableConfiguration request succeeds, but S3\n\t// Metadata was unable to create the table, this structure contains the error code\n\t// and error message.\n\tError *ErrorDetails\n\n\tnoSmithyDocumentSerde\n}\n\n// A collection of parts associated with a multipart upload.\ntype GetObjectAttributesParts struct {\n\n\t// Indicates whether the returned list of parts is truncated. A value of true\n\t// indicates that the list was truncated. A list can be truncated if the number of\n\t// parts exceeds the limit returned in the MaxParts element.\n\tIsTruncated *bool\n\n\t// The maximum number of parts allowed in the response.\n\tMaxParts *int32\n\n\t// When a list is truncated, this element specifies the last part in the list, as\n\t// well as the value to use for the PartNumberMarker request parameter in a\n\t// subsequent request.\n\tNextPartNumberMarker *string\n\n\t// The marker for the current part.\n\tPartNumberMarker *string\n\n\t// A container for elements related to a particular part. A response can contain\n\t// zero or more Parts elements.\n\t//\n\t//   - General purpose buckets - For GetObjectAttributes , if an additional\n\t//   checksum (including x-amz-checksum-crc32 , x-amz-checksum-crc32c ,\n\t//   x-amz-checksum-sha1 , or x-amz-checksum-sha256 ) isn't applied to the object\n\t//   specified in the request, the response doesn't return the Part element.\n\t//\n\t//   - Directory buckets - For GetObjectAttributes , regardless of whether an\n\t//   additional checksum is applied to the object specified in the request, the\n\t//   response returns the Part element.\n\tParts []ObjectPart\n\n\t// The total number of parts.\n\tTotalPartsCount *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for S3 Glacier job parameters.\ntype GlacierJobParameters struct {\n\n\t// Retrieval tier at which the restore will be processed.\n\t//\n\t// This member is required.\n\tTier Tier\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for grant information.\ntype Grant struct {\n\n\t// The person being granted permissions.\n\tGrantee *Grantee\n\n\t// Specifies the permission given to the grantee.\n\tPermission Permission\n\n\tnoSmithyDocumentSerde\n}\n\n// End of support notice: Beginning November 21, 2025, Amazon S3 will stop\n// returning DisplayName . Update your applications to use canonical IDs (unique\n// identifier for Amazon Web Services accounts), Amazon Web Services account ID (12\n// digit identifier) or IAM ARNs (full resource naming) as a direct replacement of\n// DisplayName .\n//\n// This change affects the following Amazon Web Services Regions: US East (N.\n// Virginia) Region, US West (N. California) Region, US West (Oregon) Region, Asia\n// Pacific (Singapore) Region, Asia Pacific (Sydney) Region, Asia Pacific (Tokyo)\n// Region, Europe (Ireland) Region, and South America (So Paulo) Region.\n//\n// Container for the person being granted permissions.\ntype Grantee struct {\n\n\t// Type of grantee\n\t//\n\t// This member is required.\n\tType Type\n\n\t// Screen name of the grantee.\n\tDisplayName *string\n\n\t// Email address of the grantee.\n\t//\n\t// Using email addresses to specify a grantee is only supported in the following\n\t// Amazon Web Services Regions:\n\t//\n\t//   - US East (N. Virginia)\n\t//\n\t//   - US West (N. California)\n\t//\n\t//   - US West (Oregon)\n\t//\n\t//   - Asia Pacific (Singapore)\n\t//\n\t//   - Asia Pacific (Sydney)\n\t//\n\t//   - Asia Pacific (Tokyo)\n\t//\n\t//   - Europe (Ireland)\n\t//\n\t//   - South America (So Paulo)\n\t//\n\t// For a list of all the Amazon S3 supported Regions and endpoints, see [Regions and Endpoints] in the\n\t// Amazon Web Services General Reference.\n\t//\n\t// [Regions and Endpoints]: https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region\n\tEmailAddress *string\n\n\t// The canonical user ID of the grantee.\n\tID *string\n\n\t// URI of the grantee group.\n\tURI *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for the Suffix element.\ntype IndexDocument struct {\n\n\t// A suffix that is appended to a request that is for a directory on the website\n\t// endpoint. (For example, if the suffix is index.html and you make a request to\n\t// samplebucket/images/ , the data that is returned will be for the object with the\n\t// key name images/index.html .) The suffix must not be empty and must not include\n\t// a slash character.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\t//\n\t// This member is required.\n\tSuffix *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Container element that identifies who initiated the multipart upload.\ntype Initiator struct {\n\n\t// Name of the Principal.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tDisplayName *string\n\n\t// If the principal is an Amazon Web Services account, it provides the Canonical\n\t// User ID. If the principal is an IAM User, it provides a user ARN value.\n\t//\n\t// Directory buckets - If the principal is an Amazon Web Services account, it\n\t// provides the Amazon Web Services account ID. If the principal is an IAM User, it\n\t// provides a user ARN value.\n\tID *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes the serialization format of the object.\ntype InputSerialization struct {\n\n\t// Describes the serialization of a CSV-encoded object.\n\tCSV *CSVInput\n\n\t// Specifies object's compression format. Valid values: NONE, GZIP, BZIP2. Default\n\t// Value: NONE.\n\tCompressionType CompressionType\n\n\t// Specifies JSON as object's input serialization format.\n\tJSON *JSONInput\n\n\t// Specifies Parquet as object's input serialization format.\n\tParquet *ParquetInput\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for specifying S3 Intelligent-Tiering filters. The filters\n// determine the subset of objects to which the rule applies.\ntype IntelligentTieringAndOperator struct {\n\n\t// An object key name prefix that identifies the subset of objects to which the\n\t// configuration applies.\n\tPrefix *string\n\n\t// All of these tags must exist in the object's tag set in order for the\n\t// configuration to apply.\n\tTags []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket.\n//\n// For information about the S3 Intelligent-Tiering storage class, see [Storage class for automatically optimizing frequently and infrequently accessed objects].\n//\n// [Storage class for automatically optimizing frequently and infrequently accessed objects]: https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access\ntype IntelligentTieringConfiguration struct {\n\n\t// The ID used to identify the S3 Intelligent-Tiering configuration.\n\t//\n\t// This member is required.\n\tId *string\n\n\t// Specifies the status of the configuration.\n\t//\n\t// This member is required.\n\tStatus IntelligentTieringStatus\n\n\t// Specifies the S3 Intelligent-Tiering storage class tier of the configuration.\n\t//\n\t// This member is required.\n\tTierings []Tiering\n\n\t// Specifies a bucket filter. The configuration only includes objects that meet\n\t// the filter's criteria.\n\tFilter *IntelligentTieringFilter\n\n\tnoSmithyDocumentSerde\n}\n\n// The Filter is used to identify objects that the S3 Intelligent-Tiering\n// configuration applies to.\ntype IntelligentTieringFilter struct {\n\n\t// A conjunction (logical AND) of predicates, which is used in evaluating a\n\t// metrics filter. The operator must have at least two predicates, and an object\n\t// must match all of the predicates in order for the filter to apply.\n\tAnd *IntelligentTieringAndOperator\n\n\t// An object key name prefix that identifies the subset of objects to which the\n\t// rule applies.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\tPrefix *string\n\n\t// A container of a key value name pair.\n\tTag *Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the S3 Inventory configuration for an Amazon S3 bucket. For more\n// information, see [GET Bucket inventory]in the Amazon S3 API Reference.\n//\n// [GET Bucket inventory]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html\ntype InventoryConfiguration struct {\n\n\t// Contains information about where to publish the inventory results.\n\t//\n\t// This member is required.\n\tDestination *InventoryDestination\n\n\t// The ID used to identify the inventory configuration.\n\t//\n\t// This member is required.\n\tId *string\n\n\t// Object versions to include in the inventory list. If set to All , the list\n\t// includes all the object versions, which adds the version-related fields\n\t// VersionId , IsLatest , and DeleteMarker to the list. If set to Current , the\n\t// list does not contain these version-related fields.\n\t//\n\t// This member is required.\n\tIncludedObjectVersions InventoryIncludedObjectVersions\n\n\t// Specifies whether the inventory is enabled or disabled. If set to True , an\n\t// inventory list is generated. If set to False , no inventory list is generated.\n\t//\n\t// This member is required.\n\tIsEnabled *bool\n\n\t// Specifies the schedule for generating inventory results.\n\t//\n\t// This member is required.\n\tSchedule *InventorySchedule\n\n\t// Specifies an inventory filter. The inventory only includes objects that meet\n\t// the filter's criteria.\n\tFilter *InventoryFilter\n\n\t// Contains the optional fields that are included in the inventory results.\n\tOptionalFields []InventoryOptionalField\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the S3 Inventory configuration for an Amazon S3 bucket.\ntype InventoryDestination struct {\n\n\t// Contains the bucket name, file format, bucket owner (optional), and prefix\n\t// (optional) where inventory results are published.\n\t//\n\t// This member is required.\n\tS3BucketDestination *InventoryS3BucketDestination\n\n\tnoSmithyDocumentSerde\n}\n\n// Contains the type of server-side encryption used to encrypt the S3 Inventory\n// results.\ntype InventoryEncryption struct {\n\n\t// Specifies the use of SSE-KMS to encrypt delivered inventory reports.\n\tSSEKMS *SSEKMS\n\n\t// Specifies the use of SSE-S3 to encrypt delivered inventory reports.\n\tSSES3 *SSES3\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies an S3 Inventory filter. The inventory only includes objects that meet\n// the filter's criteria.\ntype InventoryFilter struct {\n\n\t// The prefix that an object must have to be included in the inventory results.\n\t//\n\t// This member is required.\n\tPrefix *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Contains the bucket name, file format, bucket owner (optional), and prefix\n// (optional) where S3 Inventory results are published.\ntype InventoryS3BucketDestination struct {\n\n\t// The Amazon Resource Name (ARN) of the bucket where inventory results will be\n\t// published.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Specifies the output format of the inventory results.\n\t//\n\t// This member is required.\n\tFormat InventoryFormat\n\n\t// The account ID that owns the destination S3 bucket. If no account ID is\n\t// provided, the owner is not validated before exporting data.\n\t//\n\t// Although this value is optional, we strongly recommend that you set it to help\n\t// prevent problems if the destination bucket ownership changes.\n\tAccountId *string\n\n\t// Contains the type of server-side encryption used to encrypt the inventory\n\t// results.\n\tEncryption *InventoryEncryption\n\n\t// The prefix that is prepended to all inventory results.\n\tPrefix *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the schedule for generating S3 Inventory results.\ntype InventorySchedule struct {\n\n\t// Specifies how frequently inventory results are produced.\n\t//\n\t// This member is required.\n\tFrequency InventoryFrequency\n\n\tnoSmithyDocumentSerde\n}\n\n// The inventory table configuration for an S3 Metadata configuration.\ntype InventoryTableConfiguration struct {\n\n\t//  The configuration state of the inventory table, indicating whether the\n\t// inventory table is enabled or disabled.\n\t//\n\t// This member is required.\n\tConfigurationState InventoryConfigurationState\n\n\t//  The encryption configuration for the inventory table.\n\tEncryptionConfiguration *MetadataTableEncryptionConfiguration\n\n\tnoSmithyDocumentSerde\n}\n\n// The inventory table configuration for an S3 Metadata configuration.\ntype InventoryTableConfigurationResult struct {\n\n\t//  The configuration state of the inventory table, indicating whether the\n\t// inventory table is enabled or disabled.\n\t//\n\t// This member is required.\n\tConfigurationState InventoryConfigurationState\n\n\t//  If an S3 Metadata V1 CreateBucketMetadataTableConfiguration or V2\n\t// CreateBucketMetadataConfiguration request succeeds, but S3 Metadata was unable\n\t// to create the table, this structure contains the error code and error message.\n\t//\n\t// If you created your S3 Metadata configuration before July 15, 2025, we\n\t// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n\t// can expire journal table records and create a live inventory table.\n\t//\n\t// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\n\tError *ErrorDetails\n\n\t//  The Amazon Resource Name (ARN) for the inventory table.\n\tTableArn *string\n\n\t//  The name of the inventory table.\n\tTableName *string\n\n\t//  The status of the inventory table. The status values are:\n\t//\n\t//   - CREATING - The inventory table is in the process of being created in the\n\t//   specified Amazon Web Services managed table bucket.\n\t//\n\t//   - BACKFILLING - The inventory table is in the process of being backfilled.\n\t//   When you enable the inventory table for your metadata configuration, the table\n\t//   goes through a process known as backfilling, during which Amazon S3 scans your\n\t//   general purpose bucket to retrieve the initial metadata for all objects in the\n\t//   bucket. Depending on the number of objects in your bucket, this process can take\n\t//   several hours. When the backfilling process is finished, the status of your\n\t//   inventory table changes from BACKFILLING to ACTIVE . After backfilling is\n\t//   completed, updates to your objects are reflected in the inventory table within\n\t//   one hour.\n\t//\n\t//   - ACTIVE - The inventory table has been created successfully, and records are\n\t//   being delivered to the table.\n\t//\n\t//   - FAILED - Amazon S3 is unable to create the inventory table, or Amazon S3 is\n\t//   unable to deliver records.\n\tTableStatus *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The specified updates to the S3 Metadata inventory table configuration.\ntype InventoryTableConfigurationUpdates struct {\n\n\t//  The configuration state of the inventory table, indicating whether the\n\t// inventory table is enabled or disabled.\n\t//\n\t// This member is required.\n\tConfigurationState InventoryConfigurationState\n\n\t//  The encryption configuration for the inventory table.\n\tEncryptionConfiguration *MetadataTableEncryptionConfiguration\n\n\tnoSmithyDocumentSerde\n}\n\n// The journal table configuration for an S3 Metadata configuration.\ntype JournalTableConfiguration struct {\n\n\t//  The journal table record expiration settings for the journal table.\n\t//\n\t// This member is required.\n\tRecordExpiration *RecordExpiration\n\n\t//  The encryption configuration for the journal table.\n\tEncryptionConfiguration *MetadataTableEncryptionConfiguration\n\n\tnoSmithyDocumentSerde\n}\n\n// The journal table configuration for the S3 Metadata configuration.\ntype JournalTableConfigurationResult struct {\n\n\t//  The journal table record expiration settings for the journal table.\n\t//\n\t// This member is required.\n\tRecordExpiration *RecordExpiration\n\n\t//  The name of the journal table.\n\t//\n\t// This member is required.\n\tTableName *string\n\n\t//  The status of the journal table. The status values are:\n\t//\n\t//   - CREATING - The journal table is in the process of being created in the\n\t//   specified table bucket.\n\t//\n\t//   - ACTIVE - The journal table has been created successfully, and records are\n\t//   being delivered to the table.\n\t//\n\t//   - FAILED - Amazon S3 is unable to create the journal table, or Amazon S3 is\n\t//   unable to deliver records.\n\t//\n\t// This member is required.\n\tTableStatus *string\n\n\t//  If an S3 Metadata V1 CreateBucketMetadataTableConfiguration or V2\n\t// CreateBucketMetadataConfiguration request succeeds, but S3 Metadata was unable\n\t// to create the table, this structure contains the error code and error message.\n\t//\n\t// If you created your S3 Metadata configuration before July 15, 2025, we\n\t// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n\t// can expire journal table records and create a live inventory table.\n\t//\n\t// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\n\tError *ErrorDetails\n\n\t//  The Amazon Resource Name (ARN) for the journal table.\n\tTableArn *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The specified updates to the S3 Metadata journal table configuration.\ntype JournalTableConfigurationUpdates struct {\n\n\t//  The journal table record expiration settings for the journal table.\n\t//\n\t// This member is required.\n\tRecordExpiration *RecordExpiration\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies JSON as object's input serialization format.\ntype JSONInput struct {\n\n\t// The type of JSON. Valid values: Document, Lines.\n\tType JSONType\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies JSON as request's output serialization format.\ntype JSONOutput struct {\n\n\t// The value used to separate individual records in the output. If no value is\n\t// specified, Amazon S3 uses a newline character ('\\n').\n\tRecordDelimiter *string\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for specifying the configuration for Lambda notifications.\ntype LambdaFunctionConfiguration struct {\n\n\t// The Amazon S3 bucket event for which to invoke the Lambda function. For more\n\t// information, see [Supported Event Types]in the Amazon S3 User Guide.\n\t//\n\t// [Supported Event Types]: https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html\n\t//\n\t// This member is required.\n\tEvents []Event\n\n\t// The Amazon Resource Name (ARN) of the Lambda function that Amazon S3 invokes\n\t// when the specified event type occurs.\n\t//\n\t// This member is required.\n\tLambdaFunctionArn *string\n\n\t// Specifies object key name filtering rules. For information about key name\n\t// filtering, see [Configuring event notifications using object key name filtering]in the Amazon S3 User Guide.\n\t//\n\t// [Configuring event notifications using object key name filtering]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html\n\tFilter *NotificationConfigurationFilter\n\n\t// An optional unique identifier for configurations in a notification\n\t// configuration. If you don't provide one, Amazon S3 will assign an ID.\n\tId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for the expiration for the lifecycle of the object.\n//\n// For more information see, [Managing your storage lifecycle] in the Amazon S3 User Guide.\n//\n// [Managing your storage lifecycle]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html\ntype LifecycleExpiration struct {\n\n\t// Indicates at what date the object is to be moved or deleted. The date value\n\t// must conform to the ISO 8601 format. The time is always midnight UTC.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\tDate *time.Time\n\n\t// Indicates the lifetime, in days, of the objects that are subject to the rule.\n\t// The value must be a non-zero positive integer.\n\tDays *int32\n\n\t// Indicates whether Amazon S3 will remove a delete marker with no noncurrent\n\t// versions. If set to true, the delete marker will be expired; if set to false the\n\t// policy takes no action. This cannot be specified with Days or Date in a\n\t// Lifecycle Expiration Policy.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\tExpiredObjectDeleteMarker *bool\n\n\tnoSmithyDocumentSerde\n}\n\n// A lifecycle rule for individual objects in an Amazon S3 bucket.\n//\n// For more information see, [Managing your storage lifecycle] in the Amazon S3 User Guide.\n//\n// [Managing your storage lifecycle]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html\ntype LifecycleRule struct {\n\n\t// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is\n\t// not currently being applied.\n\t//\n\t// This member is required.\n\tStatus ExpirationStatus\n\n\t// Specifies the days since the initiation of an incomplete multipart upload that\n\t// Amazon S3 will wait before permanently removing all parts of the upload. For\n\t// more information, see [Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration]in the Amazon S3 User Guide.\n\t//\n\t// [Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Configuration]: https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config\n\tAbortIncompleteMultipartUpload *AbortIncompleteMultipartUpload\n\n\t// Specifies the expiration for the lifecycle of the object in the form of date,\n\t// days and, whether the object has a delete marker.\n\tExpiration *LifecycleExpiration\n\n\t// The Filter is used to identify objects that a Lifecycle Rule applies to. A\n\t// Filter must have exactly one of Prefix , Tag , ObjectSizeGreaterThan ,\n\t// ObjectSizeLessThan , or And specified. Filter is required if the LifecycleRule\n\t// does not contain a Prefix element.\n\t//\n\t// For more information about Tag filters, see [Adding filters to Lifecycle rules] in the Amazon S3 User Guide.\n\t//\n\t// Tag filters are not supported for directory buckets.\n\t//\n\t// [Adding filters to Lifecycle rules]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-filters.html\n\tFilter *LifecycleRuleFilter\n\n\t// Unique identifier for the rule. The value cannot be longer than 255 characters.\n\tID *string\n\n\t// Specifies when noncurrent object versions expire. Upon expiration, Amazon S3\n\t// permanently deletes the noncurrent object versions. You set this lifecycle\n\t// configuration action on a bucket that has versioning enabled (or suspended) to\n\t// request that Amazon S3 delete noncurrent object versions at a specific period in\n\t// the object's lifetime.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\tNoncurrentVersionExpiration *NoncurrentVersionExpiration\n\n\t// Specifies the transition rule for the lifecycle rule that describes when\n\t// noncurrent objects transition to a specific storage class. If your bucket is\n\t// versioning-enabled (or versioning is suspended), you can set this action to\n\t// request that Amazon S3 transition noncurrent object versions to a specific\n\t// storage class at a set period in the object's lifetime.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\tNoncurrentVersionTransitions []NoncurrentVersionTransition\n\n\t//  The general purpose bucket prefix that identifies one or more objects to which\n\t// the rule applies. We recommend using Filter instead of Prefix for new PUTs.\n\t// Previous configurations where a prefix is defined will continue to operate as\n\t// before.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\t//\n\t// Deprecated: This member has been deprecated.\n\tPrefix *string\n\n\t// Specifies when an Amazon S3 object transitions to a specified storage class.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\tTransitions []Transition\n\n\tnoSmithyDocumentSerde\n}\n\n// This is used in a Lifecycle Rule Filter to apply a logical AND to two or more\n// predicates. The Lifecycle Rule will apply to any object matching all of the\n// predicates configured inside the And operator.\ntype LifecycleRuleAndOperator struct {\n\n\t// Minimum object size to which the rule applies.\n\tObjectSizeGreaterThan *int64\n\n\t// Maximum object size to which the rule applies.\n\tObjectSizeLessThan *int64\n\n\t// Prefix identifying one or more objects to which the rule applies.\n\tPrefix *string\n\n\t// All of these tags must exist in the object's tag set in order for the rule to\n\t// apply.\n\tTags []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// The Filter is used to identify objects that a Lifecycle Rule applies to. A\n// Filter can have exactly one of Prefix , Tag , ObjectSizeGreaterThan ,\n// ObjectSizeLessThan , or And specified. If the Filter element is left empty, the\n// Lifecycle Rule applies to all objects in the bucket.\ntype LifecycleRuleFilter struct {\n\n\t// This is used in a Lifecycle Rule Filter to apply a logical AND to two or more\n\t// predicates. The Lifecycle Rule will apply to any object matching all of the\n\t// predicates configured inside the And operator.\n\tAnd *LifecycleRuleAndOperator\n\n\t// Minimum object size to which the rule applies.\n\tObjectSizeGreaterThan *int64\n\n\t// Maximum object size to which the rule applies.\n\tObjectSizeLessThan *int64\n\n\t// Prefix identifying one or more objects to which the rule applies.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\tPrefix *string\n\n\t// This tag must exist in the object's tag set in order for the rule to apply.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\tTag *Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the location where the bucket will be created.\n//\n// For directory buckets, the location type is Availability Zone or Local Zone.\n// For more information about directory buckets, see [Working with directory buckets]in the Amazon S3 User Guide.\n//\n// This functionality is only supported by directory buckets.\n//\n// [Working with directory buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html\ntype LocationInfo struct {\n\n\t// The name of the location where the bucket will be created.\n\t//\n\t// For directory buckets, the name of the location is the Zone ID of the\n\t// Availability Zone (AZ) or Local Zone (LZ) where the bucket will be created. An\n\t// example AZ ID value is usw2-az1 .\n\tName *string\n\n\t// The type of location where the bucket will be created.\n\tType LocationType\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes where logs are stored and the prefix that Amazon S3 assigns to all\n// log object keys for a bucket. For more information, see [PUT Bucket logging]in the Amazon S3 API\n// Reference.\n//\n// [PUT Bucket logging]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html\ntype LoggingEnabled struct {\n\n\t// Specifies the bucket where you want Amazon S3 to store server access logs. You\n\t// can have your logs delivered to any bucket that you own, including the same\n\t// bucket that is being logged. You can also configure multiple buckets to deliver\n\t// their logs to the same target bucket. In this case, you should choose a\n\t// different TargetPrefix for each source bucket so that the delivered log files\n\t// can be distinguished by key.\n\t//\n\t// This member is required.\n\tTargetBucket *string\n\n\t// A prefix for all log object keys. If you store log files from multiple Amazon\n\t// S3 buckets in a single bucket, you can use a prefix to distinguish which log\n\t// files came from which bucket.\n\t//\n\t// This member is required.\n\tTargetPrefix *string\n\n\t// Container for granting information.\n\t//\n\t// Buckets that use the bucket owner enforced setting for Object Ownership don't\n\t// support target grants. For more information, see [Permissions for server access log delivery]in the Amazon S3 User Guide.\n\t//\n\t// [Permissions for server access log delivery]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/enable-server-access-logging.html#grant-log-delivery-permissions-general\n\tTargetGrants []TargetGrant\n\n\t// Amazon S3 key format for log objects.\n\tTargetObjectKeyFormat *TargetObjectKeyFormat\n\n\tnoSmithyDocumentSerde\n}\n\n// The S3 Metadata configuration for a general purpose bucket.\ntype MetadataConfiguration struct {\n\n\t//  The journal table configuration for a metadata configuration.\n\t//\n\t// This member is required.\n\tJournalTableConfiguration *JournalTableConfiguration\n\n\t//  The inventory table configuration for a metadata configuration.\n\tInventoryTableConfiguration *InventoryTableConfiguration\n\n\tnoSmithyDocumentSerde\n}\n\n// The S3 Metadata configuration for a general purpose bucket.\ntype MetadataConfigurationResult struct {\n\n\t//  The destination settings for a metadata configuration.\n\t//\n\t// This member is required.\n\tDestinationResult *DestinationResult\n\n\t//  The inventory table configuration for a metadata configuration.\n\tInventoryTableConfigurationResult *InventoryTableConfigurationResult\n\n\t//  The journal table configuration for a metadata configuration.\n\tJournalTableConfigurationResult *JournalTableConfigurationResult\n\n\tnoSmithyDocumentSerde\n}\n\n// A metadata key-value pair to store with an object.\ntype MetadataEntry struct {\n\n\t// Name of the object.\n\tName *string\n\n\t// Value of the object.\n\tValue *string\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe V1 S3 Metadata configuration for a general purpose bucket.\n//\n// If you created your S3 Metadata configuration before July 15, 2025, we\n// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n// can expire journal table records and create a live inventory table.\n//\n// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\ntype MetadataTableConfiguration struct {\n\n\t//  The destination information for the metadata table configuration. The\n\t// destination table bucket must be in the same Region and Amazon Web Services\n\t// account as the general purpose bucket. The specified metadata table name must be\n\t// unique within the aws_s3_metadata namespace in the destination table bucket.\n\t//\n\t// This member is required.\n\tS3TablesDestination *S3TablesDestination\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe V1 S3 Metadata configuration for a general purpose bucket. The destination\n//\n// table bucket must be in the same Region and Amazon Web Services account as the\n// general purpose bucket. The specified metadata table name must be unique within\n// the aws_s3_metadata namespace in the destination table bucket.\n//\n// If you created your S3 Metadata configuration before July 15, 2025, we\n// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n// can expire journal table records and create a live inventory table.\n//\n// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\ntype MetadataTableConfigurationResult struct {\n\n\t//  The destination information for the metadata table configuration. The\n\t// destination table bucket must be in the same Region and Amazon Web Services\n\t// account as the general purpose bucket. The specified metadata table name must be\n\t// unique within the aws_s3_metadata namespace in the destination table bucket.\n\t//\n\t// This member is required.\n\tS3TablesDestinationResult *S3TablesDestinationResult\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe encryption settings for an S3 Metadata journal table or inventory table\n//\n// configuration.\ntype MetadataTableEncryptionConfiguration struct {\n\n\t//  The encryption type specified for a metadata table. To specify server-side\n\t// encryption with Key Management Service (KMS) keys (SSE-KMS), use the aws:kms\n\t// value. To specify server-side encryption with Amazon S3 managed keys (SSE-S3),\n\t// use the AES256 value.\n\t//\n\t// This member is required.\n\tSseAlgorithm TableSseAlgorithm\n\n\t//  If server-side encryption with Key Management Service (KMS) keys (SSE-KMS) is\n\t// specified, you must also specify the KMS key Amazon Resource Name (ARN). You\n\t// must specify a customer-managed KMS key that's located in the same Region as the\n\t// general purpose bucket that corresponds to the metadata table configuration.\n\tKmsKeyArn *string\n\n\tnoSmithyDocumentSerde\n}\n\n//\tA container specifying replication metrics-related settings enabling\n//\n// replication metrics and events.\ntype Metrics struct {\n\n\t//  Specifies whether the replication metrics are enabled.\n\t//\n\t// This member is required.\n\tStatus MetricsStatus\n\n\t//  A container specifying the time threshold for emitting the\n\t// s3:Replication:OperationMissedThreshold event.\n\tEventThreshold *ReplicationTimeValue\n\n\tnoSmithyDocumentSerde\n}\n\n// A conjunction (logical AND) of predicates, which is used in evaluating a\n// metrics filter. The operator must have at least two predicates, and an object\n// must match all of the predicates in order for the filter to apply.\ntype MetricsAndOperator struct {\n\n\t// The access point ARN used when evaluating an AND predicate.\n\tAccessPointArn *string\n\n\t// The prefix used when evaluating an AND predicate.\n\tPrefix *string\n\n\t// The list of tags used when evaluating an AND predicate.\n\tTags []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies a metrics configuration for the CloudWatch request metrics (specified\n// by the metrics configuration ID) from an Amazon S3 bucket. If you're updating an\n// existing metrics configuration, note that this is a full replacement of the\n// existing metrics configuration. If you don't include the elements you want to\n// keep, they are erased. For more information, see [PutBucketMetricsConfiguration].\n//\n// [PutBucketMetricsConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html\ntype MetricsConfiguration struct {\n\n\t// The ID used to identify the metrics configuration. The ID has a 64 character\n\t// limit and can only contain letters, numbers, periods, dashes, and underscores.\n\t//\n\t// This member is required.\n\tId *string\n\n\t// Specifies a metrics configuration filter. The metrics configuration will only\n\t// include objects that meet the filter's criteria. A filter must be a prefix, an\n\t// object tag, an access point ARN, or a conjunction (MetricsAndOperator).\n\tFilter MetricsFilter\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies a metrics configuration filter. The metrics configuration only\n// includes objects that meet the filter's criteria. A filter must be a prefix, an\n// object tag, an access point ARN, or a conjunction (MetricsAndOperator). For more\n// information, see [PutBucketMetricsConfiguration].\n//\n// The following types satisfy this interface:\n//\n//\tMetricsFilterMemberAccessPointArn\n//\tMetricsFilterMemberAnd\n//\tMetricsFilterMemberPrefix\n//\tMetricsFilterMemberTag\n//\n// [PutBucketMetricsConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketMetricsConfiguration.html\ntype MetricsFilter interface {\n\tisMetricsFilter()\n}\n\n// The access point ARN used when evaluating a metrics filter.\ntype MetricsFilterMemberAccessPointArn struct {\n\tValue string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*MetricsFilterMemberAccessPointArn) isMetricsFilter() {}\n\n// A conjunction (logical AND) of predicates, which is used in evaluating a\n// metrics filter. The operator must have at least two predicates, and an object\n// must match all of the predicates in order for the filter to apply.\ntype MetricsFilterMemberAnd struct {\n\tValue MetricsAndOperator\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*MetricsFilterMemberAnd) isMetricsFilter() {}\n\n// The prefix used when evaluating a metrics filter.\ntype MetricsFilterMemberPrefix struct {\n\tValue string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*MetricsFilterMemberPrefix) isMetricsFilter() {}\n\n// The tag used when evaluating a metrics filter.\ntype MetricsFilterMemberTag struct {\n\tValue Tag\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*MetricsFilterMemberTag) isMetricsFilter() {}\n\n// Container for the MultipartUpload for the Amazon S3 object.\ntype MultipartUpload struct {\n\n\t// The algorithm that was used to create a checksum of the object.\n\tChecksumAlgorithm ChecksumAlgorithm\n\n\t// The checksum type that is used to calculate the objects checksum value. For\n\t// more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumType ChecksumType\n\n\t// Date and time at which the multipart upload was initiated.\n\tInitiated *time.Time\n\n\t// Identifies who initiated the multipart upload.\n\tInitiator *Initiator\n\n\t// Key of the object for which the multipart upload was initiated.\n\tKey *string\n\n\t// Specifies the owner of the object that is part of the multipart upload.\n\t//\n\t// Directory buckets - The bucket owner is returned as the object owner for all\n\t// the objects.\n\tOwner *Owner\n\n\t// The class of storage used to store the object.\n\t//\n\t// Directory buckets - Directory buckets only support EXPRESS_ONEZONE (the S3\n\t// Express One Zone storage class) in Availability Zones and ONEZONE_IA (the S3\n\t// One Zone-Infrequent Access storage class) in Dedicated Local Zones.\n\tStorageClass StorageClass\n\n\t// Upload ID that identifies the multipart upload.\n\tUploadId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies when noncurrent object versions expire. Upon expiration, Amazon S3\n// permanently deletes the noncurrent object versions. You set this lifecycle\n// configuration action on a bucket that has versioning enabled (or suspended) to\n// request that Amazon S3 delete noncurrent object versions at a specific period in\n// the object's lifetime.\n//\n// This parameter applies to general purpose buckets only. It is not supported for\n// directory bucket lifecycle configurations.\ntype NoncurrentVersionExpiration struct {\n\n\t// Specifies how many noncurrent versions Amazon S3 will retain. You can specify\n\t// up to 100 noncurrent versions to retain. Amazon S3 will permanently delete any\n\t// additional noncurrent versions beyond the specified number to retain. For more\n\t// information about noncurrent versions, see [Lifecycle configuration elements]in the Amazon S3 User Guide.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\t//\n\t// [Lifecycle configuration elements]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html\n\tNewerNoncurrentVersions *int32\n\n\t// Specifies the number of days an object is noncurrent before Amazon S3 can\n\t// perform the associated action. The value must be a non-zero positive integer.\n\t// For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent]in the Amazon S3\n\t// User Guide.\n\t//\n\t// This parameter applies to general purpose buckets only. It is not supported for\n\t// directory bucket lifecycle configurations.\n\t//\n\t// [How Amazon S3 Calculates When an Object Became Noncurrent]: https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations\n\tNoncurrentDays *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for the transition rule that describes when noncurrent objects\n// transition to the STANDARD_IA , ONEZONE_IA , INTELLIGENT_TIERING , GLACIER_IR ,\n// GLACIER , or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled\n// (or versioning is suspended), you can set this action to request that Amazon S3\n// transition noncurrent object versions to the STANDARD_IA , ONEZONE_IA ,\n// INTELLIGENT_TIERING , GLACIER_IR , GLACIER , or DEEP_ARCHIVE storage class at a\n// specific period in the object's lifetime.\ntype NoncurrentVersionTransition struct {\n\n\t// Specifies how many noncurrent versions Amazon S3 will retain in the same\n\t// storage class before transitioning objects. You can specify up to 100 noncurrent\n\t// versions to retain. Amazon S3 will transition any additional noncurrent versions\n\t// beyond the specified number to retain. For more information about noncurrent\n\t// versions, see [Lifecycle configuration elements]in the Amazon S3 User Guide.\n\t//\n\t// [Lifecycle configuration elements]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html\n\tNewerNoncurrentVersions *int32\n\n\t// Specifies the number of days an object is noncurrent before Amazon S3 can\n\t// perform the associated action. For information about the noncurrent days\n\t// calculations, see [How Amazon S3 Calculates How Long an Object Has Been Noncurrent]in the Amazon S3 User Guide.\n\t//\n\t// [How Amazon S3 Calculates How Long an Object Has Been Noncurrent]: https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations\n\tNoncurrentDays *int32\n\n\t// The class of storage used to store the object.\n\tStorageClass TransitionStorageClass\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for specifying the notification configuration of the bucket. If\n// this element is empty, notifications are turned off for the bucket.\ntype NotificationConfiguration struct {\n\n\t// Enables delivery of events to Amazon EventBridge.\n\tEventBridgeConfiguration *EventBridgeConfiguration\n\n\t// Describes the Lambda functions to invoke and the events for which to invoke\n\t// them.\n\tLambdaFunctionConfigurations []LambdaFunctionConfiguration\n\n\t// The Amazon Simple Queue Service queues to publish messages to and the events\n\t// for which to publish messages.\n\tQueueConfigurations []QueueConfiguration\n\n\t// The topic to which notifications are sent and the events for which\n\t// notifications are generated.\n\tTopicConfigurations []TopicConfiguration\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies object key name filtering rules. For information about key name\n// filtering, see [Configuring event notifications using object key name filtering]in the Amazon S3 User Guide.\n//\n// [Configuring event notifications using object key name filtering]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html\ntype NotificationConfigurationFilter struct {\n\n\t// A container for object key name prefix and suffix filtering rules.\n\tKey *S3KeyFilter\n\n\tnoSmithyDocumentSerde\n}\n\n// An object consists of data and its descriptive metadata.\ntype Object struct {\n\n\t// The algorithm that was used to create a checksum of the object.\n\tChecksumAlgorithm []ChecksumAlgorithm\n\n\t// The checksum type that is used to calculate the objects checksum value. For\n\t// more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumType ChecksumType\n\n\t// The entity tag is a hash of the object. The ETag reflects changes only to the\n\t// contents of an object, not its metadata. The ETag may or may not be an MD5\n\t// digest of the object data. Whether or not it is depends on how the object was\n\t// created and how it is encrypted as described below:\n\t//\n\t//   - Objects created by the PUT Object, POST Object, or Copy operation, or\n\t//   through the Amazon Web Services Management Console, and are encrypted by SSE-S3\n\t//   or plaintext, have ETags that are an MD5 digest of their object data.\n\t//\n\t//   - Objects created by the PUT Object, POST Object, or Copy operation, or\n\t//   through the Amazon Web Services Management Console, and are encrypted by SSE-C\n\t//   or SSE-KMS, have ETags that are not an MD5 digest of their object data.\n\t//\n\t//   - If an object is created by either the Multipart Upload or Part Copy\n\t//   operation, the ETag is not an MD5 digest, regardless of the method of\n\t//   encryption. If an object is larger than 16 MB, the Amazon Web Services\n\t//   Management Console will upload or copy that object as a Multipart Upload, and\n\t//   therefore the ETag will not be an MD5 digest.\n\t//\n\t// Directory buckets - MD5 is not supported by directory buckets.\n\tETag *string\n\n\t// The name that you assign to an object. You use the object key to retrieve the\n\t// object.\n\tKey *string\n\n\t// Creation date of the object.\n\tLastModified *time.Time\n\n\t// The owner of the object\n\t//\n\t// Directory buckets - The bucket owner is returned as the object owner.\n\tOwner *Owner\n\n\t// Specifies the restoration status of an object. Objects in certain storage\n\t// classes must be restored before they can be retrieved. For more information\n\t// about these storage classes and how to work with archived objects, see [Working with archived objects]in the\n\t// Amazon S3 User Guide.\n\t//\n\t// This functionality is not supported for directory buckets. Directory buckets\n\t// only support EXPRESS_ONEZONE (the S3 Express One Zone storage class) in\n\t// Availability Zones and ONEZONE_IA (the S3 One Zone-Infrequent Access storage\n\t// class) in Dedicated Local Zones.\n\t//\n\t// [Working with archived objects]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/archived-objects.html\n\tRestoreStatus *RestoreStatus\n\n\t// Size in bytes of the object\n\tSize *int64\n\n\t// The class of storage used to store the object.\n\t//\n\t// Directory buckets - Directory buckets only support EXPRESS_ONEZONE (the S3\n\t// Express One Zone storage class) in Availability Zones and ONEZONE_IA (the S3\n\t// One Zone-Infrequent Access storage class) in Dedicated Local Zones.\n\tStorageClass ObjectStorageClass\n\n\tnoSmithyDocumentSerde\n}\n\n// Object Identifier is unique value to identify objects.\ntype ObjectIdentifier struct {\n\n\t// Key name of the object.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\t//\n\t// This member is required.\n\tKey *string\n\n\t// An entity tag (ETag) is an identifier assigned by a web server to a specific\n\t// version of a resource found at a URL. This header field makes the request method\n\t// conditional on ETags .\n\t//\n\t// Entity tags (ETags) for S3 Express One Zone are random alphanumeric strings\n\t// unique to the object.\n\tETag *string\n\n\t// If present, the objects are deleted only if its modification times matches the\n\t// provided Timestamp .\n\t//\n\t// This functionality is only supported for directory buckets.\n\tLastModifiedTime *time.Time\n\n\t// If present, the objects are deleted only if its size matches the provided size\n\t// in bytes.\n\t//\n\t// This functionality is only supported for directory buckets.\n\tSize *int64\n\n\t// Version ID for the specific version of the object to delete.\n\t//\n\t// This functionality is not supported for directory buckets.\n\tVersionId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The container element for Object Lock configuration parameters.\ntype ObjectLockConfiguration struct {\n\n\t// Indicates whether this bucket has an Object Lock configuration enabled. Enable\n\t// ObjectLockEnabled when you apply ObjectLockConfiguration to a bucket.\n\tObjectLockEnabled ObjectLockEnabled\n\n\t// Specifies the Object Lock rule for the specified object. Enable the this rule\n\t// when you apply ObjectLockConfiguration to a bucket. Bucket settings require\n\t// both a mode and a period. The period can be either Days or Years but you must\n\t// select one. You cannot specify Days and Years at the same time.\n\tRule *ObjectLockRule\n\n\tnoSmithyDocumentSerde\n}\n\n// A legal hold configuration for an object.\ntype ObjectLockLegalHold struct {\n\n\t// Indicates whether the specified object has a legal hold in place.\n\tStatus ObjectLockLegalHoldStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// A Retention configuration for an object.\ntype ObjectLockRetention struct {\n\n\t// Indicates the Retention mode for the specified object.\n\tMode ObjectLockRetentionMode\n\n\t// The date on which this Object Lock Retention will expire.\n\tRetainUntilDate *time.Time\n\n\tnoSmithyDocumentSerde\n}\n\n// The container element for an Object Lock rule.\ntype ObjectLockRule struct {\n\n\t// The default Object Lock retention mode and period that you want to apply to new\n\t// objects placed in the specified bucket. Bucket settings require both a mode and\n\t// a period. The period can be either Days or Years but you must select one. You\n\t// cannot specify Days and Years at the same time.\n\tDefaultRetention *DefaultRetention\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for elements related to an individual part.\ntype ObjectPart struct {\n\n\t// The Base64 encoded, 32-bit CRC32 checksum of the part. This checksum is present\n\t// if the multipart upload request was created with the CRC32 checksum algorithm.\n\t// For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32 *string\n\n\t// The Base64 encoded, 32-bit CRC32C checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the CRC32C checksum\n\t// algorithm. For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32C *string\n\n\t// The Base64 encoded, 64-bit CRC64NVME checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the CRC64NVME checksum\n\t// algorithm, or if the object was uploaded without a checksum (and Amazon S3 added\n\t// the default checksum, CRC64NVME , to the uploaded object). For more information,\n\t// see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// The Base64 encoded, 160-bit SHA1 checksum of the part. This checksum is present\n\t// if the multipart upload request was created with the SHA1 checksum algorithm.\n\t// For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA1 *string\n\n\t// The Base64 encoded, 256-bit SHA256 checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the SHA256 checksum\n\t// algorithm. For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA256 *string\n\n\t// The part number identifying the part. This value is a positive integer between\n\t// 1 and 10,000.\n\tPartNumber *int32\n\n\t// The size of the uploaded part in bytes.\n\tSize *int64\n\n\tnoSmithyDocumentSerde\n}\n\n// The version of an object.\ntype ObjectVersion struct {\n\n\t// The algorithm that was used to create a checksum of the object.\n\tChecksumAlgorithm []ChecksumAlgorithm\n\n\t// The checksum type that is used to calculate the objects checksum value. For\n\t// more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumType ChecksumType\n\n\t// The entity tag is an MD5 hash of that version of the object.\n\tETag *string\n\n\t// Specifies whether the object is (true) or is not (false) the latest version of\n\t// an object.\n\tIsLatest *bool\n\n\t// The object key.\n\tKey *string\n\n\t// Date and time when the object was last modified.\n\tLastModified *time.Time\n\n\t// Specifies the owner of the object.\n\tOwner *Owner\n\n\t// Specifies the restoration status of an object. Objects in certain storage\n\t// classes must be restored before they can be retrieved. For more information\n\t// about these storage classes and how to work with archived objects, see [Working with archived objects]in the\n\t// Amazon S3 User Guide.\n\t//\n\t// [Working with archived objects]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/archived-objects.html\n\tRestoreStatus *RestoreStatus\n\n\t// Size in bytes of the object.\n\tSize *int64\n\n\t// The class of storage used to store the object.\n\tStorageClass ObjectVersionStorageClass\n\n\t// Version ID of an object.\n\tVersionId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes the location where the restore job's output is stored.\ntype OutputLocation struct {\n\n\t// Describes an S3 location that will receive the results of the restore request.\n\tS3 *S3Location\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes how results of the Select job are serialized.\ntype OutputSerialization struct {\n\n\t// Describes the serialization of CSV-encoded Select results.\n\tCSV *CSVOutput\n\n\t// Specifies JSON as request's output serialization format.\n\tJSON *JSONOutput\n\n\tnoSmithyDocumentSerde\n}\n\n// End of support notice: Beginning November 21, 2025, Amazon S3 will stop\n// returning DisplayName . Update your applications to use canonical IDs (unique\n// identifier for Amazon Web Services accounts), Amazon Web Services account ID (12\n// digit identifier) or IAM ARNs (full resource naming) as a direct replacement of\n// DisplayName .\n//\n// This change affects the following Amazon Web Services Regions: US East (N.\n// Virginia) Region, US West (N. California) Region, US West (Oregon) Region, Asia\n// Pacific (Singapore) Region, Asia Pacific (Sydney) Region, Asia Pacific (Tokyo)\n// Region, Europe (Ireland) Region, and South America (So Paulo) Region.\n//\n// Container for the owner's display name and ID.\ntype Owner struct {\n\n\t// Container for the display name of the owner. This value is only supported in\n\t// the following Amazon Web Services Regions:\n\t//\n\t//   - US East (N. Virginia)\n\t//\n\t//   - US West (N. California)\n\t//\n\t//   - US West (Oregon)\n\t//\n\t//   - Asia Pacific (Singapore)\n\t//\n\t//   - Asia Pacific (Sydney)\n\t//\n\t//   - Asia Pacific (Tokyo)\n\t//\n\t//   - Europe (Ireland)\n\t//\n\t//   - South America (So Paulo)\n\t//\n\t// This functionality is not supported for directory buckets.\n\tDisplayName *string\n\n\t// Container for the ID of the owner.\n\tID *string\n\n\tnoSmithyDocumentSerde\n}\n\n// The container element for a bucket's ownership controls.\ntype OwnershipControls struct {\n\n\t// The container element for an ownership control rule.\n\t//\n\t// This member is required.\n\tRules []OwnershipControlsRule\n\n\tnoSmithyDocumentSerde\n}\n\n// The container element for an ownership control rule.\ntype OwnershipControlsRule struct {\n\n\t// The container element for object ownership for a bucket's ownership controls.\n\t//\n\t// BucketOwnerPreferred - Objects uploaded to the bucket change ownership to the\n\t// bucket owner if the objects are uploaded with the bucket-owner-full-control\n\t// canned ACL.\n\t//\n\t// ObjectWriter - The uploading account will own the object if the object is\n\t// uploaded with the bucket-owner-full-control canned ACL.\n\t//\n\t// BucketOwnerEnforced - Access control lists (ACLs) are disabled and no longer\n\t// affect permissions. The bucket owner automatically owns and has full control\n\t// over every object in the bucket. The bucket only accepts PUT requests that don't\n\t// specify an ACL or specify bucket owner full control ACLs (such as the predefined\n\t// bucket-owner-full-control canned ACL or a custom ACL in XML format that grants\n\t// the same permissions).\n\t//\n\t// By default, ObjectOwnership is set to BucketOwnerEnforced and ACLs are\n\t// disabled. We recommend keeping ACLs disabled, except in uncommon use cases where\n\t// you must control access for each object individually. For more information about\n\t// S3 Object Ownership, see [Controlling ownership of objects and disabling ACLs for your bucket]in the Amazon S3 User Guide.\n\t//\n\t// This functionality is not supported for directory buckets. Directory buckets\n\t// use the bucket owner enforced setting for S3 Object Ownership.\n\t//\n\t// [Controlling ownership of objects and disabling ACLs for your bucket]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html\n\t//\n\t// This member is required.\n\tObjectOwnership ObjectOwnership\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for Parquet.\ntype ParquetInput struct {\n\tnoSmithyDocumentSerde\n}\n\n// Container for elements related to a part.\ntype Part struct {\n\n\t// The Base64 encoded, 32-bit CRC32 checksum of the part. This checksum is present\n\t// if the object was uploaded with the CRC32 checksum algorithm. For more\n\t// information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32 *string\n\n\t// The Base64 encoded, 32-bit CRC32C checksum of the part. This checksum is\n\t// present if the object was uploaded with the CRC32C checksum algorithm. For more\n\t// information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC32C *string\n\n\t// The Base64 encoded, 64-bit CRC64NVME checksum of the part. This checksum is\n\t// present if the multipart upload request was created with the CRC64NVME checksum\n\t// algorithm, or if the object was uploaded without a checksum (and Amazon S3 added\n\t// the default checksum, CRC64NVME , to the uploaded object). For more information,\n\t// see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumCRC64NVME *string\n\n\t// The Base64 encoded, 160-bit SHA1 checksum of the part. This checksum is present\n\t// if the object was uploaded with the SHA1 checksum algorithm. For more\n\t// information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA1 *string\n\n\t// The Base64 encoded, 256-bit SHA256 checksum of the part. This checksum is\n\t// present if the object was uploaded with the SHA256 checksum algorithm. For more\n\t// information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumSHA256 *string\n\n\t// Entity tag returned when the part was uploaded.\n\tETag *string\n\n\t// Date and time at which the part was uploaded.\n\tLastModified *time.Time\n\n\t// Part number identifying the part. This is a positive integer between 1 and\n\t// 10,000.\n\tPartNumber *int32\n\n\t// Size in bytes of the uploaded part data.\n\tSize *int64\n\n\tnoSmithyDocumentSerde\n}\n\n// Amazon S3 keys for log objects are partitioned in the following format:\n//\n//\t[DestinationPrefix][SourceAccountId]/[SourceRegion]/[SourceBucket]/[YYYY]/[MM]/[DD]/[YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString]\n//\n// PartitionedPrefix defaults to EventTime delivery when server access logs are\n// delivered.\ntype PartitionedPrefix struct {\n\n\t// Specifies the partition date source for the partitioned prefix.\n\t// PartitionDateSource can be EventTime or DeliveryTime .\n\t//\n\t// For DeliveryTime , the time in the log file names corresponds to the delivery\n\t// time for the log files.\n\t//\n\t// For EventTime , The logs delivered are for a specific day only. The year, month,\n\t// and day correspond to the day on which the event occurred, and the hour, minutes\n\t// and seconds are set to 00 in the key.\n\tPartitionDateSource PartitionDateSource\n\n\tnoSmithyDocumentSerde\n}\n\n// The container element for a bucket's policy status.\ntype PolicyStatus struct {\n\n\t// The policy status for this bucket. TRUE indicates that this bucket is public.\n\t// FALSE indicates that the bucket is not public.\n\tIsPublic *bool\n\n\tnoSmithyDocumentSerde\n}\n\n// This data type contains information about progress of an operation.\ntype Progress struct {\n\n\t// The current number of uncompressed object bytes processed.\n\tBytesProcessed *int64\n\n\t// The current number of bytes of records payload data returned.\n\tBytesReturned *int64\n\n\t// The current number of object bytes scanned.\n\tBytesScanned *int64\n\n\tnoSmithyDocumentSerde\n}\n\n// This data type contains information about the progress event of an operation.\ntype ProgressEvent struct {\n\n\t// The Progress event details.\n\tDetails *Progress\n\n\tnoSmithyDocumentSerde\n}\n\n// The PublicAccessBlock configuration that you want to apply to this Amazon S3\n// bucket. You can enable the configuration options in any combination. For more\n// information about when Amazon S3 considers a bucket or object public, see [The Meaning of \"Public\"]in\n// the Amazon S3 User Guide.\n//\n// [The Meaning of \"Public\"]: https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status\ntype PublicAccessBlockConfiguration struct {\n\n\t// Specifies whether Amazon S3 should block public access control lists (ACLs) for\n\t// this bucket and objects in this bucket. Setting this element to TRUE causes the\n\t// following behavior:\n\t//\n\t//   - PUT Bucket ACL and PUT Object ACL calls fail if the specified ACL is public.\n\t//\n\t//   - PUT Object calls fail if the request includes a public ACL.\n\t//\n\t//   - PUT Bucket calls fail if the request includes a public ACL.\n\t//\n\t// Enabling this setting doesn't affect existing policies or ACLs.\n\tBlockPublicAcls *bool\n\n\t// Specifies whether Amazon S3 should block public bucket policies for this\n\t// bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT\n\t// Bucket policy if the specified bucket policy allows public access.\n\t//\n\t// Enabling this setting doesn't affect existing bucket policies.\n\tBlockPublicPolicy *bool\n\n\t// Specifies whether Amazon S3 should ignore public ACLs for this bucket and\n\t// objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore\n\t// all public ACLs on this bucket and objects in this bucket.\n\t//\n\t// Enabling this setting doesn't affect the persistence of any existing ACLs and\n\t// doesn't prevent new public ACLs from being set.\n\tIgnorePublicAcls *bool\n\n\t// Specifies whether Amazon S3 should restrict public bucket policies for this\n\t// bucket. Setting this element to TRUE restricts access to this bucket to only\n\t// Amazon Web Services service principals and authorized users within this account\n\t// if the bucket has a public policy.\n\t//\n\t// Enabling this setting doesn't affect previously stored bucket policies, except\n\t// that public and cross-account access within any public bucket policy, including\n\t// non-public delegation to specific accounts, is blocked.\n\tRestrictPublicBuckets *bool\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the configuration for publishing messages to an Amazon Simple Queue\n// Service (Amazon SQS) queue when Amazon S3 detects specified events.\ntype QueueConfiguration struct {\n\n\t// A collection of bucket events for which to send notifications\n\t//\n\t// This member is required.\n\tEvents []Event\n\n\t// The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3\n\t// publishes a message when it detects events of the specified type.\n\t//\n\t// This member is required.\n\tQueueArn *string\n\n\t// Specifies object key name filtering rules. For information about key name\n\t// filtering, see [Configuring event notifications using object key name filtering]in the Amazon S3 User Guide.\n\t//\n\t// [Configuring event notifications using object key name filtering]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html\n\tFilter *NotificationConfigurationFilter\n\n\t// An optional unique identifier for configurations in a notification\n\t// configuration. If you don't provide one, Amazon S3 will assign an ID.\n\tId *string\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe journal table record expiration settings for a journal table in an S3\n//\n// Metadata configuration.\ntype RecordExpiration struct {\n\n\t//  Specifies whether journal table record expiration is enabled or disabled.\n\t//\n\t// This member is required.\n\tExpiration ExpirationState\n\n\t//  If you enable journal table record expiration, you can set the number of days\n\t// to retain your journal table records. Journal table records must be retained for\n\t// a minimum of 7 days. To set this value, specify any whole number from 7 to\n\t// 2147483647 . For example, to retain your journal table records for one year, set\n\t// this value to 365 .\n\tDays *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// The container for the records event.\ntype RecordsEvent struct {\n\n\t// The byte array of partial, one or more result records. S3 Select doesn't\n\t// guarantee that a record will be self-contained in one record frame. To ensure\n\t// continuous streaming of data, S3 Select might split the same record across\n\t// multiple record frames instead of aggregating the results in memory. Some S3\n\t// clients (for example, the SDK for Java) handle this behavior by creating a\n\t// ByteStream out of the response by default. Other clients might not handle this\n\t// behavior by default. In those cases, you must aggregate the results on the\n\t// client side and parse the response.\n\tPayload []byte\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies how requests are redirected. In the event of an error, you can\n// specify a different error code to return.\ntype Redirect struct {\n\n\t// The host name to use in the redirect request.\n\tHostName *string\n\n\t// The HTTP redirect code to use on the response. Not required if one of the\n\t// siblings is present.\n\tHttpRedirectCode *string\n\n\t// Protocol to use when redirecting requests. The default is the protocol that is\n\t// used in the original request.\n\tProtocol Protocol\n\n\t// The object key prefix to use in the redirect request. For example, to redirect\n\t// requests for all pages with prefix docs/ (objects in the docs/ folder) to\n\t// documents/ , you can set a condition block with KeyPrefixEquals set to docs/\n\t// and in the Redirect set ReplaceKeyPrefixWith to /documents . Not required if one\n\t// of the siblings is present. Can be present only if ReplaceKeyWith is not\n\t// provided.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\tReplaceKeyPrefixWith *string\n\n\t// The specific object key to use in the redirect request. For example, redirect\n\t// request to error.html . Not required if one of the siblings is present. Can be\n\t// present only if ReplaceKeyPrefixWith is not provided.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\tReplaceKeyWith *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the redirect behavior of all requests to a website endpoint of an\n// Amazon S3 bucket.\ntype RedirectAllRequestsTo struct {\n\n\t// Name of the host where requests are redirected.\n\t//\n\t// This member is required.\n\tHostName *string\n\n\t// Protocol to use when redirecting requests. The default is the protocol that is\n\t// used in the original request.\n\tProtocol Protocol\n\n\tnoSmithyDocumentSerde\n}\n\n// A filter that you can specify for selection for modifications on replicas.\n// Amazon S3 doesn't replicate replica modifications by default. In the latest\n// version of replication configuration (when Filter is specified), you can\n// specify this element and set the status to Enabled to replicate modifications\n// on replicas.\n//\n// If you don't specify the Filter element, Amazon S3 assumes that the replication\n// configuration is the earlier version, V1. In the earlier version, this element\n// is not allowed.\ntype ReplicaModifications struct {\n\n\t// Specifies whether Amazon S3 replicates modifications on replicas.\n\t//\n\t// This member is required.\n\tStatus ReplicaModificationsStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for replication rules. You can add up to 1,000 rules. The maximum\n// size of a replication configuration is 2 MB.\ntype ReplicationConfiguration struct {\n\n\t// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role\n\t// that Amazon S3 assumes when replicating objects. For more information, see [How to Set Up Replication]in\n\t// the Amazon S3 User Guide.\n\t//\n\t// [How to Set Up Replication]: https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html\n\t//\n\t// This member is required.\n\tRole *string\n\n\t// A container for one or more replication rules. A replication configuration must\n\t// have at least one rule and can contain a maximum of 1,000 rules.\n\t//\n\t// This member is required.\n\tRules []ReplicationRule\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies which Amazon S3 objects to replicate and where to store the replicas.\ntype ReplicationRule struct {\n\n\t// A container for information about the replication destination and its\n\t// configurations including enabling the S3 Replication Time Control (S3 RTC).\n\t//\n\t// This member is required.\n\tDestination *Destination\n\n\t// Specifies whether the rule is enabled.\n\t//\n\t// This member is required.\n\tStatus ReplicationRuleStatus\n\n\t// Specifies whether Amazon S3 replicates delete markers. If you specify a Filter\n\t// in your replication configuration, you must also include a\n\t// DeleteMarkerReplication element. If your Filter includes a Tag element, the\n\t// DeleteMarkerReplication Status must be set to Disabled, because Amazon S3 does\n\t// not support replicating delete markers for tag-based rules. For an example\n\t// configuration, see [Basic Rule Configuration].\n\t//\n\t// For more information about delete marker replication, see [Basic Rule Configuration].\n\t//\n\t// If you are using an earlier version of the replication configuration, Amazon S3\n\t// handles replication of delete markers differently. For more information, see [Backward Compatibility].\n\t//\n\t// [Basic Rule Configuration]: https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html\n\t// [Backward Compatibility]: https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations\n\tDeleteMarkerReplication *DeleteMarkerReplication\n\n\t// Optional configuration to replicate existing source bucket objects.\n\t//\n\t// This parameter is no longer supported. To replicate existing objects, see [Replicating existing objects with S3 Batch Replication] in\n\t// the Amazon S3 User Guide.\n\t//\n\t// [Replicating existing objects with S3 Batch Replication]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-batch-replication-batch.html\n\tExistingObjectReplication *ExistingObjectReplication\n\n\t// A filter that identifies the subset of objects to which the replication rule\n\t// applies. A Filter must specify exactly one Prefix , Tag , or an And child\n\t// element.\n\tFilter *ReplicationRuleFilter\n\n\t// A unique identifier for the rule. The maximum value is 255 characters.\n\tID *string\n\n\t// An object key name prefix that identifies the object or objects to which the\n\t// rule applies. The maximum prefix length is 1,024 characters. To include all\n\t// objects in a bucket, specify an empty string.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\t//\n\t// Deprecated: This member has been deprecated.\n\tPrefix *string\n\n\t// The priority indicates which rule has precedence whenever two or more\n\t// replication rules conflict. Amazon S3 will attempt to replicate objects\n\t// according to all replication rules. However, if there are two or more rules with\n\t// the same destination bucket, then objects will be replicated according to the\n\t// rule with the highest priority. The higher the number, the higher the priority.\n\t//\n\t// For more information, see [Replication] in the Amazon S3 User Guide.\n\t//\n\t// [Replication]: https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html\n\tPriority *int32\n\n\t// A container that describes additional filters for identifying the source\n\t// objects that you want to replicate. You can choose to enable or disable the\n\t// replication of these objects. Currently, Amazon S3 supports only the filter that\n\t// you can specify for objects created with server-side encryption using a customer\n\t// managed key stored in Amazon Web Services Key Management Service (SSE-KMS).\n\tSourceSelectionCriteria *SourceSelectionCriteria\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for specifying rule filters. The filters determine the subset of\n// objects to which the rule applies. This element is required only if you specify\n// more than one filter.\n//\n// For example:\n//\n//   - If you specify both a Prefix and a Tag filter, wrap these filters in an And\n//     tag.\n//\n//   - If you specify a filter based on multiple tags, wrap the Tag elements in an\n//     And tag.\ntype ReplicationRuleAndOperator struct {\n\n\t// An object key name prefix that identifies the subset of objects to which the\n\t// rule applies.\n\tPrefix *string\n\n\t// An array of tags containing key and value pairs.\n\tTags []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// A filter that identifies the subset of objects to which the replication rule\n// applies. A Filter must specify exactly one Prefix , Tag , or an And child\n// element.\ntype ReplicationRuleFilter struct {\n\n\t// A container for specifying rule filters. The filters determine the subset of\n\t// objects to which the rule applies. This element is required only if you specify\n\t// more than one filter. For example:\n\t//\n\t//   - If you specify both a Prefix and a Tag filter, wrap these filters in an And\n\t//   tag.\n\t//\n\t//   - If you specify a filter based on multiple tags, wrap the Tag elements in an\n\t//   And tag.\n\tAnd *ReplicationRuleAndOperator\n\n\t// An object key name prefix that identifies the subset of objects to which the\n\t// rule applies.\n\t//\n\t// Replacement must be made for object keys containing special characters (such as\n\t// carriage returns) when using XML requests. For more information, see [XML related object key constraints].\n\t//\n\t// [XML related object key constraints]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints\n\tPrefix *string\n\n\t// A container for specifying a tag key and value.\n\t//\n\t// The rule applies only to objects that have the tag in their tag set.\n\tTag *Tag\n\n\tnoSmithyDocumentSerde\n}\n\n//\tA container specifying S3 Replication Time Control (S3 RTC) related\n//\n// information, including whether S3 RTC is enabled and the time when all objects\n// and operations on objects must be replicated. Must be specified together with a\n// Metrics block.\ntype ReplicationTime struct {\n\n\t//  Specifies whether the replication time is enabled.\n\t//\n\t// This member is required.\n\tStatus ReplicationTimeStatus\n\n\t//  A container specifying the time by which replication should be complete for\n\t// all objects and operations on objects.\n\t//\n\t// This member is required.\n\tTime *ReplicationTimeValue\n\n\tnoSmithyDocumentSerde\n}\n\n//\tA container specifying the time value for S3 Replication Time Control (S3 RTC)\n//\n// and replication metrics EventThreshold .\ntype ReplicationTimeValue struct {\n\n\t//  Contains an integer specifying time in minutes.\n\t//\n\t// Valid value: 15\n\tMinutes *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for Payer.\ntype RequestPaymentConfiguration struct {\n\n\t// Specifies who pays for the download and request fees.\n\t//\n\t// This member is required.\n\tPayer Payer\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for specifying if periodic QueryProgress messages should be sent.\ntype RequestProgress struct {\n\n\t// Specifies whether periodic QueryProgress frames should be sent. Valid values:\n\t// TRUE, FALSE. Default value: FALSE.\n\tEnabled *bool\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for restore job parameters.\ntype RestoreRequest struct {\n\n\t// Lifetime of the active copy in days. Do not use with restores that specify\n\t// OutputLocation .\n\t//\n\t// The Days element is required for regular restores, and must not be provided for\n\t// select requests.\n\tDays *int32\n\n\t// The optional description for the job.\n\tDescription *string\n\n\t// S3 Glacier related parameters pertaining to this job. Do not use with restores\n\t// that specify OutputLocation .\n\tGlacierJobParameters *GlacierJobParameters\n\n\t// Describes the location where the restore job's output is stored.\n\tOutputLocation *OutputLocation\n\n\t// Amazon S3 Select is no longer available to new customers. Existing customers of\n\t// Amazon S3 Select can continue to use the feature as usual. [Learn more]\n\t//\n\t// Describes the parameters for Select job types.\n\t//\n\t// [Learn more]: http://aws.amazon.com/blogs/storage/how-to-optimize-querying-your-data-in-amazon-s3/\n\tSelectParameters *SelectParameters\n\n\t// Retrieval tier at which the restore will be processed.\n\tTier Tier\n\n\t// Amazon S3 Select is no longer available to new customers. Existing customers of\n\t// Amazon S3 Select can continue to use the feature as usual. [Learn more]\n\t//\n\t// Type of restore request.\n\t//\n\t// [Learn more]: http://aws.amazon.com/blogs/storage/how-to-optimize-querying-your-data-in-amazon-s3/\n\tType RestoreRequestType\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the restoration status of an object. Objects in certain storage\n// classes must be restored before they can be retrieved. For more information\n// about these storage classes and how to work with archived objects, see [Working with archived objects]in the\n// Amazon S3 User Guide.\n//\n// This functionality is not supported for directory buckets. Directory buckets\n// only support EXPRESS_ONEZONE (the S3 Express One Zone storage class) in\n// Availability Zones and ONEZONE_IA (the S3 One Zone-Infrequent Access storage\n// class) in Dedicated Local Zones.\n//\n// [Working with archived objects]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/archived-objects.html\ntype RestoreStatus struct {\n\n\t// Specifies whether the object is currently being restored. If the object\n\t// restoration is in progress, the header returns the value TRUE . For example:\n\t//\n\t//     x-amz-optional-object-attributes: IsRestoreInProgress=\"true\"\n\t//\n\t// If the object restoration has completed, the header returns the value FALSE .\n\t// For example:\n\t//\n\t//     x-amz-optional-object-attributes: IsRestoreInProgress=\"false\",\n\t//     RestoreExpiryDate=\"2012-12-21T00:00:00.000Z\"\n\t//\n\t// If the object hasn't been restored, there is no header response.\n\tIsRestoreInProgress *bool\n\n\t// Indicates when the restored copy will expire. This value is populated only if\n\t// the object has already been restored. For example:\n\t//\n\t//     x-amz-optional-object-attributes: IsRestoreInProgress=\"false\",\n\t//     RestoreExpiryDate=\"2012-12-21T00:00:00.000Z\"\n\tRestoreExpiryDate *time.Time\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the redirect behavior and when a redirect is applied. For more\n// information about routing rules, see [Configuring advanced conditional redirects]in the Amazon S3 User Guide.\n//\n// [Configuring advanced conditional redirects]: https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html#advanced-conditional-redirects\ntype RoutingRule struct {\n\n\t// Container for redirect information. You can redirect requests to another host,\n\t// to another page, or with another protocol. In the event of an error, you can\n\t// specify a different error code to return.\n\t//\n\t// This member is required.\n\tRedirect *Redirect\n\n\t// A container for describing a condition that must be met for the specified\n\t// redirect to apply. For example, 1. If request is for pages in the /docs folder,\n\t// redirect to the /documents folder. 2. If request results in HTTP error 4xx,\n\t// redirect request to another host where you might process the error.\n\tCondition *Condition\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for object key name prefix and suffix filtering rules.\ntype S3KeyFilter struct {\n\n\t// A list of containers for the key-value pair that defines the criteria for the\n\t// filter rule.\n\tFilterRules []FilterRule\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes an Amazon S3 location that will receive the results of the restore\n// request.\ntype S3Location struct {\n\n\t// The name of the bucket where the restore results will be placed.\n\t//\n\t// This member is required.\n\tBucketName *string\n\n\t// The prefix that is prepended to the restore results for this request.\n\t//\n\t// This member is required.\n\tPrefix *string\n\n\t// A list of grants that control access to the staged results.\n\tAccessControlList []Grant\n\n\t// The canned ACL to apply to the restore results.\n\tCannedACL ObjectCannedACL\n\n\t// Contains the type of server-side encryption used.\n\tEncryption *Encryption\n\n\t// The class of storage used to store the restore results.\n\tStorageClass StorageClass\n\n\t// The tag-set that is applied to the restore results.\n\tTagging *Tagging\n\n\t// A list of metadata to store with the restore results in S3.\n\tUserMetadata []MetadataEntry\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe destination information for a V1 S3 Metadata configuration. The\n//\n// destination table bucket must be in the same Region and Amazon Web Services\n// account as the general purpose bucket. The specified metadata table name must be\n// unique within the aws_s3_metadata namespace in the destination table bucket.\n//\n// If you created your S3 Metadata configuration before July 15, 2025, we\n// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n// can expire journal table records and create a live inventory table.\n//\n// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\ntype S3TablesDestination struct {\n\n\t//  The Amazon Resource Name (ARN) for the table bucket that's specified as the\n\t// destination in the metadata table configuration. The destination table bucket\n\t// must be in the same Region and Amazon Web Services account as the general\n\t// purpose bucket.\n\t//\n\t// This member is required.\n\tTableBucketArn *string\n\n\t//  The name for the metadata table in your metadata table configuration. The\n\t// specified metadata table name must be unique within the aws_s3_metadata\n\t// namespace in the destination table bucket.\n\t//\n\t// This member is required.\n\tTableName *string\n\n\tnoSmithyDocumentSerde\n}\n\n//\tThe destination information for a V1 S3 Metadata configuration. The\n//\n// destination table bucket must be in the same Region and Amazon Web Services\n// account as the general purpose bucket. The specified metadata table name must be\n// unique within the aws_s3_metadata namespace in the destination table bucket.\n//\n// If you created your S3 Metadata configuration before July 15, 2025, we\n// recommend that you delete and re-create your configuration by using [CreateBucketMetadataConfiguration]so that you\n// can expire journal table records and create a live inventory table.\n//\n// [CreateBucketMetadataConfiguration]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateBucketMetadataConfiguration.html\ntype S3TablesDestinationResult struct {\n\n\t//  The Amazon Resource Name (ARN) for the metadata table in the metadata table\n\t// configuration. The specified metadata table name must be unique within the\n\t// aws_s3_metadata namespace in the destination table bucket.\n\t//\n\t// This member is required.\n\tTableArn *string\n\n\t//  The Amazon Resource Name (ARN) for the table bucket that's specified as the\n\t// destination in the metadata table configuration. The destination table bucket\n\t// must be in the same Region and Amazon Web Services account as the general\n\t// purpose bucket.\n\t//\n\t// This member is required.\n\tTableBucketArn *string\n\n\t//  The name for the metadata table in your metadata table configuration. The\n\t// specified metadata table name must be unique within the aws_s3_metadata\n\t// namespace in the destination table bucket.\n\t//\n\t// This member is required.\n\tTableName *string\n\n\t//  The table bucket namespace for the metadata table in your metadata table\n\t// configuration. This value is always aws_s3_metadata .\n\t//\n\t// This member is required.\n\tTableNamespace *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the byte range of the object to get the records from. A record is\n// processed when its first byte is contained by the range. This parameter is\n// optional, but when specified, it must not be empty. See RFC 2616, Section\n// 14.35.1 about how to specify the start and end of the range.\ntype ScanRange struct {\n\n\t// Specifies the end of the byte range. This parameter is optional. Valid values:\n\t// non-negative integers. The default value is one less than the size of the object\n\t// being queried. If only the End parameter is supplied, it is interpreted to mean\n\t// scan the last N bytes of the file. For example, 50 means scan the last 50 bytes.\n\tEnd *int64\n\n\t// Specifies the start of the byte range. This parameter is optional. Valid\n\t// values: non-negative integers. The default value is 0. If only start is\n\t// supplied, it means scan from that point to the end of the file. For example, 50\n\t// means scan from byte 50 until the end of the file.\n\tStart *int64\n\n\tnoSmithyDocumentSerde\n}\n\n// The container for selecting objects from a content event stream.\n//\n// The following types satisfy this interface:\n//\n//\tSelectObjectContentEventStreamMemberCont\n//\tSelectObjectContentEventStreamMemberEnd\n//\tSelectObjectContentEventStreamMemberProgress\n//\tSelectObjectContentEventStreamMemberRecords\n//\tSelectObjectContentEventStreamMemberStats\ntype SelectObjectContentEventStream interface {\n\tisSelectObjectContentEventStream()\n}\n\n// The Continuation Event.\ntype SelectObjectContentEventStreamMemberCont struct {\n\tValue ContinuationEvent\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*SelectObjectContentEventStreamMemberCont) isSelectObjectContentEventStream() {}\n\n// The End Event.\ntype SelectObjectContentEventStreamMemberEnd struct {\n\tValue EndEvent\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*SelectObjectContentEventStreamMemberEnd) isSelectObjectContentEventStream() {}\n\n// The Progress Event.\ntype SelectObjectContentEventStreamMemberProgress struct {\n\tValue ProgressEvent\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*SelectObjectContentEventStreamMemberProgress) isSelectObjectContentEventStream() {}\n\n// The Records Event.\ntype SelectObjectContentEventStreamMemberRecords struct {\n\tValue RecordsEvent\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*SelectObjectContentEventStreamMemberRecords) isSelectObjectContentEventStream() {}\n\n// The Stats Event.\ntype SelectObjectContentEventStreamMemberStats struct {\n\tValue StatsEvent\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*SelectObjectContentEventStreamMemberStats) isSelectObjectContentEventStream() {}\n\n// Amazon S3 Select is no longer available to new customers. Existing customers of\n// Amazon S3 Select can continue to use the feature as usual. [Learn more]\n//\n// Describes the parameters for Select job types.\n//\n// Learn [How to optimize querying your data in Amazon S3] using [Amazon Athena], [S3 Object Lambda], or client-side filtering.\n//\n// [Learn more]: http://aws.amazon.com/blogs/storage/how-to-optimize-querying-your-data-in-amazon-s3/\n// [How to optimize querying your data in Amazon S3]: http://aws.amazon.com/blogs/storage/how-to-optimize-querying-your-data-in-amazon-s3/\n// [Amazon Athena]: https://docs.aws.amazon.com/athena/latest/ug/what-is.html\n// [S3 Object Lambda]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/transforming-objects.html\ntype SelectParameters struct {\n\n\t// Amazon S3 Select is no longer available to new customers. Existing customers of\n\t// Amazon S3 Select can continue to use the feature as usual. [Learn more]\n\t//\n\t// The expression that is used to query the object.\n\t//\n\t// [Learn more]: http://aws.amazon.com/blogs/storage/how-to-optimize-querying-your-data-in-amazon-s3/\n\t//\n\t// This member is required.\n\tExpression *string\n\n\t// The type of the provided expression (for example, SQL).\n\t//\n\t// This member is required.\n\tExpressionType ExpressionType\n\n\t// Describes the serialization format of the object.\n\t//\n\t// This member is required.\n\tInputSerialization *InputSerialization\n\n\t// Describes how the results of the Select job are serialized.\n\t//\n\t// This member is required.\n\tOutputSerialization *OutputSerialization\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes the default server-side encryption to apply to new objects in the\n// bucket. If a PUT Object request doesn't specify any server-side encryption, this\n// default encryption will be applied. For more information, see [PutBucketEncryption].\n//\n//   - General purpose buckets - If you don't specify a customer managed key at\n//     configuration, Amazon S3 automatically creates an Amazon Web Services KMS key (\n//     aws/s3 ) in your Amazon Web Services account the first time that you add an\n//     object encrypted with SSE-KMS to a bucket. By default, Amazon S3 uses this KMS\n//     key for SSE-KMS.\n//\n//   - Directory buckets - Your SSE-KMS configuration can only support 1 [customer managed key]per\n//     directory bucket's lifetime. The [Amazon Web Services managed key]( aws/s3 ) isn't supported.\n//\n//   - Directory buckets - For directory buckets, there are only two supported\n//     options for server-side encryption: SSE-S3 and SSE-KMS.\n//\n// [PutBucketEncryption]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html\n// [customer managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk\n// [Amazon Web Services managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk\ntype ServerSideEncryptionByDefault struct {\n\n\t// Server-side encryption algorithm to use for the default encryption.\n\t//\n\t// For directory buckets, there are only two supported values for server-side\n\t// encryption: AES256 and aws:kms .\n\t//\n\t// This member is required.\n\tSSEAlgorithm ServerSideEncryption\n\n\t// Amazon Web Services Key Management Service (KMS) customer managed key ID to use\n\t// for the default encryption.\n\t//\n\t//   - General purpose buckets - This parameter is allowed if and only if\n\t//   SSEAlgorithm is set to aws:kms or aws:kms:dsse .\n\t//\n\t//   - Directory buckets - This parameter is allowed if and only if SSEAlgorithm is\n\t//   set to aws:kms .\n\t//\n\t// You can specify the key ID, key alias, or the Amazon Resource Name (ARN) of the\n\t// KMS key.\n\t//\n\t//   - Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab\n\t//\n\t//   - Key ARN:\n\t//   arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab\n\t//\n\t//   - Key Alias: alias/alias-name\n\t//\n\t// If you are using encryption with cross-account or Amazon Web Services service\n\t// operations, you must use a fully qualified KMS key ARN. For more information,\n\t// see [Using encryption for cross-account operations].\n\t//\n\t//   - General purpose buckets - If you're specifying a customer managed KMS key,\n\t//   we recommend using a fully qualified KMS key ARN. If you use a KMS key alias\n\t//   instead, then KMS resolves the key within the requesters account. This behavior\n\t//   can result in data that's encrypted with a KMS key that belongs to the\n\t//   requester, and not the bucket owner. Also, if you use a key ID, you can run into\n\t//   a LogDestination undeliverable error when creating a VPC flow log.\n\t//\n\t//   - Directory buckets - When you specify an [KMS customer managed key]for encryption in your directory\n\t//   bucket, only use the key ID or key ARN. The key alias format of the KMS key\n\t//   isn't supported.\n\t//\n\t// Amazon S3 only supports symmetric encryption KMS keys. For more information,\n\t// see [Asymmetric keys in Amazon Web Services KMS]in the Amazon Web Services Key Management Service Developer Guide.\n\t//\n\t// [Using encryption for cross-account operations]: https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy\n\t// [KMS customer managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk\n\t// [Asymmetric keys in Amazon Web Services KMS]: https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html\n\tKMSMasterKeyID *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the default server-side-encryption configuration.\ntype ServerSideEncryptionConfiguration struct {\n\n\t// Container for information about a particular server-side encryption\n\t// configuration rule.\n\t//\n\t// This member is required.\n\tRules []ServerSideEncryptionRule\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the default server-side encryption configuration.\n//\n//   - General purpose buckets - If you're specifying a customer managed KMS key,\n//     we recommend using a fully qualified KMS key ARN. If you use a KMS key alias\n//     instead, then KMS resolves the key within the requesters account. This behavior\n//     can result in data that's encrypted with a KMS key that belongs to the\n//     requester, and not the bucket owner.\n//\n//   - Directory buckets - When you specify an [KMS customer managed key]for encryption in your directory\n//     bucket, only use the key ID or key ARN. The key alias format of the KMS key\n//     isn't supported.\n//\n// [KMS customer managed key]: https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk\ntype ServerSideEncryptionRule struct {\n\n\t// Specifies the default server-side encryption to apply to new objects in the\n\t// bucket. If a PUT Object request doesn't specify any server-side encryption, this\n\t// default encryption will be applied.\n\tApplyServerSideEncryptionByDefault *ServerSideEncryptionByDefault\n\n\t// A bucket-level setting for Amazon S3 general purpose buckets used to prevent\n\t// the upload of new objects encrypted with the specified server-side encryption\n\t// type. For example, blocking an encryption type will block PutObject , CopyObject\n\t// , PostObject , multipart upload, and replication requests to the bucket for\n\t// objects with the specified encryption type. However, you can continue to read\n\t// and list any pre-existing objects already encrypted with the specified\n\t// encryption type. For more information, see [Blocking an encryption type for a general purpose bucket].\n\t//\n\t// Currently, this parameter only supports blocking or unblocking Server Side\n\t// Encryption with Customer Provided Keys (SSE-C). For more information about\n\t// SSE-C, see [Using server-side encryption with customer-provided keys (SSE-C)].\n\t//\n\t// [Blocking an encryption type for a general purpose bucket]: https://docs.aws.amazon.com/AmazonS3/userguide/block-encryption-type.html\n\t// [Using server-side encryption with customer-provided keys (SSE-C)]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/ServerSideEncryptionCustomerKeys.html\n\tBlockedEncryptionTypes *BlockedEncryptionTypes\n\n\t// Specifies whether Amazon S3 should use an S3 Bucket Key with server-side\n\t// encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects\n\t// are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3\n\t// to use an S3 Bucket Key.\n\t//\n\t//   - General purpose buckets - By default, S3 Bucket Key is not enabled. For\n\t//   more information, see [Amazon S3 Bucket Keys]in the Amazon S3 User Guide.\n\t//\n\t//   - Directory buckets - S3 Bucket Keys are always enabled for GET and PUT\n\t//   operations in a directory bucket and cant be disabled. S3 Bucket Keys aren't\n\t//   supported, when you copy SSE-KMS encrypted objects from general purpose buckets\n\t//   to directory buckets, from directory buckets to general purpose buckets, or\n\t//   between directory buckets, through [CopyObject], [UploadPartCopy], [the Copy operation in Batch Operations], or [the import jobs]. In this case, Amazon S3 makes a\n\t//   call to KMS every time a copy request is made for a KMS-encrypted object.\n\t//\n\t// [Amazon S3 Bucket Keys]: https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html\n\t// [CopyObject]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CopyObject.html\n\t// [the import jobs]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-import-job\n\t// [UploadPartCopy]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html\n\t// [the Copy operation in Batch Operations]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-objects-Batch-Ops\n\tBucketKeyEnabled *bool\n\n\tnoSmithyDocumentSerde\n}\n\n// The established temporary security credentials of the session.\n//\n// Directory buckets - These session credentials are only supported for the\n// authentication and authorization of Zonal endpoint API operations on directory\n// buckets.\ntype SessionCredentials struct {\n\n\t// A unique identifier that's associated with a secret access key. The access key\n\t// ID and the secret access key are used together to sign programmatic Amazon Web\n\t// Services requests cryptographically.\n\t//\n\t// This member is required.\n\tAccessKeyId *string\n\n\t// Temporary security credentials expire after a specified interval. After\n\t// temporary credentials expire, any calls that you make with those credentials\n\t// will fail. So you must generate a new set of temporary credentials. Temporary\n\t// credentials cannot be extended or refreshed beyond the original specified\n\t// interval.\n\t//\n\t// This member is required.\n\tExpiration *time.Time\n\n\t// A key that's used with the access key ID to cryptographically sign programmatic\n\t// Amazon Web Services requests. Signing a request identifies the sender and\n\t// prevents the request from being altered.\n\t//\n\t// This member is required.\n\tSecretAccessKey *string\n\n\t// A part of the temporary security credentials. The session token is used to\n\t// validate the temporary security credentials.\n\t//\n\t// This member is required.\n\tSessionToken *string\n\n\tnoSmithyDocumentSerde\n}\n\n// To use simple format for S3 keys for log objects, set SimplePrefix to an empty\n// object.\n//\n//\t[DestinationPrefix][YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString]\ntype SimplePrefix struct {\n\tnoSmithyDocumentSerde\n}\n\n// A container that describes additional filters for identifying the source\n// objects that you want to replicate. You can choose to enable or disable the\n// replication of these objects. Currently, Amazon S3 supports only the filter that\n// you can specify for objects created with server-side encryption using a customer\n// managed key stored in Amazon Web Services Key Management Service (SSE-KMS).\ntype SourceSelectionCriteria struct {\n\n\t// A filter that you can specify for selections for modifications on replicas.\n\t// Amazon S3 doesn't replicate replica modifications by default. In the latest\n\t// version of replication configuration (when Filter is specified), you can\n\t// specify this element and set the status to Enabled to replicate modifications\n\t// on replicas.\n\t//\n\t// If you don't specify the Filter element, Amazon S3 assumes that the replication\n\t// configuration is the earlier version, V1. In the earlier version, this element\n\t// is not allowed\n\tReplicaModifications *ReplicaModifications\n\n\t//  A container for filter information for the selection of Amazon S3 objects\n\t// encrypted with Amazon Web Services KMS. If you include SourceSelectionCriteria\n\t// in the replication configuration, this element is required.\n\tSseKmsEncryptedObjects *SseKmsEncryptedObjects\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the use of SSE-KMS to encrypt delivered inventory reports.\ntype SSEKMS struct {\n\n\t// Specifies the ID of the Key Management Service (KMS) symmetric encryption\n\t// customer managed key to use for encrypting inventory reports.\n\t//\n\t// This member is required.\n\tKeyId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for filter information for the selection of S3 objects encrypted\n// with Amazon Web Services KMS.\ntype SseKmsEncryptedObjects struct {\n\n\t// Specifies whether Amazon S3 replicates objects created with server-side\n\t// encryption using an Amazon Web Services KMS key stored in Amazon Web Services\n\t// Key Management Service.\n\t//\n\t// This member is required.\n\tStatus SseKmsEncryptedObjectsStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies the use of SSE-S3 to encrypt delivered inventory reports.\ntype SSES3 struct {\n\tnoSmithyDocumentSerde\n}\n\n// Container for the stats details.\ntype Stats struct {\n\n\t// The total number of uncompressed object bytes processed.\n\tBytesProcessed *int64\n\n\t// The total number of bytes of records payload data returned.\n\tBytesReturned *int64\n\n\t// The total number of object bytes scanned.\n\tBytesScanned *int64\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for the Stats Event.\ntype StatsEvent struct {\n\n\t// The Stats event details.\n\tDetails *Stats\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies data related to access patterns to be collected and made available to\n// analyze the tradeoffs between different storage classes for an Amazon S3 bucket.\ntype StorageClassAnalysis struct {\n\n\t// Specifies how data related to the storage class analysis for an Amazon S3\n\t// bucket should be exported.\n\tDataExport *StorageClassAnalysisDataExport\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for data related to the storage class analysis for an Amazon S3\n// bucket for export.\ntype StorageClassAnalysisDataExport struct {\n\n\t// The place to store the data for an analysis.\n\t//\n\t// This member is required.\n\tDestination *AnalyticsExportDestination\n\n\t// The version of the output schema to use when exporting data. Must be V_1 .\n\t//\n\t// This member is required.\n\tOutputSchemaVersion StorageClassAnalysisSchemaVersion\n\n\tnoSmithyDocumentSerde\n}\n\n// A container of a key value name pair.\ntype Tag struct {\n\n\t// Name of the object key.\n\t//\n\t// This member is required.\n\tKey *string\n\n\t// Value of the tag.\n\t//\n\t// This member is required.\n\tValue *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for TagSet elements.\ntype Tagging struct {\n\n\t// A collection for a set of tags\n\t//\n\t// This member is required.\n\tTagSet []Tag\n\n\tnoSmithyDocumentSerde\n}\n\n// Container for granting information.\n//\n// Buckets that use the bucket owner enforced setting for Object Ownership don't\n// support target grants. For more information, see [Permissions server access log delivery]in the Amazon S3 User Guide.\n//\n// [Permissions server access log delivery]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/enable-server-access-logging.html#grant-log-delivery-permissions-general\ntype TargetGrant struct {\n\n\t// Container for the person being granted permissions.\n\tGrantee *Grantee\n\n\t// Logging permissions assigned to the grantee for the bucket.\n\tPermission BucketLogsPermission\n\n\tnoSmithyDocumentSerde\n}\n\n// Amazon S3 key format for log objects. Only one format, PartitionedPrefix or\n// SimplePrefix, is allowed.\ntype TargetObjectKeyFormat struct {\n\n\t// Partitioned S3 key for log objects.\n\tPartitionedPrefix *PartitionedPrefix\n\n\t// To use the simple format for S3 keys for log objects. To specify SimplePrefix\n\t// format, set SimplePrefix to {}.\n\tSimplePrefix *SimplePrefix\n\n\tnoSmithyDocumentSerde\n}\n\n// The S3 Intelligent-Tiering storage class is designed to optimize storage costs\n// by automatically moving data to the most cost-effective storage access tier,\n// without additional operational overhead.\ntype Tiering struct {\n\n\t// S3 Intelligent-Tiering access tier. See [Storage class for automatically optimizing frequently and infrequently accessed objects] for a list of access tiers in the S3\n\t// Intelligent-Tiering storage class.\n\t//\n\t// [Storage class for automatically optimizing frequently and infrequently accessed objects]: https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access\n\t//\n\t// This member is required.\n\tAccessTier IntelligentTieringAccessTier\n\n\t// The number of consecutive days of no access after which an object will be\n\t// eligible to be transitioned to the corresponding tier. The minimum number of\n\t// days specified for Archive Access tier must be at least 90 days and Deep Archive\n\t// Access tier must be at least 180 days. The maximum can be up to 2 years (730\n\t// days).\n\t//\n\t// This member is required.\n\tDays *int32\n\n\tnoSmithyDocumentSerde\n}\n\n// A container for specifying the configuration for publication of messages to an\n// Amazon Simple Notification Service (Amazon SNS) topic when Amazon S3 detects\n// specified events.\ntype TopicConfiguration struct {\n\n\t// The Amazon S3 bucket event about which to send notifications. For more\n\t// information, see [Supported Event Types]in the Amazon S3 User Guide.\n\t//\n\t// [Supported Event Types]: https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html\n\t//\n\t// This member is required.\n\tEvents []Event\n\n\t// The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3\n\t// publishes a message when it detects events of the specified type.\n\t//\n\t// This member is required.\n\tTopicArn *string\n\n\t// Specifies object key name filtering rules. For information about key name\n\t// filtering, see [Configuring event notifications using object key name filtering]in the Amazon S3 User Guide.\n\t//\n\t// [Configuring event notifications using object key name filtering]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html\n\tFilter *NotificationConfigurationFilter\n\n\t// An optional unique identifier for configurations in a notification\n\t// configuration. If you don't provide one, Amazon S3 will assign an ID.\n\tId *string\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies when an object transitions to a specified storage class. For more\n// information about Amazon S3 lifecycle configuration rules, see [Transitioning Objects Using Amazon S3 Lifecycle]in the Amazon S3\n// User Guide.\n//\n// [Transitioning Objects Using Amazon S3 Lifecycle]: https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html\ntype Transition struct {\n\n\t// Indicates when objects are transitioned to the specified storage class. The\n\t// date value must be in ISO 8601 format. The time is always midnight UTC.\n\tDate *time.Time\n\n\t// Indicates the number of days after creation when objects are transitioned to\n\t// the specified storage class. If the specified storage class is\n\t// INTELLIGENT_TIERING , GLACIER_IR , GLACIER , or DEEP_ARCHIVE , valid values are\n\t// 0 or positive integers. If the specified storage class is STANDARD_IA or\n\t// ONEZONE_IA , valid values are positive integers greater than 30 . Be aware that\n\t// some storage classes have a minimum storage duration and that you're charged for\n\t// transitioning objects before their minimum storage duration. For more\n\t// information, see [Constraints and considerations for transitions]in the Amazon S3 User Guide.\n\t//\n\t// [Constraints and considerations for transitions]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html#lifecycle-configuration-constraints\n\tDays *int32\n\n\t// The storage class to which you want the object to transition.\n\tStorageClass TransitionStorageClass\n\n\tnoSmithyDocumentSerde\n}\n\n// Describes the versioning state of an Amazon S3 bucket. For more information,\n// see [PUT Bucket versioning]in the Amazon S3 API Reference.\n//\n// [PUT Bucket versioning]: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html\ntype VersioningConfiguration struct {\n\n\t// Specifies whether MFA delete is enabled in the bucket versioning configuration.\n\t// This element is only returned if the bucket has been configured with MFA delete.\n\t// If the bucket has never been so configured, this element is not returned.\n\tMFADelete MFADelete\n\n\t// The versioning state of the bucket.\n\tStatus BucketVersioningStatus\n\n\tnoSmithyDocumentSerde\n}\n\n// Specifies website configuration parameters for an Amazon S3 bucket.\ntype WebsiteConfiguration struct {\n\n\t// The name of the error document for the website.\n\tErrorDocument *ErrorDocument\n\n\t// The name of the index document for the website.\n\tIndexDocument *IndexDocument\n\n\t// The redirect behavior for every request to this bucket's website endpoint.\n\t//\n\t// If you specify this property, you can't specify any other property.\n\tRedirectAllRequestsTo *RedirectAllRequestsTo\n\n\t// Rules that define when a redirect is applied and the redirect behavior.\n\tRoutingRules []RoutingRule\n\n\tnoSmithyDocumentSerde\n}\n\ntype noSmithyDocumentSerde = smithydocument.NoSerde\n\n// UnknownUnionMember is returned when a union member is returned over the wire,\n// but has an unknown tag.\ntype UnknownUnionMember struct {\n\tTag   string\n\tValue []byte\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (*UnknownUnionMember) isAnalyticsFilter()                {}\nfunc (*UnknownUnionMember) isMetricsFilter()                  {}\nfunc (*UnknownUnionMember) isSelectObjectContentEventStream() {}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/validators.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\tsmithy \"github.com/aws/smithy-go\"\n\t\"github.com/aws/smithy-go/middleware\"\n)\n\ntype validateOpAbortMultipartUpload struct {\n}\n\nfunc (*validateOpAbortMultipartUpload) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpAbortMultipartUpload) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*AbortMultipartUploadInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpAbortMultipartUploadInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCompleteMultipartUpload struct {\n}\n\nfunc (*validateOpCompleteMultipartUpload) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCompleteMultipartUpload) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CompleteMultipartUploadInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCompleteMultipartUploadInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCopyObject struct {\n}\n\nfunc (*validateOpCopyObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCopyObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CopyObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCopyObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCreateBucket struct {\n}\n\nfunc (*validateOpCreateBucket) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCreateBucket) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CreateBucketInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCreateBucketInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCreateBucketMetadataConfiguration struct {\n}\n\nfunc (*validateOpCreateBucketMetadataConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCreateBucketMetadataConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CreateBucketMetadataConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCreateBucketMetadataConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCreateBucketMetadataTableConfiguration struct {\n}\n\nfunc (*validateOpCreateBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCreateBucketMetadataTableConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CreateBucketMetadataTableConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCreateBucketMetadataTableConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCreateMultipartUpload struct {\n}\n\nfunc (*validateOpCreateMultipartUpload) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCreateMultipartUpload) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CreateMultipartUploadInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCreateMultipartUploadInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpCreateSession struct {\n}\n\nfunc (*validateOpCreateSession) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpCreateSession) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*CreateSessionInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpCreateSessionInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketAnalyticsConfiguration struct {\n}\n\nfunc (*validateOpDeleteBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketAnalyticsConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketAnalyticsConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketAnalyticsConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketCors struct {\n}\n\nfunc (*validateOpDeleteBucketCors) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketCors) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketCorsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketCorsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketEncryption struct {\n}\n\nfunc (*validateOpDeleteBucketEncryption) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketEncryption) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketEncryptionInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketEncryptionInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucket struct {\n}\n\nfunc (*validateOpDeleteBucket) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucket) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*validateOpDeleteBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketIntelligentTieringConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketIntelligentTieringConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketIntelligentTieringConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketInventoryConfiguration struct {\n}\n\nfunc (*validateOpDeleteBucketInventoryConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketInventoryConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketInventoryConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketInventoryConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketLifecycle struct {\n}\n\nfunc (*validateOpDeleteBucketLifecycle) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketLifecycle) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketLifecycleInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketLifecycleInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketMetadataConfiguration struct {\n}\n\nfunc (*validateOpDeleteBucketMetadataConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketMetadataConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketMetadataConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketMetadataConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketMetadataTableConfiguration struct {\n}\n\nfunc (*validateOpDeleteBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketMetadataTableConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketMetadataTableConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketMetadataTableConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketMetricsConfiguration struct {\n}\n\nfunc (*validateOpDeleteBucketMetricsConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketMetricsConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketMetricsConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketMetricsConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketOwnershipControls struct {\n}\n\nfunc (*validateOpDeleteBucketOwnershipControls) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketOwnershipControls) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketOwnershipControlsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketOwnershipControlsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketPolicy struct {\n}\n\nfunc (*validateOpDeleteBucketPolicy) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketPolicy) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketPolicyInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketPolicyInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketReplication struct {\n}\n\nfunc (*validateOpDeleteBucketReplication) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketReplication) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketReplicationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketReplicationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketTagging struct {\n}\n\nfunc (*validateOpDeleteBucketTagging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketTagging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketTaggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketTaggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteBucketWebsite struct {\n}\n\nfunc (*validateOpDeleteBucketWebsite) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteBucketWebsite) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteBucketWebsiteInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteBucketWebsiteInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteObject struct {\n}\n\nfunc (*validateOpDeleteObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteObjects struct {\n}\n\nfunc (*validateOpDeleteObjects) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteObjects) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteObjectsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteObjectsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeleteObjectTagging struct {\n}\n\nfunc (*validateOpDeleteObjectTagging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeleteObjectTagging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeleteObjectTaggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeleteObjectTaggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpDeletePublicAccessBlock struct {\n}\n\nfunc (*validateOpDeletePublicAccessBlock) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpDeletePublicAccessBlock) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*DeletePublicAccessBlockInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpDeletePublicAccessBlockInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketAbac struct {\n}\n\nfunc (*validateOpGetBucketAbac) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketAbac) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketAbacInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketAbacInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketAccelerateConfiguration struct {\n}\n\nfunc (*validateOpGetBucketAccelerateConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketAccelerateConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketAccelerateConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketAccelerateConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketAcl struct {\n}\n\nfunc (*validateOpGetBucketAcl) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketAcl) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketAclInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketAclInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketAnalyticsConfiguration struct {\n}\n\nfunc (*validateOpGetBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketAnalyticsConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketAnalyticsConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketAnalyticsConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketCors struct {\n}\n\nfunc (*validateOpGetBucketCors) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketCors) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketCorsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketCorsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketEncryption struct {\n}\n\nfunc (*validateOpGetBucketEncryption) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketEncryption) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketEncryptionInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketEncryptionInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*validateOpGetBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketIntelligentTieringConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketIntelligentTieringConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketIntelligentTieringConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketInventoryConfiguration struct {\n}\n\nfunc (*validateOpGetBucketInventoryConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketInventoryConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketInventoryConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketInventoryConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketLifecycleConfiguration struct {\n}\n\nfunc (*validateOpGetBucketLifecycleConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketLifecycleConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketLifecycleConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketLifecycleConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketLocation struct {\n}\n\nfunc (*validateOpGetBucketLocation) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketLocation) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketLocationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketLocationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketLogging struct {\n}\n\nfunc (*validateOpGetBucketLogging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketLogging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketLoggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketLoggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketMetadataConfiguration struct {\n}\n\nfunc (*validateOpGetBucketMetadataConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketMetadataConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketMetadataConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketMetadataConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketMetadataTableConfiguration struct {\n}\n\nfunc (*validateOpGetBucketMetadataTableConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketMetadataTableConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketMetadataTableConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketMetadataTableConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketMetricsConfiguration struct {\n}\n\nfunc (*validateOpGetBucketMetricsConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketMetricsConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketMetricsConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketMetricsConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketNotificationConfiguration struct {\n}\n\nfunc (*validateOpGetBucketNotificationConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketNotificationConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketNotificationConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketNotificationConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketOwnershipControls struct {\n}\n\nfunc (*validateOpGetBucketOwnershipControls) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketOwnershipControls) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketOwnershipControlsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketOwnershipControlsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketPolicy struct {\n}\n\nfunc (*validateOpGetBucketPolicy) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketPolicy) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketPolicyInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketPolicyInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketPolicyStatus struct {\n}\n\nfunc (*validateOpGetBucketPolicyStatus) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketPolicyStatus) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketPolicyStatusInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketPolicyStatusInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketReplication struct {\n}\n\nfunc (*validateOpGetBucketReplication) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketReplication) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketReplicationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketReplicationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketRequestPayment struct {\n}\n\nfunc (*validateOpGetBucketRequestPayment) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketRequestPayment) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketRequestPaymentInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketRequestPaymentInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketTagging struct {\n}\n\nfunc (*validateOpGetBucketTagging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketTagging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketTaggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketTaggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketVersioning struct {\n}\n\nfunc (*validateOpGetBucketVersioning) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketVersioning) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketVersioningInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketVersioningInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetBucketWebsite struct {\n}\n\nfunc (*validateOpGetBucketWebsite) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetBucketWebsite) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetBucketWebsiteInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetBucketWebsiteInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectAcl struct {\n}\n\nfunc (*validateOpGetObjectAcl) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectAcl) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectAclInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectAclInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectAttributes struct {\n}\n\nfunc (*validateOpGetObjectAttributes) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectAttributes) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectAttributesInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectAttributesInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObject struct {\n}\n\nfunc (*validateOpGetObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectLegalHold struct {\n}\n\nfunc (*validateOpGetObjectLegalHold) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectLegalHold) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectLegalHoldInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectLegalHoldInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectLockConfiguration struct {\n}\n\nfunc (*validateOpGetObjectLockConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectLockConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectLockConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectLockConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectRetention struct {\n}\n\nfunc (*validateOpGetObjectRetention) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectRetention) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectRetentionInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectRetentionInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectTagging struct {\n}\n\nfunc (*validateOpGetObjectTagging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectTagging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectTaggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectTaggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetObjectTorrent struct {\n}\n\nfunc (*validateOpGetObjectTorrent) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetObjectTorrent) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetObjectTorrentInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetObjectTorrentInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpGetPublicAccessBlock struct {\n}\n\nfunc (*validateOpGetPublicAccessBlock) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpGetPublicAccessBlock) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*GetPublicAccessBlockInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpGetPublicAccessBlockInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpHeadBucket struct {\n}\n\nfunc (*validateOpHeadBucket) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpHeadBucket) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*HeadBucketInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpHeadBucketInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpHeadObject struct {\n}\n\nfunc (*validateOpHeadObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpHeadObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*HeadObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpHeadObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListBucketAnalyticsConfigurations struct {\n}\n\nfunc (*validateOpListBucketAnalyticsConfigurations) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListBucketAnalyticsConfigurations) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListBucketAnalyticsConfigurationsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListBucketAnalyticsConfigurationsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListBucketIntelligentTieringConfigurations struct {\n}\n\nfunc (*validateOpListBucketIntelligentTieringConfigurations) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListBucketIntelligentTieringConfigurations) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListBucketIntelligentTieringConfigurationsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListBucketIntelligentTieringConfigurationsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListBucketInventoryConfigurations struct {\n}\n\nfunc (*validateOpListBucketInventoryConfigurations) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListBucketInventoryConfigurations) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListBucketInventoryConfigurationsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListBucketInventoryConfigurationsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListBucketMetricsConfigurations struct {\n}\n\nfunc (*validateOpListBucketMetricsConfigurations) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListBucketMetricsConfigurations) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListBucketMetricsConfigurationsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListBucketMetricsConfigurationsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListMultipartUploads struct {\n}\n\nfunc (*validateOpListMultipartUploads) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListMultipartUploads) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListMultipartUploadsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListMultipartUploadsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListObjects struct {\n}\n\nfunc (*validateOpListObjects) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListObjects) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListObjectsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListObjectsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListObjectsV2 struct {\n}\n\nfunc (*validateOpListObjectsV2) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListObjectsV2) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListObjectsV2Input)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListObjectsV2Input(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListObjectVersions struct {\n}\n\nfunc (*validateOpListObjectVersions) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListObjectVersions) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListObjectVersionsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListObjectVersionsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpListParts struct {\n}\n\nfunc (*validateOpListParts) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpListParts) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*ListPartsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpListPartsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketAbac struct {\n}\n\nfunc (*validateOpPutBucketAbac) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketAbac) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketAbacInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketAbacInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketAccelerateConfiguration struct {\n}\n\nfunc (*validateOpPutBucketAccelerateConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketAccelerateConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketAccelerateConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketAccelerateConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketAcl struct {\n}\n\nfunc (*validateOpPutBucketAcl) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketAcl) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketAclInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketAclInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketAnalyticsConfiguration struct {\n}\n\nfunc (*validateOpPutBucketAnalyticsConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketAnalyticsConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketAnalyticsConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketAnalyticsConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketCors struct {\n}\n\nfunc (*validateOpPutBucketCors) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketCors) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketCorsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketCorsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketEncryption struct {\n}\n\nfunc (*validateOpPutBucketEncryption) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketEncryption) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketEncryptionInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketEncryptionInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketIntelligentTieringConfiguration struct {\n}\n\nfunc (*validateOpPutBucketIntelligentTieringConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketIntelligentTieringConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketIntelligentTieringConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketIntelligentTieringConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketInventoryConfiguration struct {\n}\n\nfunc (*validateOpPutBucketInventoryConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketInventoryConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketInventoryConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketInventoryConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketLifecycleConfiguration struct {\n}\n\nfunc (*validateOpPutBucketLifecycleConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketLifecycleConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketLifecycleConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketLifecycleConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketLogging struct {\n}\n\nfunc (*validateOpPutBucketLogging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketLogging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketLoggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketLoggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketMetricsConfiguration struct {\n}\n\nfunc (*validateOpPutBucketMetricsConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketMetricsConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketMetricsConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketMetricsConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketNotificationConfiguration struct {\n}\n\nfunc (*validateOpPutBucketNotificationConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketNotificationConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketNotificationConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketNotificationConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketOwnershipControls struct {\n}\n\nfunc (*validateOpPutBucketOwnershipControls) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketOwnershipControls) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketOwnershipControlsInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketOwnershipControlsInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketPolicy struct {\n}\n\nfunc (*validateOpPutBucketPolicy) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketPolicy) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketPolicyInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketPolicyInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketReplication struct {\n}\n\nfunc (*validateOpPutBucketReplication) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketReplication) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketReplicationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketReplicationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketRequestPayment struct {\n}\n\nfunc (*validateOpPutBucketRequestPayment) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketRequestPayment) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketRequestPaymentInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketRequestPaymentInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketTagging struct {\n}\n\nfunc (*validateOpPutBucketTagging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketTagging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketTaggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketTaggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketVersioning struct {\n}\n\nfunc (*validateOpPutBucketVersioning) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketVersioning) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketVersioningInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketVersioningInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutBucketWebsite struct {\n}\n\nfunc (*validateOpPutBucketWebsite) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutBucketWebsite) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutBucketWebsiteInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutBucketWebsiteInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutObjectAcl struct {\n}\n\nfunc (*validateOpPutObjectAcl) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutObjectAcl) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutObjectAclInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutObjectAclInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutObject struct {\n}\n\nfunc (*validateOpPutObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutObjectLegalHold struct {\n}\n\nfunc (*validateOpPutObjectLegalHold) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutObjectLegalHold) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutObjectLegalHoldInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutObjectLegalHoldInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutObjectLockConfiguration struct {\n}\n\nfunc (*validateOpPutObjectLockConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutObjectLockConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutObjectLockConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutObjectLockConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutObjectRetention struct {\n}\n\nfunc (*validateOpPutObjectRetention) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutObjectRetention) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutObjectRetentionInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutObjectRetentionInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutObjectTagging struct {\n}\n\nfunc (*validateOpPutObjectTagging) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutObjectTagging) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutObjectTaggingInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutObjectTaggingInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpPutPublicAccessBlock struct {\n}\n\nfunc (*validateOpPutPublicAccessBlock) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpPutPublicAccessBlock) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*PutPublicAccessBlockInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpPutPublicAccessBlockInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpRenameObject struct {\n}\n\nfunc (*validateOpRenameObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpRenameObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*RenameObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpRenameObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpRestoreObject struct {\n}\n\nfunc (*validateOpRestoreObject) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpRestoreObject) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*RestoreObjectInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpRestoreObjectInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpSelectObjectContent struct {\n}\n\nfunc (*validateOpSelectObjectContent) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpSelectObjectContent) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*SelectObjectContentInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpSelectObjectContentInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpUpdateBucketMetadataInventoryTableConfiguration struct {\n}\n\nfunc (*validateOpUpdateBucketMetadataInventoryTableConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpUpdateBucketMetadataInventoryTableConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*UpdateBucketMetadataInventoryTableConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpUpdateBucketMetadataInventoryTableConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpUpdateBucketMetadataJournalTableConfiguration struct {\n}\n\nfunc (*validateOpUpdateBucketMetadataJournalTableConfiguration) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpUpdateBucketMetadataJournalTableConfiguration) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*UpdateBucketMetadataJournalTableConfigurationInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpUpdateBucketMetadataJournalTableConfigurationInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpUploadPartCopy struct {\n}\n\nfunc (*validateOpUploadPartCopy) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpUploadPartCopy) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*UploadPartCopyInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpUploadPartCopyInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpUploadPart struct {\n}\n\nfunc (*validateOpUploadPart) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpUploadPart) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*UploadPartInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpUploadPartInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\ntype validateOpWriteGetObjectResponse struct {\n}\n\nfunc (*validateOpWriteGetObjectResponse) ID() string {\n\treturn \"OperationInputValidation\"\n}\n\nfunc (m *validateOpWriteGetObjectResponse) HandleInitialize(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (\n\tout middleware.InitializeOutput, metadata middleware.Metadata, err error,\n) {\n\tinput, ok := in.Parameters.(*WriteGetObjectResponseInput)\n\tif !ok {\n\t\treturn out, metadata, fmt.Errorf(\"unknown input parameters type %T\", in.Parameters)\n\t}\n\tif err := validateOpWriteGetObjectResponseInput(input); err != nil {\n\t\treturn out, metadata, err\n\t}\n\treturn next.HandleInitialize(ctx, in)\n}\n\nfunc addOpAbortMultipartUploadValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpAbortMultipartUpload{}, middleware.After)\n}\n\nfunc addOpCompleteMultipartUploadValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCompleteMultipartUpload{}, middleware.After)\n}\n\nfunc addOpCopyObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCopyObject{}, middleware.After)\n}\n\nfunc addOpCreateBucketValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCreateBucket{}, middleware.After)\n}\n\nfunc addOpCreateBucketMetadataConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCreateBucketMetadataConfiguration{}, middleware.After)\n}\n\nfunc addOpCreateBucketMetadataTableConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCreateBucketMetadataTableConfiguration{}, middleware.After)\n}\n\nfunc addOpCreateMultipartUploadValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCreateMultipartUpload{}, middleware.After)\n}\n\nfunc addOpCreateSessionValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpCreateSession{}, middleware.After)\n}\n\nfunc addOpDeleteBucketAnalyticsConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketAnalyticsConfiguration{}, middleware.After)\n}\n\nfunc addOpDeleteBucketCorsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketCors{}, middleware.After)\n}\n\nfunc addOpDeleteBucketEncryptionValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketEncryption{}, middleware.After)\n}\n\nfunc addOpDeleteBucketValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucket{}, middleware.After)\n}\n\nfunc addOpDeleteBucketIntelligentTieringConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketIntelligentTieringConfiguration{}, middleware.After)\n}\n\nfunc addOpDeleteBucketInventoryConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketInventoryConfiguration{}, middleware.After)\n}\n\nfunc addOpDeleteBucketLifecycleValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketLifecycle{}, middleware.After)\n}\n\nfunc addOpDeleteBucketMetadataConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketMetadataConfiguration{}, middleware.After)\n}\n\nfunc addOpDeleteBucketMetadataTableConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketMetadataTableConfiguration{}, middleware.After)\n}\n\nfunc addOpDeleteBucketMetricsConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketMetricsConfiguration{}, middleware.After)\n}\n\nfunc addOpDeleteBucketOwnershipControlsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketOwnershipControls{}, middleware.After)\n}\n\nfunc addOpDeleteBucketPolicyValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketPolicy{}, middleware.After)\n}\n\nfunc addOpDeleteBucketReplicationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketReplication{}, middleware.After)\n}\n\nfunc addOpDeleteBucketTaggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketTagging{}, middleware.After)\n}\n\nfunc addOpDeleteBucketWebsiteValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteBucketWebsite{}, middleware.After)\n}\n\nfunc addOpDeleteObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteObject{}, middleware.After)\n}\n\nfunc addOpDeleteObjectsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteObjects{}, middleware.After)\n}\n\nfunc addOpDeleteObjectTaggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeleteObjectTagging{}, middleware.After)\n}\n\nfunc addOpDeletePublicAccessBlockValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpDeletePublicAccessBlock{}, middleware.After)\n}\n\nfunc addOpGetBucketAbacValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketAbac{}, middleware.After)\n}\n\nfunc addOpGetBucketAccelerateConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketAccelerateConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketAclValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketAcl{}, middleware.After)\n}\n\nfunc addOpGetBucketAnalyticsConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketAnalyticsConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketCorsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketCors{}, middleware.After)\n}\n\nfunc addOpGetBucketEncryptionValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketEncryption{}, middleware.After)\n}\n\nfunc addOpGetBucketIntelligentTieringConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketIntelligentTieringConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketInventoryConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketInventoryConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketLifecycleConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketLifecycleConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketLocationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketLocation{}, middleware.After)\n}\n\nfunc addOpGetBucketLoggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketLogging{}, middleware.After)\n}\n\nfunc addOpGetBucketMetadataConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketMetadataConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketMetadataTableConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketMetadataTableConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketMetricsConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketMetricsConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketNotificationConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketNotificationConfiguration{}, middleware.After)\n}\n\nfunc addOpGetBucketOwnershipControlsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketOwnershipControls{}, middleware.After)\n}\n\nfunc addOpGetBucketPolicyValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketPolicy{}, middleware.After)\n}\n\nfunc addOpGetBucketPolicyStatusValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketPolicyStatus{}, middleware.After)\n}\n\nfunc addOpGetBucketReplicationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketReplication{}, middleware.After)\n}\n\nfunc addOpGetBucketRequestPaymentValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketRequestPayment{}, middleware.After)\n}\n\nfunc addOpGetBucketTaggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketTagging{}, middleware.After)\n}\n\nfunc addOpGetBucketVersioningValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketVersioning{}, middleware.After)\n}\n\nfunc addOpGetBucketWebsiteValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetBucketWebsite{}, middleware.After)\n}\n\nfunc addOpGetObjectAclValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectAcl{}, middleware.After)\n}\n\nfunc addOpGetObjectAttributesValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectAttributes{}, middleware.After)\n}\n\nfunc addOpGetObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObject{}, middleware.After)\n}\n\nfunc addOpGetObjectLegalHoldValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectLegalHold{}, middleware.After)\n}\n\nfunc addOpGetObjectLockConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectLockConfiguration{}, middleware.After)\n}\n\nfunc addOpGetObjectRetentionValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectRetention{}, middleware.After)\n}\n\nfunc addOpGetObjectTaggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectTagging{}, middleware.After)\n}\n\nfunc addOpGetObjectTorrentValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetObjectTorrent{}, middleware.After)\n}\n\nfunc addOpGetPublicAccessBlockValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpGetPublicAccessBlock{}, middleware.After)\n}\n\nfunc addOpHeadBucketValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpHeadBucket{}, middleware.After)\n}\n\nfunc addOpHeadObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpHeadObject{}, middleware.After)\n}\n\nfunc addOpListBucketAnalyticsConfigurationsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListBucketAnalyticsConfigurations{}, middleware.After)\n}\n\nfunc addOpListBucketIntelligentTieringConfigurationsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListBucketIntelligentTieringConfigurations{}, middleware.After)\n}\n\nfunc addOpListBucketInventoryConfigurationsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListBucketInventoryConfigurations{}, middleware.After)\n}\n\nfunc addOpListBucketMetricsConfigurationsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListBucketMetricsConfigurations{}, middleware.After)\n}\n\nfunc addOpListMultipartUploadsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListMultipartUploads{}, middleware.After)\n}\n\nfunc addOpListObjectsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListObjects{}, middleware.After)\n}\n\nfunc addOpListObjectsV2ValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListObjectsV2{}, middleware.After)\n}\n\nfunc addOpListObjectVersionsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListObjectVersions{}, middleware.After)\n}\n\nfunc addOpListPartsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpListParts{}, middleware.After)\n}\n\nfunc addOpPutBucketAbacValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketAbac{}, middleware.After)\n}\n\nfunc addOpPutBucketAccelerateConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketAccelerateConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketAclValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketAcl{}, middleware.After)\n}\n\nfunc addOpPutBucketAnalyticsConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketAnalyticsConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketCorsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketCors{}, middleware.After)\n}\n\nfunc addOpPutBucketEncryptionValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketEncryption{}, middleware.After)\n}\n\nfunc addOpPutBucketIntelligentTieringConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketIntelligentTieringConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketInventoryConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketInventoryConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketLifecycleConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketLifecycleConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketLoggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketLogging{}, middleware.After)\n}\n\nfunc addOpPutBucketMetricsConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketMetricsConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketNotificationConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketNotificationConfiguration{}, middleware.After)\n}\n\nfunc addOpPutBucketOwnershipControlsValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketOwnershipControls{}, middleware.After)\n}\n\nfunc addOpPutBucketPolicyValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketPolicy{}, middleware.After)\n}\n\nfunc addOpPutBucketReplicationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketReplication{}, middleware.After)\n}\n\nfunc addOpPutBucketRequestPaymentValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketRequestPayment{}, middleware.After)\n}\n\nfunc addOpPutBucketTaggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketTagging{}, middleware.After)\n}\n\nfunc addOpPutBucketVersioningValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketVersioning{}, middleware.After)\n}\n\nfunc addOpPutBucketWebsiteValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutBucketWebsite{}, middleware.After)\n}\n\nfunc addOpPutObjectAclValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutObjectAcl{}, middleware.After)\n}\n\nfunc addOpPutObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutObject{}, middleware.After)\n}\n\nfunc addOpPutObjectLegalHoldValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutObjectLegalHold{}, middleware.After)\n}\n\nfunc addOpPutObjectLockConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutObjectLockConfiguration{}, middleware.After)\n}\n\nfunc addOpPutObjectRetentionValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutObjectRetention{}, middleware.After)\n}\n\nfunc addOpPutObjectTaggingValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutObjectTagging{}, middleware.After)\n}\n\nfunc addOpPutPublicAccessBlockValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpPutPublicAccessBlock{}, middleware.After)\n}\n\nfunc addOpRenameObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpRenameObject{}, middleware.After)\n}\n\nfunc addOpRestoreObjectValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpRestoreObject{}, middleware.After)\n}\n\nfunc addOpSelectObjectContentValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpSelectObjectContent{}, middleware.After)\n}\n\nfunc addOpUpdateBucketMetadataInventoryTableConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpUpdateBucketMetadataInventoryTableConfiguration{}, middleware.After)\n}\n\nfunc addOpUpdateBucketMetadataJournalTableConfigurationValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpUpdateBucketMetadataJournalTableConfiguration{}, middleware.After)\n}\n\nfunc addOpUploadPartCopyValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpUploadPartCopy{}, middleware.After)\n}\n\nfunc addOpUploadPartValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpUploadPart{}, middleware.After)\n}\n\nfunc addOpWriteGetObjectResponseValidationMiddleware(stack *middleware.Stack) error {\n\treturn stack.Initialize.Add(&validateOpWriteGetObjectResponse{}, middleware.After)\n}\n\nfunc validateAccessControlPolicy(v *types.AccessControlPolicy) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AccessControlPolicy\"}\n\tif v.Grants != nil {\n\t\tif err := validateGrants(v.Grants); err != nil {\n\t\t\tinvalidParams.AddNested(\"Grants\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateAccessControlTranslation(v *types.AccessControlTranslation) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AccessControlTranslation\"}\n\tif len(v.Owner) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Owner\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateAnalyticsAndOperator(v *types.AnalyticsAndOperator) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AnalyticsAndOperator\"}\n\tif v.Tags != nil {\n\t\tif err := validateTagSet(v.Tags); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tags\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateAnalyticsConfiguration(v *types.AnalyticsConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AnalyticsConfiguration\"}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.Filter != nil {\n\t\tif err := validateAnalyticsFilter(v.Filter); err != nil {\n\t\t\tinvalidParams.AddNested(\"Filter\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.StorageClassAnalysis == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"StorageClassAnalysis\"))\n\t} else if v.StorageClassAnalysis != nil {\n\t\tif err := validateStorageClassAnalysis(v.StorageClassAnalysis); err != nil {\n\t\t\tinvalidParams.AddNested(\"StorageClassAnalysis\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateAnalyticsExportDestination(v *types.AnalyticsExportDestination) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AnalyticsExportDestination\"}\n\tif v.S3BucketDestination == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"S3BucketDestination\"))\n\t} else if v.S3BucketDestination != nil {\n\t\tif err := validateAnalyticsS3BucketDestination(v.S3BucketDestination); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3BucketDestination\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateAnalyticsFilter(v types.AnalyticsFilter) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AnalyticsFilter\"}\n\tswitch uv := v.(type) {\n\tcase *types.AnalyticsFilterMemberAnd:\n\t\tif err := validateAnalyticsAndOperator(&uv.Value); err != nil {\n\t\t\tinvalidParams.AddNested(\"[And]\", err.(smithy.InvalidParamsError))\n\t\t}\n\n\tcase *types.AnalyticsFilterMemberTag:\n\t\tif err := validateTag(&uv.Value); err != nil {\n\t\t\tinvalidParams.AddNested(\"[Tag]\", err.(smithy.InvalidParamsError))\n\t\t}\n\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateAnalyticsS3BucketDestination(v *types.AnalyticsS3BucketDestination) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AnalyticsS3BucketDestination\"}\n\tif len(v.Format) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Format\"))\n\t}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateBucketLifecycleConfiguration(v *types.BucketLifecycleConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"BucketLifecycleConfiguration\"}\n\tif v.Rules == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Rules\"))\n\t} else if v.Rules != nil {\n\t\tif err := validateLifecycleRules(v.Rules); err != nil {\n\t\t\tinvalidParams.AddNested(\"Rules\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateBucketLoggingStatus(v *types.BucketLoggingStatus) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"BucketLoggingStatus\"}\n\tif v.LoggingEnabled != nil {\n\t\tif err := validateLoggingEnabled(v.LoggingEnabled); err != nil {\n\t\t\tinvalidParams.AddNested(\"LoggingEnabled\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateCORSConfiguration(v *types.CORSConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CORSConfiguration\"}\n\tif v.CORSRules == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"CORSRules\"))\n\t} else if v.CORSRules != nil {\n\t\tif err := validateCORSRules(v.CORSRules); err != nil {\n\t\t\tinvalidParams.AddNested(\"CORSRules\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateCORSRule(v *types.CORSRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CORSRule\"}\n\tif v.AllowedMethods == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"AllowedMethods\"))\n\t}\n\tif v.AllowedOrigins == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"AllowedOrigins\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateCORSRules(v []types.CORSRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CORSRules\"}\n\tfor i := range v {\n\t\tif err := validateCORSRule(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateCreateBucketConfiguration(v *types.CreateBucketConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CreateBucketConfiguration\"}\n\tif v.Tags != nil {\n\t\tif err := validateTagSet(v.Tags); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tags\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateDelete(v *types.Delete) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Delete\"}\n\tif v.Objects == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Objects\"))\n\t} else if v.Objects != nil {\n\t\tif err := validateObjectIdentifierList(v.Objects); err != nil {\n\t\t\tinvalidParams.AddNested(\"Objects\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateDestination(v *types.Destination) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Destination\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.AccessControlTranslation != nil {\n\t\tif err := validateAccessControlTranslation(v.AccessControlTranslation); err != nil {\n\t\t\tinvalidParams.AddNested(\"AccessControlTranslation\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.ReplicationTime != nil {\n\t\tif err := validateReplicationTime(v.ReplicationTime); err != nil {\n\t\t\tinvalidParams.AddNested(\"ReplicationTime\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.Metrics != nil {\n\t\tif err := validateMetrics(v.Metrics); err != nil {\n\t\t\tinvalidParams.AddNested(\"Metrics\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateEncryption(v *types.Encryption) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Encryption\"}\n\tif len(v.EncryptionType) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"EncryptionType\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateErrorDocument(v *types.ErrorDocument) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ErrorDocument\"}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateExistingObjectReplication(v *types.ExistingObjectReplication) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ExistingObjectReplication\"}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateGlacierJobParameters(v *types.GlacierJobParameters) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GlacierJobParameters\"}\n\tif len(v.Tier) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Tier\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateGrant(v *types.Grant) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Grant\"}\n\tif v.Grantee != nil {\n\t\tif err := validateGrantee(v.Grantee); err != nil {\n\t\t\tinvalidParams.AddNested(\"Grantee\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateGrantee(v *types.Grantee) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Grantee\"}\n\tif len(v.Type) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Type\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateGrants(v []types.Grant) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Grants\"}\n\tfor i := range v {\n\t\tif err := validateGrant(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateIndexDocument(v *types.IndexDocument) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"IndexDocument\"}\n\tif v.Suffix == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Suffix\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateIntelligentTieringAndOperator(v *types.IntelligentTieringAndOperator) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"IntelligentTieringAndOperator\"}\n\tif v.Tags != nil {\n\t\tif err := validateTagSet(v.Tags); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tags\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateIntelligentTieringConfiguration(v *types.IntelligentTieringConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"IntelligentTieringConfiguration\"}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.Filter != nil {\n\t\tif err := validateIntelligentTieringFilter(v.Filter); err != nil {\n\t\t\tinvalidParams.AddNested(\"Filter\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif v.Tierings == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Tierings\"))\n\t} else if v.Tierings != nil {\n\t\tif err := validateTieringList(v.Tierings); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tierings\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateIntelligentTieringFilter(v *types.IntelligentTieringFilter) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"IntelligentTieringFilter\"}\n\tif v.Tag != nil {\n\t\tif err := validateTag(v.Tag); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tag\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.And != nil {\n\t\tif err := validateIntelligentTieringAndOperator(v.And); err != nil {\n\t\t\tinvalidParams.AddNested(\"And\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryConfiguration(v *types.InventoryConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryConfiguration\"}\n\tif v.Destination == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Destination\"))\n\t} else if v.Destination != nil {\n\t\tif err := validateInventoryDestination(v.Destination); err != nil {\n\t\t\tinvalidParams.AddNested(\"Destination\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.IsEnabled == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"IsEnabled\"))\n\t}\n\tif v.Filter != nil {\n\t\tif err := validateInventoryFilter(v.Filter); err != nil {\n\t\t\tinvalidParams.AddNested(\"Filter\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif len(v.IncludedObjectVersions) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"IncludedObjectVersions\"))\n\t}\n\tif v.Schedule == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Schedule\"))\n\t} else if v.Schedule != nil {\n\t\tif err := validateInventorySchedule(v.Schedule); err != nil {\n\t\t\tinvalidParams.AddNested(\"Schedule\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryDestination(v *types.InventoryDestination) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryDestination\"}\n\tif v.S3BucketDestination == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"S3BucketDestination\"))\n\t} else if v.S3BucketDestination != nil {\n\t\tif err := validateInventoryS3BucketDestination(v.S3BucketDestination); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3BucketDestination\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryEncryption(v *types.InventoryEncryption) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryEncryption\"}\n\tif v.SSEKMS != nil {\n\t\tif err := validateSSEKMS(v.SSEKMS); err != nil {\n\t\t\tinvalidParams.AddNested(\"SSEKMS\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryFilter(v *types.InventoryFilter) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryFilter\"}\n\tif v.Prefix == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Prefix\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryS3BucketDestination(v *types.InventoryS3BucketDestination) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryS3BucketDestination\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif len(v.Format) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Format\"))\n\t}\n\tif v.Encryption != nil {\n\t\tif err := validateInventoryEncryption(v.Encryption); err != nil {\n\t\t\tinvalidParams.AddNested(\"Encryption\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventorySchedule(v *types.InventorySchedule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventorySchedule\"}\n\tif len(v.Frequency) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Frequency\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryTableConfiguration(v *types.InventoryTableConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryTableConfiguration\"}\n\tif len(v.ConfigurationState) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ConfigurationState\"))\n\t}\n\tif v.EncryptionConfiguration != nil {\n\t\tif err := validateMetadataTableEncryptionConfiguration(v.EncryptionConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"EncryptionConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateInventoryTableConfigurationUpdates(v *types.InventoryTableConfigurationUpdates) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"InventoryTableConfigurationUpdates\"}\n\tif len(v.ConfigurationState) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ConfigurationState\"))\n\t}\n\tif v.EncryptionConfiguration != nil {\n\t\tif err := validateMetadataTableEncryptionConfiguration(v.EncryptionConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"EncryptionConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateJournalTableConfiguration(v *types.JournalTableConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"JournalTableConfiguration\"}\n\tif v.RecordExpiration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"RecordExpiration\"))\n\t} else if v.RecordExpiration != nil {\n\t\tif err := validateRecordExpiration(v.RecordExpiration); err != nil {\n\t\t\tinvalidParams.AddNested(\"RecordExpiration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.EncryptionConfiguration != nil {\n\t\tif err := validateMetadataTableEncryptionConfiguration(v.EncryptionConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"EncryptionConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateJournalTableConfigurationUpdates(v *types.JournalTableConfigurationUpdates) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"JournalTableConfigurationUpdates\"}\n\tif v.RecordExpiration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"RecordExpiration\"))\n\t} else if v.RecordExpiration != nil {\n\t\tif err := validateRecordExpiration(v.RecordExpiration); err != nil {\n\t\t\tinvalidParams.AddNested(\"RecordExpiration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLambdaFunctionConfiguration(v *types.LambdaFunctionConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LambdaFunctionConfiguration\"}\n\tif v.LambdaFunctionArn == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"LambdaFunctionArn\"))\n\t}\n\tif v.Events == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Events\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLambdaFunctionConfigurationList(v []types.LambdaFunctionConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LambdaFunctionConfigurationList\"}\n\tfor i := range v {\n\t\tif err := validateLambdaFunctionConfiguration(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLifecycleRule(v *types.LifecycleRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LifecycleRule\"}\n\tif v.Filter != nil {\n\t\tif err := validateLifecycleRuleFilter(v.Filter); err != nil {\n\t\t\tinvalidParams.AddNested(\"Filter\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLifecycleRuleAndOperator(v *types.LifecycleRuleAndOperator) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LifecycleRuleAndOperator\"}\n\tif v.Tags != nil {\n\t\tif err := validateTagSet(v.Tags); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tags\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLifecycleRuleFilter(v *types.LifecycleRuleFilter) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LifecycleRuleFilter\"}\n\tif v.Tag != nil {\n\t\tif err := validateTag(v.Tag); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tag\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.And != nil {\n\t\tif err := validateLifecycleRuleAndOperator(v.And); err != nil {\n\t\t\tinvalidParams.AddNested(\"And\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLifecycleRules(v []types.LifecycleRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LifecycleRules\"}\n\tfor i := range v {\n\t\tif err := validateLifecycleRule(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateLoggingEnabled(v *types.LoggingEnabled) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"LoggingEnabled\"}\n\tif v.TargetBucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"TargetBucket\"))\n\t}\n\tif v.TargetGrants != nil {\n\t\tif err := validateTargetGrants(v.TargetGrants); err != nil {\n\t\t\tinvalidParams.AddNested(\"TargetGrants\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.TargetPrefix == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"TargetPrefix\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetadataConfiguration(v *types.MetadataConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"MetadataConfiguration\"}\n\tif v.JournalTableConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"JournalTableConfiguration\"))\n\t} else if v.JournalTableConfiguration != nil {\n\t\tif err := validateJournalTableConfiguration(v.JournalTableConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"JournalTableConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.InventoryTableConfiguration != nil {\n\t\tif err := validateInventoryTableConfiguration(v.InventoryTableConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"InventoryTableConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetadataTableConfiguration(v *types.MetadataTableConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"MetadataTableConfiguration\"}\n\tif v.S3TablesDestination == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"S3TablesDestination\"))\n\t} else if v.S3TablesDestination != nil {\n\t\tif err := validateS3TablesDestination(v.S3TablesDestination); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3TablesDestination\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetadataTableEncryptionConfiguration(v *types.MetadataTableEncryptionConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"MetadataTableEncryptionConfiguration\"}\n\tif len(v.SseAlgorithm) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"SseAlgorithm\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetrics(v *types.Metrics) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Metrics\"}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetricsAndOperator(v *types.MetricsAndOperator) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"MetricsAndOperator\"}\n\tif v.Tags != nil {\n\t\tif err := validateTagSet(v.Tags); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tags\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetricsConfiguration(v *types.MetricsConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"MetricsConfiguration\"}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.Filter != nil {\n\t\tif err := validateMetricsFilter(v.Filter); err != nil {\n\t\t\tinvalidParams.AddNested(\"Filter\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateMetricsFilter(v types.MetricsFilter) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"MetricsFilter\"}\n\tswitch uv := v.(type) {\n\tcase *types.MetricsFilterMemberAnd:\n\t\tif err := validateMetricsAndOperator(&uv.Value); err != nil {\n\t\t\tinvalidParams.AddNested(\"[And]\", err.(smithy.InvalidParamsError))\n\t\t}\n\n\tcase *types.MetricsFilterMemberTag:\n\t\tif err := validateTag(&uv.Value); err != nil {\n\t\t\tinvalidParams.AddNested(\"[Tag]\", err.(smithy.InvalidParamsError))\n\t\t}\n\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateNotificationConfiguration(v *types.NotificationConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"NotificationConfiguration\"}\n\tif v.TopicConfigurations != nil {\n\t\tif err := validateTopicConfigurationList(v.TopicConfigurations); err != nil {\n\t\t\tinvalidParams.AddNested(\"TopicConfigurations\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.QueueConfigurations != nil {\n\t\tif err := validateQueueConfigurationList(v.QueueConfigurations); err != nil {\n\t\t\tinvalidParams.AddNested(\"QueueConfigurations\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.LambdaFunctionConfigurations != nil {\n\t\tif err := validateLambdaFunctionConfigurationList(v.LambdaFunctionConfigurations); err != nil {\n\t\t\tinvalidParams.AddNested(\"LambdaFunctionConfigurations\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateObjectIdentifier(v *types.ObjectIdentifier) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ObjectIdentifier\"}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateObjectIdentifierList(v []types.ObjectIdentifier) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ObjectIdentifierList\"}\n\tfor i := range v {\n\t\tif err := validateObjectIdentifier(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOutputLocation(v *types.OutputLocation) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"OutputLocation\"}\n\tif v.S3 != nil {\n\t\tif err := validateS3Location(v.S3); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOwnershipControls(v *types.OwnershipControls) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"OwnershipControls\"}\n\tif v.Rules == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Rules\"))\n\t} else if v.Rules != nil {\n\t\tif err := validateOwnershipControlsRules(v.Rules); err != nil {\n\t\t\tinvalidParams.AddNested(\"Rules\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOwnershipControlsRule(v *types.OwnershipControlsRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"OwnershipControlsRule\"}\n\tif len(v.ObjectOwnership) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ObjectOwnership\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOwnershipControlsRules(v []types.OwnershipControlsRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"OwnershipControlsRules\"}\n\tfor i := range v {\n\t\tif err := validateOwnershipControlsRule(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateQueueConfiguration(v *types.QueueConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"QueueConfiguration\"}\n\tif v.QueueArn == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"QueueArn\"))\n\t}\n\tif v.Events == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Events\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateQueueConfigurationList(v []types.QueueConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"QueueConfigurationList\"}\n\tfor i := range v {\n\t\tif err := validateQueueConfiguration(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateRecordExpiration(v *types.RecordExpiration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RecordExpiration\"}\n\tif len(v.Expiration) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Expiration\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateRedirectAllRequestsTo(v *types.RedirectAllRequestsTo) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RedirectAllRequestsTo\"}\n\tif v.HostName == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"HostName\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicaModifications(v *types.ReplicaModifications) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicaModifications\"}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicationConfiguration(v *types.ReplicationConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicationConfiguration\"}\n\tif v.Role == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Role\"))\n\t}\n\tif v.Rules == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Rules\"))\n\t} else if v.Rules != nil {\n\t\tif err := validateReplicationRules(v.Rules); err != nil {\n\t\t\tinvalidParams.AddNested(\"Rules\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicationRule(v *types.ReplicationRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicationRule\"}\n\tif v.Filter != nil {\n\t\tif err := validateReplicationRuleFilter(v.Filter); err != nil {\n\t\t\tinvalidParams.AddNested(\"Filter\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif v.SourceSelectionCriteria != nil {\n\t\tif err := validateSourceSelectionCriteria(v.SourceSelectionCriteria); err != nil {\n\t\t\tinvalidParams.AddNested(\"SourceSelectionCriteria\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.ExistingObjectReplication != nil {\n\t\tif err := validateExistingObjectReplication(v.ExistingObjectReplication); err != nil {\n\t\t\tinvalidParams.AddNested(\"ExistingObjectReplication\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.Destination == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Destination\"))\n\t} else if v.Destination != nil {\n\t\tif err := validateDestination(v.Destination); err != nil {\n\t\t\tinvalidParams.AddNested(\"Destination\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicationRuleAndOperator(v *types.ReplicationRuleAndOperator) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicationRuleAndOperator\"}\n\tif v.Tags != nil {\n\t\tif err := validateTagSet(v.Tags); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tags\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicationRuleFilter(v *types.ReplicationRuleFilter) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicationRuleFilter\"}\n\tif v.Tag != nil {\n\t\tif err := validateTag(v.Tag); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tag\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.And != nil {\n\t\tif err := validateReplicationRuleAndOperator(v.And); err != nil {\n\t\t\tinvalidParams.AddNested(\"And\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicationRules(v []types.ReplicationRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicationRules\"}\n\tfor i := range v {\n\t\tif err := validateReplicationRule(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateReplicationTime(v *types.ReplicationTime) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ReplicationTime\"}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif v.Time == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Time\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateRequestPaymentConfiguration(v *types.RequestPaymentConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RequestPaymentConfiguration\"}\n\tif len(v.Payer) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Payer\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateRestoreRequest(v *types.RestoreRequest) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RestoreRequest\"}\n\tif v.GlacierJobParameters != nil {\n\t\tif err := validateGlacierJobParameters(v.GlacierJobParameters); err != nil {\n\t\t\tinvalidParams.AddNested(\"GlacierJobParameters\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.SelectParameters != nil {\n\t\tif err := validateSelectParameters(v.SelectParameters); err != nil {\n\t\t\tinvalidParams.AddNested(\"SelectParameters\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.OutputLocation != nil {\n\t\tif err := validateOutputLocation(v.OutputLocation); err != nil {\n\t\t\tinvalidParams.AddNested(\"OutputLocation\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateRoutingRule(v *types.RoutingRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RoutingRule\"}\n\tif v.Redirect == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Redirect\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateRoutingRules(v []types.RoutingRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RoutingRules\"}\n\tfor i := range v {\n\t\tif err := validateRoutingRule(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateS3Location(v *types.S3Location) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"S3Location\"}\n\tif v.BucketName == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"BucketName\"))\n\t}\n\tif v.Prefix == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Prefix\"))\n\t}\n\tif v.Encryption != nil {\n\t\tif err := validateEncryption(v.Encryption); err != nil {\n\t\t\tinvalidParams.AddNested(\"Encryption\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.AccessControlList != nil {\n\t\tif err := validateGrants(v.AccessControlList); err != nil {\n\t\t\tinvalidParams.AddNested(\"AccessControlList\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.Tagging != nil {\n\t\tif err := validateTagging(v.Tagging); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tagging\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateS3TablesDestination(v *types.S3TablesDestination) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"S3TablesDestination\"}\n\tif v.TableBucketArn == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"TableBucketArn\"))\n\t}\n\tif v.TableName == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"TableName\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateSelectParameters(v *types.SelectParameters) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"SelectParameters\"}\n\tif v.InputSerialization == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"InputSerialization\"))\n\t}\n\tif len(v.ExpressionType) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ExpressionType\"))\n\t}\n\tif v.Expression == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Expression\"))\n\t}\n\tif v.OutputSerialization == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"OutputSerialization\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateServerSideEncryptionByDefault(v *types.ServerSideEncryptionByDefault) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ServerSideEncryptionByDefault\"}\n\tif len(v.SSEAlgorithm) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"SSEAlgorithm\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateServerSideEncryptionConfiguration(v *types.ServerSideEncryptionConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ServerSideEncryptionConfiguration\"}\n\tif v.Rules == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Rules\"))\n\t} else if v.Rules != nil {\n\t\tif err := validateServerSideEncryptionRules(v.Rules); err != nil {\n\t\t\tinvalidParams.AddNested(\"Rules\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateServerSideEncryptionRule(v *types.ServerSideEncryptionRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ServerSideEncryptionRule\"}\n\tif v.ApplyServerSideEncryptionByDefault != nil {\n\t\tif err := validateServerSideEncryptionByDefault(v.ApplyServerSideEncryptionByDefault); err != nil {\n\t\t\tinvalidParams.AddNested(\"ApplyServerSideEncryptionByDefault\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateServerSideEncryptionRules(v []types.ServerSideEncryptionRule) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ServerSideEncryptionRules\"}\n\tfor i := range v {\n\t\tif err := validateServerSideEncryptionRule(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateSourceSelectionCriteria(v *types.SourceSelectionCriteria) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"SourceSelectionCriteria\"}\n\tif v.SseKmsEncryptedObjects != nil {\n\t\tif err := validateSseKmsEncryptedObjects(v.SseKmsEncryptedObjects); err != nil {\n\t\t\tinvalidParams.AddNested(\"SseKmsEncryptedObjects\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.ReplicaModifications != nil {\n\t\tif err := validateReplicaModifications(v.ReplicaModifications); err != nil {\n\t\t\tinvalidParams.AddNested(\"ReplicaModifications\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateSSEKMS(v *types.SSEKMS) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"SSEKMS\"}\n\tif v.KeyId == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"KeyId\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateSseKmsEncryptedObjects(v *types.SseKmsEncryptedObjects) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"SseKmsEncryptedObjects\"}\n\tif len(v.Status) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Status\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateStorageClassAnalysis(v *types.StorageClassAnalysis) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"StorageClassAnalysis\"}\n\tif v.DataExport != nil {\n\t\tif err := validateStorageClassAnalysisDataExport(v.DataExport); err != nil {\n\t\t\tinvalidParams.AddNested(\"DataExport\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateStorageClassAnalysisDataExport(v *types.StorageClassAnalysisDataExport) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"StorageClassAnalysisDataExport\"}\n\tif len(v.OutputSchemaVersion) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"OutputSchemaVersion\"))\n\t}\n\tif v.Destination == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Destination\"))\n\t} else if v.Destination != nil {\n\t\tif err := validateAnalyticsExportDestination(v.Destination); err != nil {\n\t\t\tinvalidParams.AddNested(\"Destination\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTag(v *types.Tag) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Tag\"}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.Value == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Value\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTagging(v *types.Tagging) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Tagging\"}\n\tif v.TagSet == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"TagSet\"))\n\t} else if v.TagSet != nil {\n\t\tif err := validateTagSet(v.TagSet); err != nil {\n\t\t\tinvalidParams.AddNested(\"TagSet\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTagSet(v []types.Tag) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"TagSet\"}\n\tfor i := range v {\n\t\tif err := validateTag(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTargetGrant(v *types.TargetGrant) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"TargetGrant\"}\n\tif v.Grantee != nil {\n\t\tif err := validateGrantee(v.Grantee); err != nil {\n\t\t\tinvalidParams.AddNested(\"Grantee\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTargetGrants(v []types.TargetGrant) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"TargetGrants\"}\n\tfor i := range v {\n\t\tif err := validateTargetGrant(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTiering(v *types.Tiering) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"Tiering\"}\n\tif v.Days == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Days\"))\n\t}\n\tif len(v.AccessTier) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"AccessTier\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTieringList(v []types.Tiering) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"TieringList\"}\n\tfor i := range v {\n\t\tif err := validateTiering(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTopicConfiguration(v *types.TopicConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"TopicConfiguration\"}\n\tif v.TopicArn == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"TopicArn\"))\n\t}\n\tif v.Events == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Events\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateTopicConfigurationList(v []types.TopicConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"TopicConfigurationList\"}\n\tfor i := range v {\n\t\tif err := validateTopicConfiguration(&v[i]); err != nil {\n\t\t\tinvalidParams.AddNested(fmt.Sprintf(\"[%d]\", i), err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateWebsiteConfiguration(v *types.WebsiteConfiguration) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"WebsiteConfiguration\"}\n\tif v.ErrorDocument != nil {\n\t\tif err := validateErrorDocument(v.ErrorDocument); err != nil {\n\t\t\tinvalidParams.AddNested(\"ErrorDocument\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.IndexDocument != nil {\n\t\tif err := validateIndexDocument(v.IndexDocument); err != nil {\n\t\t\tinvalidParams.AddNested(\"IndexDocument\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.RedirectAllRequestsTo != nil {\n\t\tif err := validateRedirectAllRequestsTo(v.RedirectAllRequestsTo); err != nil {\n\t\t\tinvalidParams.AddNested(\"RedirectAllRequestsTo\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.RoutingRules != nil {\n\t\tif err := validateRoutingRules(v.RoutingRules); err != nil {\n\t\t\tinvalidParams.AddNested(\"RoutingRules\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpAbortMultipartUploadInput(v *AbortMultipartUploadInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"AbortMultipartUploadInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.UploadId == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"UploadId\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCompleteMultipartUploadInput(v *CompleteMultipartUploadInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CompleteMultipartUploadInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.UploadId == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"UploadId\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCopyObjectInput(v *CopyObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CopyObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.CopySource == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"CopySource\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCreateBucketInput(v *CreateBucketInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CreateBucketInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.CreateBucketConfiguration != nil {\n\t\tif err := validateCreateBucketConfiguration(v.CreateBucketConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"CreateBucketConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCreateBucketMetadataConfigurationInput(v *CreateBucketMetadataConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CreateBucketMetadataConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.MetadataConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"MetadataConfiguration\"))\n\t} else if v.MetadataConfiguration != nil {\n\t\tif err := validateMetadataConfiguration(v.MetadataConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"MetadataConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCreateBucketMetadataTableConfigurationInput(v *CreateBucketMetadataTableConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CreateBucketMetadataTableConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.MetadataTableConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"MetadataTableConfiguration\"))\n\t} else if v.MetadataTableConfiguration != nil {\n\t\tif err := validateMetadataTableConfiguration(v.MetadataTableConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"MetadataTableConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCreateMultipartUploadInput(v *CreateMultipartUploadInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CreateMultipartUploadInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpCreateSessionInput(v *CreateSessionInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"CreateSessionInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketAnalyticsConfigurationInput(v *DeleteBucketAnalyticsConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketAnalyticsConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketCorsInput(v *DeleteBucketCorsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketCorsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketEncryptionInput(v *DeleteBucketEncryptionInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketEncryptionInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketInput(v *DeleteBucketInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketIntelligentTieringConfigurationInput(v *DeleteBucketIntelligentTieringConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketIntelligentTieringConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketInventoryConfigurationInput(v *DeleteBucketInventoryConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketInventoryConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketLifecycleInput(v *DeleteBucketLifecycleInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketLifecycleInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketMetadataConfigurationInput(v *DeleteBucketMetadataConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketMetadataConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketMetadataTableConfigurationInput(v *DeleteBucketMetadataTableConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketMetadataTableConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketMetricsConfigurationInput(v *DeleteBucketMetricsConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketMetricsConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketOwnershipControlsInput(v *DeleteBucketOwnershipControlsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketOwnershipControlsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketPolicyInput(v *DeleteBucketPolicyInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketPolicyInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketReplicationInput(v *DeleteBucketReplicationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketReplicationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketTaggingInput(v *DeleteBucketTaggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketTaggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteBucketWebsiteInput(v *DeleteBucketWebsiteInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteBucketWebsiteInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteObjectInput(v *DeleteObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteObjectsInput(v *DeleteObjectsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteObjectsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Delete == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Delete\"))\n\t} else if v.Delete != nil {\n\t\tif err := validateDelete(v.Delete); err != nil {\n\t\t\tinvalidParams.AddNested(\"Delete\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeleteObjectTaggingInput(v *DeleteObjectTaggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeleteObjectTaggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpDeletePublicAccessBlockInput(v *DeletePublicAccessBlockInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"DeletePublicAccessBlockInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketAbacInput(v *GetBucketAbacInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketAbacInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketAccelerateConfigurationInput(v *GetBucketAccelerateConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketAccelerateConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketAclInput(v *GetBucketAclInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketAclInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketAnalyticsConfigurationInput(v *GetBucketAnalyticsConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketAnalyticsConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketCorsInput(v *GetBucketCorsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketCorsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketEncryptionInput(v *GetBucketEncryptionInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketEncryptionInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketIntelligentTieringConfigurationInput(v *GetBucketIntelligentTieringConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketIntelligentTieringConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketInventoryConfigurationInput(v *GetBucketInventoryConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketInventoryConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketLifecycleConfigurationInput(v *GetBucketLifecycleConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketLifecycleConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketLocationInput(v *GetBucketLocationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketLocationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketLoggingInput(v *GetBucketLoggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketLoggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketMetadataConfigurationInput(v *GetBucketMetadataConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketMetadataConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketMetadataTableConfigurationInput(v *GetBucketMetadataTableConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketMetadataTableConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketMetricsConfigurationInput(v *GetBucketMetricsConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketMetricsConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketNotificationConfigurationInput(v *GetBucketNotificationConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketNotificationConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketOwnershipControlsInput(v *GetBucketOwnershipControlsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketOwnershipControlsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketPolicyInput(v *GetBucketPolicyInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketPolicyInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketPolicyStatusInput(v *GetBucketPolicyStatusInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketPolicyStatusInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketReplicationInput(v *GetBucketReplicationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketReplicationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketRequestPaymentInput(v *GetBucketRequestPaymentInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketRequestPaymentInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketTaggingInput(v *GetBucketTaggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketTaggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketVersioningInput(v *GetBucketVersioningInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketVersioningInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetBucketWebsiteInput(v *GetBucketWebsiteInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetBucketWebsiteInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectAclInput(v *GetObjectAclInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectAclInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectAttributesInput(v *GetObjectAttributesInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectAttributesInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.ObjectAttributes == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ObjectAttributes\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectInput(v *GetObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectLegalHoldInput(v *GetObjectLegalHoldInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectLegalHoldInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectLockConfigurationInput(v *GetObjectLockConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectLockConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectRetentionInput(v *GetObjectRetentionInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectRetentionInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectTaggingInput(v *GetObjectTaggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectTaggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetObjectTorrentInput(v *GetObjectTorrentInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetObjectTorrentInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpGetPublicAccessBlockInput(v *GetPublicAccessBlockInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"GetPublicAccessBlockInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpHeadBucketInput(v *HeadBucketInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"HeadBucketInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpHeadObjectInput(v *HeadObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"HeadObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListBucketAnalyticsConfigurationsInput(v *ListBucketAnalyticsConfigurationsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListBucketAnalyticsConfigurationsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListBucketIntelligentTieringConfigurationsInput(v *ListBucketIntelligentTieringConfigurationsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListBucketIntelligentTieringConfigurationsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListBucketInventoryConfigurationsInput(v *ListBucketInventoryConfigurationsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListBucketInventoryConfigurationsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListBucketMetricsConfigurationsInput(v *ListBucketMetricsConfigurationsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListBucketMetricsConfigurationsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListMultipartUploadsInput(v *ListMultipartUploadsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListMultipartUploadsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListObjectsInput(v *ListObjectsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListObjectsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListObjectsV2Input(v *ListObjectsV2Input) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListObjectsV2Input\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListObjectVersionsInput(v *ListObjectVersionsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListObjectVersionsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpListPartsInput(v *ListPartsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"ListPartsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.UploadId == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"UploadId\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketAbacInput(v *PutBucketAbacInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketAbacInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.AbacStatus == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"AbacStatus\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketAccelerateConfigurationInput(v *PutBucketAccelerateConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketAccelerateConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.AccelerateConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"AccelerateConfiguration\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketAclInput(v *PutBucketAclInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketAclInput\"}\n\tif v.AccessControlPolicy != nil {\n\t\tif err := validateAccessControlPolicy(v.AccessControlPolicy); err != nil {\n\t\t\tinvalidParams.AddNested(\"AccessControlPolicy\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketAnalyticsConfigurationInput(v *PutBucketAnalyticsConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketAnalyticsConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.AnalyticsConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"AnalyticsConfiguration\"))\n\t} else if v.AnalyticsConfiguration != nil {\n\t\tif err := validateAnalyticsConfiguration(v.AnalyticsConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"AnalyticsConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketCorsInput(v *PutBucketCorsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketCorsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.CORSConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"CORSConfiguration\"))\n\t} else if v.CORSConfiguration != nil {\n\t\tif err := validateCORSConfiguration(v.CORSConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"CORSConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketEncryptionInput(v *PutBucketEncryptionInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketEncryptionInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.ServerSideEncryptionConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ServerSideEncryptionConfiguration\"))\n\t} else if v.ServerSideEncryptionConfiguration != nil {\n\t\tif err := validateServerSideEncryptionConfiguration(v.ServerSideEncryptionConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"ServerSideEncryptionConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketIntelligentTieringConfigurationInput(v *PutBucketIntelligentTieringConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketIntelligentTieringConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.IntelligentTieringConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"IntelligentTieringConfiguration\"))\n\t} else if v.IntelligentTieringConfiguration != nil {\n\t\tif err := validateIntelligentTieringConfiguration(v.IntelligentTieringConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"IntelligentTieringConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketInventoryConfigurationInput(v *PutBucketInventoryConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketInventoryConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.InventoryConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"InventoryConfiguration\"))\n\t} else if v.InventoryConfiguration != nil {\n\t\tif err := validateInventoryConfiguration(v.InventoryConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"InventoryConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketLifecycleConfigurationInput(v *PutBucketLifecycleConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketLifecycleConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.LifecycleConfiguration != nil {\n\t\tif err := validateBucketLifecycleConfiguration(v.LifecycleConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"LifecycleConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketLoggingInput(v *PutBucketLoggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketLoggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.BucketLoggingStatus == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"BucketLoggingStatus\"))\n\t} else if v.BucketLoggingStatus != nil {\n\t\tif err := validateBucketLoggingStatus(v.BucketLoggingStatus); err != nil {\n\t\t\tinvalidParams.AddNested(\"BucketLoggingStatus\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketMetricsConfigurationInput(v *PutBucketMetricsConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketMetricsConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Id == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Id\"))\n\t}\n\tif v.MetricsConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"MetricsConfiguration\"))\n\t} else if v.MetricsConfiguration != nil {\n\t\tif err := validateMetricsConfiguration(v.MetricsConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"MetricsConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketNotificationConfigurationInput(v *PutBucketNotificationConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketNotificationConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.NotificationConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"NotificationConfiguration\"))\n\t} else if v.NotificationConfiguration != nil {\n\t\tif err := validateNotificationConfiguration(v.NotificationConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"NotificationConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketOwnershipControlsInput(v *PutBucketOwnershipControlsInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketOwnershipControlsInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.OwnershipControls == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"OwnershipControls\"))\n\t} else if v.OwnershipControls != nil {\n\t\tif err := validateOwnershipControls(v.OwnershipControls); err != nil {\n\t\t\tinvalidParams.AddNested(\"OwnershipControls\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketPolicyInput(v *PutBucketPolicyInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketPolicyInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Policy == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Policy\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketReplicationInput(v *PutBucketReplicationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketReplicationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.ReplicationConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ReplicationConfiguration\"))\n\t} else if v.ReplicationConfiguration != nil {\n\t\tif err := validateReplicationConfiguration(v.ReplicationConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"ReplicationConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketRequestPaymentInput(v *PutBucketRequestPaymentInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketRequestPaymentInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.RequestPaymentConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"RequestPaymentConfiguration\"))\n\t} else if v.RequestPaymentConfiguration != nil {\n\t\tif err := validateRequestPaymentConfiguration(v.RequestPaymentConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"RequestPaymentConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketTaggingInput(v *PutBucketTaggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketTaggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Tagging == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Tagging\"))\n\t} else if v.Tagging != nil {\n\t\tif err := validateTagging(v.Tagging); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tagging\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketVersioningInput(v *PutBucketVersioningInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketVersioningInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.VersioningConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"VersioningConfiguration\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutBucketWebsiteInput(v *PutBucketWebsiteInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutBucketWebsiteInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.WebsiteConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"WebsiteConfiguration\"))\n\t} else if v.WebsiteConfiguration != nil {\n\t\tif err := validateWebsiteConfiguration(v.WebsiteConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"WebsiteConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutObjectAclInput(v *PutObjectAclInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutObjectAclInput\"}\n\tif v.AccessControlPolicy != nil {\n\t\tif err := validateAccessControlPolicy(v.AccessControlPolicy); err != nil {\n\t\t\tinvalidParams.AddNested(\"AccessControlPolicy\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutObjectInput(v *PutObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutObjectLegalHoldInput(v *PutObjectLegalHoldInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutObjectLegalHoldInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutObjectLockConfigurationInput(v *PutObjectLockConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutObjectLockConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutObjectRetentionInput(v *PutObjectRetentionInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutObjectRetentionInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutObjectTaggingInput(v *PutObjectTaggingInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutObjectTaggingInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.Tagging == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Tagging\"))\n\t} else if v.Tagging != nil {\n\t\tif err := validateTagging(v.Tagging); err != nil {\n\t\t\tinvalidParams.AddNested(\"Tagging\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpPutPublicAccessBlockInput(v *PutPublicAccessBlockInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"PutPublicAccessBlockInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.PublicAccessBlockConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"PublicAccessBlockConfiguration\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpRenameObjectInput(v *RenameObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RenameObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.RenameSource == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"RenameSource\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpRestoreObjectInput(v *RestoreObjectInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"RestoreObjectInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.RestoreRequest != nil {\n\t\tif err := validateRestoreRequest(v.RestoreRequest); err != nil {\n\t\t\tinvalidParams.AddNested(\"RestoreRequest\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpSelectObjectContentInput(v *SelectObjectContentInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"SelectObjectContentInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.Expression == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Expression\"))\n\t}\n\tif len(v.ExpressionType) == 0 {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"ExpressionType\"))\n\t}\n\tif v.InputSerialization == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"InputSerialization\"))\n\t}\n\tif v.OutputSerialization == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"OutputSerialization\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpUpdateBucketMetadataInventoryTableConfigurationInput(v *UpdateBucketMetadataInventoryTableConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"UpdateBucketMetadataInventoryTableConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.InventoryTableConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"InventoryTableConfiguration\"))\n\t} else if v.InventoryTableConfiguration != nil {\n\t\tif err := validateInventoryTableConfigurationUpdates(v.InventoryTableConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"InventoryTableConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpUpdateBucketMetadataJournalTableConfigurationInput(v *UpdateBucketMetadataJournalTableConfigurationInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"UpdateBucketMetadataJournalTableConfigurationInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.JournalTableConfiguration == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"JournalTableConfiguration\"))\n\t} else if v.JournalTableConfiguration != nil {\n\t\tif err := validateJournalTableConfigurationUpdates(v.JournalTableConfiguration); err != nil {\n\t\t\tinvalidParams.AddNested(\"JournalTableConfiguration\", err.(smithy.InvalidParamsError))\n\t\t}\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpUploadPartCopyInput(v *UploadPartCopyInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"UploadPartCopyInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.CopySource == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"CopySource\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.PartNumber == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"PartNumber\"))\n\t}\n\tif v.UploadId == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"UploadId\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpUploadPartInput(v *UploadPartInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"UploadPartInput\"}\n\tif v.Bucket == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Bucket\"))\n\t}\n\tif v.Key == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"Key\"))\n\t}\n\tif v.PartNumber == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"PartNumber\"))\n\t}\n\tif v.UploadId == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"UploadId\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc validateOpWriteGetObjectResponseInput(v *WriteGetObjectResponseInput) error {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tinvalidParams := smithy.InvalidParamsError{Context: \"WriteGetObjectResponseInput\"}\n\tif v.RequestRoute == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"RequestRoute\"))\n\t}\n\tif v.RequestToken == nil {\n\t\tinvalidParams.Add(smithy.NewErrParamRequired(\"RequestToken\"))\n\t}\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t} else {\n\t\treturn nil\n\t}\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/modules.txt",
        "content": "# github.com/KyleBanks/depth v1.2.1\n## explicit\ngithub.com/KyleBanks/depth\n# github.com/Nerzal/gocloak/v13 v13.9.0\n## explicit; go 1.18\ngithub.com/Nerzal/gocloak/v13\ngithub.com/Nerzal/gocloak/v13/pkg/jwx\n# github.com/aws/aws-sdk-go-v2 v1.40.0\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/aws\ngithub.com/aws/aws-sdk-go-v2/aws/arn\ngithub.com/aws/aws-sdk-go-v2/aws/defaults\ngithub.com/aws/aws-sdk-go-v2/aws/middleware\ngithub.com/aws/aws-sdk-go-v2/aws/protocol/xml\ngithub.com/aws/aws-sdk-go-v2/aws/ratelimit\ngithub.com/aws/aws-sdk-go-v2/aws/retry\ngithub.com/aws/aws-sdk-go-v2/aws/signer/internal/v4\ngithub.com/aws/aws-sdk-go-v2/aws/signer/v4\ngithub.com/aws/aws-sdk-go-v2/aws/transport/http\ngithub.com/aws/aws-sdk-go-v2/internal/auth\ngithub.com/aws/aws-sdk-go-v2/internal/auth/smithy\ngithub.com/aws/aws-sdk-go-v2/internal/context\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints/awsrulesfn\ngithub.com/aws/aws-sdk-go-v2/internal/middleware\ngithub.com/aws/aws-sdk-go-v2/internal/rand\ngithub.com/aws/aws-sdk-go-v2/internal/sdk\ngithub.com/aws/aws-sdk-go-v2/internal/strings\ngithub.com/aws/aws-sdk-go-v2/internal/sync/singleflight\ngithub.com/aws/aws-sdk-go-v2/internal/timeconv\n# github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.7.3\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream\ngithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream/eventstreamapi\n# github.com/aws/aws-sdk-go-v2/internal/configsources v1.4.14\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/internal/configsources\n# github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.7.14\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints/v2\n# github.com/aws/aws-sdk-go-v2/internal/v4a v1.4.14\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/internal/v4a\ngithub.com/aws/aws-sdk-go-v2/internal/v4a/internal/crypto\ngithub.com/aws/aws-sdk-go-v2/internal/v4a/internal/v4\n# github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.13.3\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/service/internal/accept-encoding\n# github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.9.5\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/service/internal/checksum\n# github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.13.14\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/service/internal/presigned-url\n# github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.19.14\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/service/internal/s3shared\ngithub.com/aws/aws-sdk-go-v2/service/internal/s3shared/arn\ngithub.com/aws/aws-sdk-go-v2/service/internal/s3shared/config\n# github.com/aws/aws-sdk-go-v2/service/s3 v1.92.0\n## explicit; go 1.23\ngithub.com/aws/aws-sdk-go-v2/service/s3\ngithub.com/aws/aws-sdk-go-v2/service/s3/internal/arn\ngithub.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\ngithub.com/aws/aws-sdk-go-v2/service/s3/internal/endpoints\ngithub.com/aws/aws-sdk-go-v2/service/s3/types\n# github.com/aws/smithy-go v1.23.2\n## explicit; go 1.23\ngithub.com/aws/smithy-go\ngithub.com/aws/smithy-go/auth\ngithub.com/aws/smithy-go/auth/bearer\ngithub.com/aws/smithy-go/container/private/cache\ngithub.com/aws/smithy-go/container/private/cache/lru\ngithub.com/aws/smithy-go/context\ngithub.com/aws/smithy-go/document\ngithub.com/aws/smithy-go/encoding\ngithub.com/aws/smithy-go/encoding/httpbinding\ngithub.com/aws/smithy-go/encoding/xml\ngithub.com/aws/smithy-go/endpoints\ngithub.com/aws/smithy-go/endpoints/private/rulesfn\ngithub.com/aws/smithy-go/internal/sync/singleflight\ngithub.com/aws/smithy-go/io\ngithub.com/aws/smithy-go/logging\ngithub.com/aws/smithy-go/metrics\ngithub.com/aws/smithy-go/middleware\ngithub.com/aws/smithy-go/ptr\ngithub.com/aws/smithy-go/rand\ngithub.com/aws/smithy-go/sync\ngithub.com/aws/smithy-go/time\ngithub.com/aws/smithy-go/tracing\ngithub.com/aws/smithy-go/transport/http\ngithub.com/aws/smithy-go/transport/http/internal/io\ngithub.com/aws/smithy-go/waiter\n# github.com/beorn7/perks v1.0.1\n## explicit; go 1.11\ngithub.com/beorn7/perks/quantile\n# github.com/caarlos0/env/v6 v6.10.1\n## explicit; go 1.17\ngithub.com/caarlos0/env/v6\n# github.com/cespare/xxhash/v2 v2.3.0\n## explicit; go 1.11\ngithub.com/cespare/xxhash/v2\n# github.com/davecgh/go-spew v1.1.1\n## explicit\ngithub.com/davecgh/go-spew/spew\n# github.com/go-chi/chi/v5 v5.2.3\n## explicit; go 1.20\ngithub.com/go-chi/chi/v5\ngithub.com/go-chi/chi/v5/middleware\n# github.com/go-chi/cors v1.2.2\n## explicit; go 1.14\ngithub.com/go-chi/cors\n# github.com/go-chi/telemetry v0.0.0-00010101000000-000000000000 => github.com/Grekkq/telemetry v0.4.2-a\n## explicit; go 1.19\ngithub.com/go-chi/telemetry\n# github.com/go-openapi/jsonpointer v0.19.5\n## explicit; go 1.13\ngithub.com/go-openapi/jsonpointer\n# github.com/go-openapi/jsonreference v0.20.0\n## explicit; go 1.13\ngithub.com/go-openapi/jsonreference\ngithub.com/go-openapi/jsonreference/internal\n# github.com/go-openapi/spec v0.20.6\n## explicit; go 1.13\ngithub.com/go-openapi/spec\n# github.com/go-openapi/swag v0.19.15\n## explicit; go 1.11\ngithub.com/go-openapi/swag\n# github.com/go-resty/resty/v2 v2.7.0\n## explicit; go 1.11\ngithub.com/go-resty/resty/v2\n# github.com/golang-jwt/jwt/v5 v5.2.2\n## explicit; go 1.18\ngithub.com/golang-jwt/jwt/v5\n# github.com/golang/mock v1.6.0\n## explicit; go 1.11\ngithub.com/golang/mock/mockgen/model\n# github.com/josharian/intern v1.0.0\n## explicit; go 1.5\ngithub.com/josharian/intern\n# github.com/klauspost/compress v1.18.0\n## explicit; go 1.22\ngithub.com/klauspost/compress\ngithub.com/klauspost/compress/fse\ngithub.com/klauspost/compress/huff0\ngithub.com/klauspost/compress/internal/cpuinfo\ngithub.com/klauspost/compress/internal/le\ngithub.com/klauspost/compress/internal/race\ngithub.com/klauspost/compress/internal/snapref\ngithub.com/klauspost/compress/s2\ngithub.com/klauspost/compress/zstd\ngithub.com/klauspost/compress/zstd/internal/xxhash\n# github.com/mailru/easyjson v0.7.6\n## explicit; go 1.12\ngithub.com/mailru/easyjson/buffer\ngithub.com/mailru/easyjson/jlexer\ngithub.com/mailru/easyjson/jwriter\n# github.com/opentracing/opentracing-go v1.2.0\n## explicit; go 1.14\ngithub.com/opentracing/opentracing-go\ngithub.com/opentracing/opentracing-go/log\n# github.com/pierrec/lz4/v4 v4.1.22\n## explicit; go 1.14\ngithub.com/pierrec/lz4/v4\ngithub.com/pierrec/lz4/v4/internal/lz4block\ngithub.com/pierrec/lz4/v4/internal/lz4errors\ngithub.com/pierrec/lz4/v4/internal/lz4stream\ngithub.com/pierrec/lz4/v4/internal/xxh32\n# github.com/pkg/errors v0.9.1\n## explicit\ngithub.com/pkg/errors\n# github.com/pmezard/go-difflib v1.0.0\n## explicit\ngithub.com/pmezard/go-difflib/difflib\n# github.com/prometheus/client_golang v1.19.0\n## explicit; go 1.20\ngithub.com/prometheus/client_golang/prometheus\ngithub.com/prometheus/client_golang/prometheus/internal\ngithub.com/prometheus/client_golang/prometheus/promhttp\n# github.com/prometheus/client_model v0.6.1\n## explicit; go 1.19\ngithub.com/prometheus/client_model/go\n# github.com/prometheus/common v0.52.3\n## explicit; go 1.20\ngithub.com/prometheus/common/expfmt\ngithub.com/prometheus/common/internal/bitbucket.org/ww/goautoneg\ngithub.com/prometheus/common/model\n# github.com/prometheus/procfs v0.13.0\n## explicit; go 1.19\ngithub.com/prometheus/procfs\ngithub.com/prometheus/procfs/internal/fs\ngithub.com/prometheus/procfs/internal/util\n# github.com/segmentio/ksuid v1.0.4\n## explicit; go 1.12\ngithub.com/segmentio/ksuid\n# github.com/stretchr/testify v1.11.1\n## explicit; go 1.17\ngithub.com/stretchr/testify/assert\ngithub.com/stretchr/testify/assert/yaml\n# github.com/swaggo/files v0.0.0-20220610200504-28940afbdbfe\n## explicit; go 1.15\ngithub.com/swaggo/files\n# github.com/swaggo/http-swagger v1.3.4\n## explicit; go 1.17\ngithub.com/swaggo/http-swagger\n# github.com/swaggo/swag v1.16.6\n## explicit; go 1.18\ngithub.com/swaggo/swag\n# github.com/twmb/franz-go v1.20.2\n## explicit; go 1.24.0\ngithub.com/twmb/franz-go/pkg/kbin\ngithub.com/twmb/franz-go/pkg/kerr\ngithub.com/twmb/franz-go/pkg/kgo\ngithub.com/twmb/franz-go/pkg/kgo/internal/sticky\ngithub.com/twmb/franz-go/pkg/kversion\ngithub.com/twmb/franz-go/pkg/sasl\n# github.com/twmb/franz-go/pkg/kmsg v1.12.0\n## explicit; go 1.24.0\ngithub.com/twmb/franz-go/pkg/kmsg\ngithub.com/twmb/franz-go/pkg/kmsg/internal/kbin\n# github.com/twmb/murmur3 v1.1.8\n## explicit; go 1.11\ngithub.com/twmb/murmur3\n# github.com/uber-go/tally/v4 v4.1.16\n## explicit; go 1.15\ngithub.com/uber-go/tally/v4\ngithub.com/uber-go/tally/v4/internal/identity\ngithub.com/uber-go/tally/v4/prometheus\n# go.uber.org/atomic v1.11.0\n## explicit; go 1.18\ngo.uber.org/atomic\n# golang.org/x/mod v0.25.0\n## explicit; go 1.23.0\ngolang.org/x/mod/internal/lazyregexp\ngolang.org/x/mod/module\ngolang.org/x/mod/semver\n# golang.org/x/net v0.42.0\n## explicit; go 1.23.0\ngolang.org/x/net/http/httpguts\ngolang.org/x/net/http2\ngolang.org/x/net/http2/hpack\ngolang.org/x/net/idna\ngolang.org/x/net/internal/httpcommon\ngolang.org/x/net/internal/timeseries\ngolang.org/x/net/publicsuffix\ngolang.org/x/net/trace\ngolang.org/x/net/webdav\ngolang.org/x/net/webdav/internal/xml\n# golang.org/x/sync v0.16.0\n## explicit; go 1.23.0\ngolang.org/x/sync/errgroup\n# golang.org/x/sys v0.34.0\n## explicit; go 1.23.0\ngolang.org/x/sys/unix\ngolang.org/x/sys/windows\n# golang.org/x/text v0.27.0\n## explicit; go 1.23.0\ngolang.org/x/text/secure/bidirule\ngolang.org/x/text/transform\ngolang.org/x/text/unicode/bidi\ngolang.org/x/text/unicode/norm\n# golang.org/x/tools v0.34.0\n## explicit; go 1.23.0\ngolang.org/x/tools/go/ast/astutil\ngolang.org/x/tools/go/buildutil\ngolang.org/x/tools/go/internal/cgo\ngolang.org/x/tools/go/loader\ngolang.org/x/tools/imports\ngolang.org/x/tools/internal/event\ngolang.org/x/tools/internal/event/core\ngolang.org/x/tools/internal/event/keys\ngolang.org/x/tools/internal/event/label\ngolang.org/x/tools/internal/gocommand\ngolang.org/x/tools/internal/gopathwalk\ngolang.org/x/tools/internal/imports\ngolang.org/x/tools/internal/modindex\ngolang.org/x/tools/internal/stdlib\n# google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b\n## explicit; go 1.23.0\ngoogle.golang.org/genproto/googleapis/rpc/status\n# google.golang.org/grpc v1.76.0\n## explicit; go 1.24.0\ngoogle.golang.org/grpc\ngoogle.golang.org/grpc/attributes\ngoogle.golang.org/grpc/backoff\ngoogle.golang.org/grpc/balancer\ngoogle.golang.org/grpc/balancer/base\ngoogle.golang.org/grpc/balancer/endpointsharding\ngoogle.golang.org/grpc/balancer/grpclb/state\ngoogle.golang.org/grpc/balancer/pickfirst\ngoogle.golang.org/grpc/balancer/pickfirst/internal\ngoogle.golang.org/grpc/balancer/pickfirst/pickfirstleaf\ngoogle.golang.org/grpc/balancer/roundrobin\ngoogle.golang.org/grpc/binarylog/grpc_binarylog_v1\ngoogle.golang.org/grpc/channelz\ngoogle.golang.org/grpc/codes\ngoogle.golang.org/grpc/connectivity\ngoogle.golang.org/grpc/credentials\ngoogle.golang.org/grpc/credentials/insecure\ngoogle.golang.org/grpc/encoding\ngoogle.golang.org/grpc/encoding/proto\ngoogle.golang.org/grpc/experimental/stats\ngoogle.golang.org/grpc/grpclog\ngoogle.golang.org/grpc/grpclog/internal\ngoogle.golang.org/grpc/internal\ngoogle.golang.org/grpc/internal/backoff\ngoogle.golang.org/grpc/internal/balancer/gracefulswitch\ngoogle.golang.org/grpc/internal/balancerload\ngoogle.golang.org/grpc/internal/binarylog\ngoogle.golang.org/grpc/internal/buffer\ngoogle.golang.org/grpc/internal/channelz\ngoogle.golang.org/grpc/internal/credentials\ngoogle.golang.org/grpc/internal/envconfig\ngoogle.golang.org/grpc/internal/grpclog\ngoogle.golang.org/grpc/internal/grpcsync\ngoogle.golang.org/grpc/internal/grpcutil\ngoogle.golang.org/grpc/internal/idle\ngoogle.golang.org/grpc/internal/metadata\ngoogle.golang.org/grpc/internal/pretty\ngoogle.golang.org/grpc/internal/proxyattributes\ngoogle.golang.org/grpc/internal/resolver\ngoogle.golang.org/grpc/internal/resolver/delegatingresolver\ngoogle.golang.org/grpc/internal/resolver/dns\ngoogle.golang.org/grpc/internal/resolver/dns/internal\ngoogle.golang.org/grpc/internal/resolver/passthrough\ngoogle.golang.org/grpc/internal/resolver/unix\ngoogle.golang.org/grpc/internal/serviceconfig\ngoogle.golang.org/grpc/internal/stats\ngoogle.golang.org/grpc/internal/status\ngoogle.golang.org/grpc/internal/syscall\ngoogle.golang.org/grpc/internal/transport\ngoogle.golang.org/grpc/internal/transport/networktype\ngoogle.golang.org/grpc/keepalive\ngoogle.golang.org/grpc/mem\ngoogle.golang.org/grpc/metadata\ngoogle.golang.org/grpc/peer\ngoogle.golang.org/grpc/resolver\ngoogle.golang.org/grpc/resolver/dns\ngoogle.golang.org/grpc/serviceconfig\ngoogle.golang.org/grpc/stats\ngoogle.golang.org/grpc/status\ngoogle.golang.org/grpc/tap\n# google.golang.org/protobuf v1.36.10\n## explicit; go 1.23\ngoogle.golang.org/protobuf/encoding/protodelim\ngoogle.golang.org/protobuf/encoding/protojson\ngoogle.golang.org/protobuf/encoding/prototext\ngoogle.golang.org/protobuf/encoding/protowire\ngoogle.golang.org/protobuf/internal/descfmt\ngoogle.golang.org/protobuf/internal/descopts\ngoogle.golang.org/protobuf/internal/detrand\ngoogle.golang.org/protobuf/internal/editiondefaults\ngoogle.golang.org/protobuf/internal/encoding/defval\ngoogle.golang.org/protobuf/internal/encoding/json\ngoogle.golang.org/protobuf/internal/encoding/messageset\ngoogle.golang.org/protobuf/internal/encoding/tag\ngoogle.golang.org/protobuf/internal/encoding/text\ngoogle.golang.org/protobuf/internal/errors\ngoogle.golang.org/protobuf/internal/filedesc\ngoogle.golang.org/protobuf/internal/filetype\ngoogle.golang.org/protobuf/internal/flags\ngoogle.golang.org/protobuf/internal/genid\ngoogle.golang.org/protobuf/internal/impl\ngoogle.golang.org/protobuf/internal/order\ngoogle.golang.org/protobuf/internal/pragma\ngoogle.golang.org/protobuf/internal/protolazy\ngoogle.golang.org/protobuf/internal/set\ngoogle.golang.org/protobuf/internal/strs\ngoogle.golang.org/protobuf/internal/version\ngoogle.golang.org/protobuf/proto\ngoogle.golang.org/protobuf/protoadapt\ngoogle.golang.org/protobuf/reflect/protoreflect\ngoogle.golang.org/protobuf/reflect/protoregistry\ngoogle.golang.org/protobuf/runtime/protoiface\ngoogle.golang.org/protobuf/runtime/protoimpl\ngoogle.golang.org/protobuf/types/known/anypb\ngoogle.golang.org/protobuf/types/known/durationpb\ngoogle.golang.org/protobuf/types/known/emptypb\ngoogle.golang.org/protobuf/types/known/timestamppb\n# gopkg.in/yaml.v2 v2.4.0\n## explicit; go 1.15\ngopkg.in/yaml.v2\n# gopkg.in/yaml.v3 v3.0.1\n## explicit\ngopkg.in/yaml.v3\n# github.com/go-chi/telemetry => github.com/Grekkq/telemetry v0.4.2-a\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "update"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_GetBucketAbac.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// Returns the attribute-based access control (ABAC) property of the general\n// purpose bucket. If the bucket ABAC is enabled, you can use tags for bucket\n// access control. For more information, see [Enabling ABAC in general purpose buckets]. Whether ABAC is enabled or\n// disabled, you can use tags for cost tracking. For more information, see [Using tags with S3 general purpose buckets].\n//\n// [Enabling ABAC in general purpose buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging-enable-abac.html\n// [Using tags with S3 general purpose buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging.html\nfunc (c *Client) GetBucketAbac(ctx context.Context, params *GetBucketAbacInput, optFns ...func(*Options)) (*GetBucketAbacOutput, error) {\n\tif params == nil {\n\t\tparams = &GetBucketAbacInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"GetBucketAbac\", params, optFns, c.addOperationGetBucketAbacMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*GetBucketAbacOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype GetBucketAbacInput struct {\n\n\t// The name of the general purpose bucket.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// The Amazon Web Services account ID of the general purpose bucket's owner.\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *GetBucketAbacInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\n}\n\ntype GetBucketAbacOutput struct {\n\n\t// The ABAC status of the general purpose bucket.\n\tAbacStatus *types.AbacStatus\n\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationGetBucketAbacMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpGetBucketAbac{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpGetBucketAbac{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"GetBucketAbac\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpGetBucketAbacValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opGetBucketAbac(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addGetBucketAbacUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *GetBucketAbacInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opGetBucketAbac(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"GetBucketAbac\",\n\t}\n}\n\n// getGetBucketAbacBucketMember returns a pointer to string denoting a provided\n// bucket member valueand a boolean indicating if the input has a modeled bucket\n// name,\nfunc getGetBucketAbacBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*GetBucketAbacInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addGetBucketAbacUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getGetBucketAbacBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "create"
      },
      {
        "name": "vendor/github.com/aws/aws-sdk-go-v2/service/s3/api_op_PutBucketAbac.go",
        "content": "// Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage s3\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tawsmiddleware \"github.com/aws/aws-sdk-go-v2/aws/middleware\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\tinternalChecksum \"github.com/aws/aws-sdk-go-v2/service/internal/checksum\"\n\ts3cust \"github.com/aws/aws-sdk-go-v2/service/s3/internal/customizations\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3/types\"\n\t\"github.com/aws/smithy-go/middleware\"\n\tsmithyhttp \"github.com/aws/smithy-go/transport/http\"\n)\n\n// Sets the attribute-based access control (ABAC) property of the general purpose\n// bucket. When you enable ABAC, you can use tags for bucket access control.\n// Additionally, when ABAC is enabled, you must use the [TagResource], [UntagResource], and [ListTagsForResource] actions to manage\n// bucket tags, and you can nolonger use the [PutBucketTagging]and [DeleteBucketTagging] actions to tag the bucket. You\n// must also have the correct permissions for these actions. For more information,\n// see [Enabling ABAC in general purpose buckets].\n//\n// [PutBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketTagging.html\n// [DeleteBucketTagging]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_DeleteBucketTagging.html\n// [TagResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_TagResource.html\n// [UntagResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_UntagResource.html\n// [Enabling ABAC in general purpose buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging-enable-abac.html\n// [ListTagsForResource]: https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_ListTagsForResource.html\nfunc (c *Client) PutBucketAbac(ctx context.Context, params *PutBucketAbacInput, optFns ...func(*Options)) (*PutBucketAbacOutput, error) {\n\tif params == nil {\n\t\tparams = &PutBucketAbacInput{}\n\t}\n\n\tresult, metadata, err := c.invokeOperation(ctx, \"PutBucketAbac\", params, optFns, c.addOperationPutBucketAbacMiddlewares)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tout := result.(*PutBucketAbacOutput)\n\tout.ResultMetadata = metadata\n\treturn out, nil\n}\n\ntype PutBucketAbacInput struct {\n\n\t// The ABAC status of the general purpose bucket. When ABAC is enabled for the\n\t// general purpose bucket, you can use tags to manage access to the general purpose\n\t// buckets as well as for cost tracking purposes. When ABAC is disabled for the\n\t// general purpose buckets, you can only use tags for cost tracking purposes. For\n\t// more information, see [Using tags with S3 general purpose buckets].\n\t//\n\t// [Using tags with S3 general purpose buckets]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/buckets-tagging.html\n\t//\n\t// This member is required.\n\tAbacStatus *types.AbacStatus\n\n\t// The name of the general purpose bucket.\n\t//\n\t// This member is required.\n\tBucket *string\n\n\t// Indicates the algorithm that you want Amazon S3 to use to create the checksum.\n\t// For more information, see [Checking object integrity]in the Amazon S3 User Guide.\n\t//\n\t// [Checking object integrity]: https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html\n\tChecksumAlgorithm types.ChecksumAlgorithm\n\n\t// The MD5 hash of the PutBucketAbac request body.\n\t//\n\t// For requests made using the Amazon Web Services Command Line Interface (CLI) or\n\t// Amazon Web Services SDKs, this field is calculated automatically.\n\tContentMD5 *string\n\n\t// The Amazon Web Services account ID of the general purpose bucket's owner.\n\tExpectedBucketOwner *string\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (in *PutBucketAbacInput) bindEndpointParams(p *EndpointParameters) {\n\n\tp.Bucket = in.Bucket\n\n}\n\ntype PutBucketAbacOutput struct {\n\t// Metadata pertaining to the operation's result.\n\tResultMetadata middleware.Metadata\n\n\tnoSmithyDocumentSerde\n}\n\nfunc (c *Client) addOperationPutBucketAbacMiddlewares(stack *middleware.Stack, options Options) (err error) {\n\tif err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {\n\t\treturn err\n\t}\n\terr = stack.Serialize.Add(&awsRestxml_serializeOpPutBucketAbac{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = stack.Deserialize.Add(&awsRestxml_deserializeOpPutBucketAbac{}, middleware.After)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := addProtocolFinalizerMiddlewares(stack, options, \"PutBucketAbac\"); err != nil {\n\t\treturn fmt.Errorf(\"add protocol finalizers: %v\", err)\n\t}\n\n\tif err = addlegacyEndpointContextSetter(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLoggerMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientRequestID(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputeContentLength(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addResolveEndpointMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addComputePayloadSHA256(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRetry(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addRawResponseToMetadata(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecordResponseTiming(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSpanRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addClientUserAgent(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketContextMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addTimeOffsetBuild(stack, c); err != nil {\n\t\treturn err\n\t}\n\tif err = addUserAgentRetryMode(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addIsExpressUserAgent(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestChecksumMetricsTracking(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addCredentialSource(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addOpPutBucketAbacValidationMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = stack.Initialize.Add(newServiceMetadataMiddleware_opPutBucketAbac(options.Region), middleware.Before); err != nil {\n\t\treturn err\n\t}\n\tif err = addMetadataRetrieverMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRecursionDetection(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketAbacInputChecksumMiddlewares(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addPutBucketAbacUpdateEndpoint(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addResponseErrorMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = v4.AddContentSHA256HeaderMiddleware(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = disableAcceptEncodingGzip(stack); err != nil {\n\t\treturn err\n\t}\n\tif err = addRequestResponseLogging(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addDisableHTTPSMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addSerializeImmutableHostnameBucketMiddleware(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptBeforeRetryLoop(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptAttempt(stack, options); err != nil {\n\t\treturn err\n\t}\n\tif err = addInterceptors(stack, options); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *PutBucketAbacInput) bucket() (string, bool) {\n\tif v.Bucket == nil {\n\t\treturn \"\", false\n\t}\n\treturn *v.Bucket, true\n}\n\nfunc newServiceMetadataMiddleware_opPutBucketAbac(region string) *awsmiddleware.RegisterServiceMetadata {\n\treturn &awsmiddleware.RegisterServiceMetadata{\n\t\tRegion:        region,\n\t\tServiceID:     ServiceID,\n\t\tOperationName: \"PutBucketAbac\",\n\t}\n}\n\n// getPutBucketAbacRequestAlgorithmMember gets the request checksum algorithm\n// value provided as input.\nfunc getPutBucketAbacRequestAlgorithmMember(input interface{}) (string, bool) {\n\tin := input.(*PutBucketAbacInput)\n\tif len(in.ChecksumAlgorithm) == 0 {\n\t\treturn \"\", false\n\t}\n\treturn string(in.ChecksumAlgorithm), true\n}\n\nfunc addPutBucketAbacInputChecksumMiddlewares(stack *middleware.Stack, options Options) error {\n\treturn addInputChecksumMiddleware(stack, internalChecksum.InputMiddlewareOptions{\n\t\tGetAlgorithm:                     getPutBucketAbacRequestAlgorithmMember,\n\t\tRequireChecksum:                  false,\n\t\tRequestChecksumCalculation:       options.RequestChecksumCalculation,\n\t\tEnableTrailingChecksum:           false,\n\t\tEnableComputeSHA256PayloadHash:   true,\n\t\tEnableDecodedContentLengthHeader: true,\n\t})\n}\n\n// getPutBucketAbacBucketMember returns a pointer to string denoting a provided\n// bucket member valueand a boolean indicating if the input has a modeled bucket\n// name,\nfunc getPutBucketAbacBucketMember(input interface{}) (*string, bool) {\n\tin := input.(*PutBucketAbacInput)\n\tif in.Bucket == nil {\n\t\treturn nil, false\n\t}\n\treturn in.Bucket, true\n}\nfunc addPutBucketAbacUpdateEndpoint(stack *middleware.Stack, options Options) error {\n\treturn s3cust.UpdateEndpoint(stack, s3cust.UpdateEndpointOptions{\n\t\tAccessor: s3cust.UpdateEndpointParameterAccessor{\n\t\t\tGetBucketFromInput: getPutBucketAbacBucketMember,\n\t\t},\n\t\tUsePathStyle:                   options.UsePathStyle,\n\t\tUseAccelerate:                  options.UseAccelerate,\n\t\tSupportsAccelerate:             true,\n\t\tTargetS3ObjectLambda:           false,\n\t\tEndpointResolver:               options.EndpointResolver,\n\t\tEndpointResolverOptions:        options.EndpointOptions,\n\t\tUseARNRegion:                   options.UseARNRegion,\n\t\tDisableMultiRegionAccessPoints: options.DisableMultiRegionAccessPoints,\n\t})\n}\n",
        "directory": "/",
        "type": "file",
        "support_file": false,
        "content_encoding": "",
        "deleted": false,
        "operation": "create"
      }
    ],
    "base-commit-sha": "ef33860e2034fd2020c7384c7a5406ff01e74f93",
    "commit-message": "Bump github.com/aws/aws-sdk-go-v2/service/s3 from 1.91.1 to 1.92.0\n\nBumps [github.com/aws/aws-sdk-go-v2/service/s3](https://github.com/aws/aws-sdk-go-v2) from 1.91.1 to 1.92.0.\n- [Release notes](https://github.com/aws/aws-sdk-go-v2/releases)\n- [Changelog](https://github.com/aws/aws-sdk-go-v2/blob/main/changelog-template.json)\n- [Commits](https://github.com/aws/aws-sdk-go-v2/compare/service/s3/v1.91.1...service/s3/v1.92.0)",
    "pr-title": "Bump github.com/aws/aws-sdk-go-v2/service/s3 from 1.91.1 to 1.92.0",
    "pr-body": "Bumps [github.com/aws/aws-sdk-go-v2/service/s3](https://github.com/aws/aws-sdk-go-v2) from 1.91.1 to 1.92.0.\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/aws/aws-sdk-go-v2/commit/69a6df880a92d44f528b1754b680de66c2298c1b\"><code>69a6df8</code></a> Release 2025-11-20</li>\n<li><a href=\"https://github.com/aws/aws-sdk-go-v2/commit/d97cf39b76283caf92bd79d9e9c70d3a72dc5e59\"><code>d97cf39</code></a> Regenerated Clients</li>\n<li><a href=\"https://github.com/aws/aws-sdk-go-v2/commit/b3229249806091602f44b85e05a53ea5e99196f1\"><code>b322924</code></a> Update endpoints model</li>\n<li><a href=\"https://github.com/aws/aws-sdk-go-v2/commit/1869e8974eede203e6ba34df1f2ebed89db33066\"><code>1869e89</code></a> Update API model</li>\n<li>See full diff in <a href=\"https://github.com/aws/aws-sdk-go-v2/compare/service/s3/v1.91.1...service/s3/v1.92.0\">compare view</a></li>\n</ul>\n</details>\n<br />\n"
  }
}
